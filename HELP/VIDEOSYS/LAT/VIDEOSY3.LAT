
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-5.  Loading font pages on an MCGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Thus, displaying a new alphanumeric character set on the MCGA is a
     two-step process. First, you store character definition tables in one
     or more of the four 8 KB blocks of video RAM reserved for this
     purpose. Then you update the character generator's font pages to
     display the characters.


Using RAM-based Character Sets


     When you use characters defined in a RAM-based table, you must choose
     how the alphanumeric character generator is to decode the character
     codes and attributes stored in the displayed portion of the video
     buffer. Using the usual 256-character ASCII set, with 8-bit
     character codes and 8-bit attributes, is simplest. However,
     to display more than 256 different characters at once or to switch
     rapidly between character sets, you must use a wider range of

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     "extended" character codes and a different set of attributes.


ASCII Character Sets

     The simplest way to customize alphanumeric characters is to use 8-bit
     ASCII character codes and attributes with a RAM-based character
     definition table. Because there are only 256 ASCII character codes,
     you can display only one 256-character set at a time. However, the
     character codes and attribute bytes stored in the displayed portion of
     the video buffer retain their usual format, so software that knows
     nothing about the RAM-based character definitions can run unchanged
     while displaying the RAM-based character set.


     EGA, VGA, and MCGA
     Whenever you select an alphanumeric video mode using the video BIOS,
     the alphanumeric character generator is configured to display the
     characters defined in the first table in character generator RAM.
     Thus, to display a different set of ASCII characters, all you need do
     is update the table. As described above, INT 10H function 11H provides
     a convenient mechanism for doing this. This same BIOS function also
     lets you display the 256 characters defined in any of the other
     character definition tables as described later in this chapter.


     HGC+ and InColor Card
     When you power up an HGC+ or an InColor Card, the alphanumeric
     character generator uses the ROM-based character definition table by
     default. To display a different ASCII character set, configure the
     alphanumeric character generator to use the RAM-based table (see
     Listing 10-6) and then load a character definition table into video
     RAM at B000:4000.

     To do this, set bit 0 of the adapter's xMode register (14H) to 1. This
     causes the adapter to display the characters defined in the table in
     RAM at B000:4000. Also, set bit 0 of the Configuration Switch register
     (3BFH) to 1 to make character generator RAM addressable at B000:4000.
     (This configuration is called "4K RamFont mode" in Hercules
     documentation.) After you update character generator RAM, you can
     protect it from subsequent modification by resetting bit 0 of the
     Configuration Switch register.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-6.  Configuring an HGC+ or InColor Card for updating
     character generator RAM.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Updating character generator RAM is more complicated on the InColor
     Card because all four bit planes are used for character definitions.
     The complexity lies in the way colors are displayed for characters
     defined in the bit planes. A character's color is determined not only
     by its foreground and background attributes, but also by the bit
     planes used to define its pixel pattern.

     The InColor Card combines the pixel values in a character definition
     (in character generator RAM) with the character's foreground and
     background attributes (in the displayed portion of the video buffer)
     to produce a 4-bit attribute for every pixel in the character. The
     logic used is:

     (pixel_value AND foreground_attribute) OR 

     (NOT pixel_value AND background_attribute)

     In the example in Figure 10-11, one of the pixels in a character has a
     value of 2 (0010B) in the character definition table. The character's
     attribute byte in the video buffer specifies a foreground value of 0
     and a background value of 7 (0111B). The InColor Card thus displays
     this pixel with an attribute of (2 AND 0) OR (NOT 2 AND 7), or 5.


                                 AND
      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄşÄÄÄÄÄ 0101 ÄÄ¿
      ³ Background                ³              ³
      ³ attribute               1101             ³
 ±±±±±±±±±±                        NOT          ³
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÚÄÄÄÄÄÁÄÄÄÄÄ¿        ³                 6-bit
³0  1  1  1  0  0  0  0 ³   ³0  0  1  0 ³     OR şÄ0101ÄPaletteÄdigital
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ÀÄÄÄÄÄÂÄÄÄÄÄÙ        ³                 output
             ±±±±±±±±±±           ³ Character definition pixel
       Foreground ³               ³              ³
        attribute ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄşÄÄÄÄÄ 0000 ÄÄÙ
                                 AND

     Figure 10-11.  InColor foreground color attribute decoding using RAM-
     based character definitions (8-bit character codes). The pixel value
     in the character definition and both attributes in the character's
     attribute byte all contribute to foreground attribute decoding.


     Using colors on the InColor Card is simpler if you load all four bit
     planes with identical bit patterns so that all pixels in the character
     definitions have the value 0FH (1111B). Then a character's foreground
     and background attributes depend solely on the values in its attribute
     byte. Alternatively, you can specify a foreground attribute of 0FH
     (1111B) and a background attribute of 0 for every character in the
     video buffer. In this case, the displayed colors depend solely on the
     pixel values in the character definitions.

     A more practical use of the InColor Card's character definition RAM is
     to load each bit plane with a different character definition table.
     Then each bit in a character's foreground attribute acts as a mask to
     select a different character set. Of course, a 4-bit foreground
     attribute is still generated, as in Figure 10-11, so in effect each
     character set is associated with the color that corresponds to its bit
     plane. You can, of course, display the character sets in any colors
     you want by programming the palette registers.

     To load the bit planes separately, use the high-order nibble in the
     Plane Mask register (18H) to write-protect the bit planes each time
     you load a different character set. This permits you to use different
     foreground attributes to display the different character sets. For
     example, if all four bit planes contain different character sets, you
     can select each of the four character sets by using the foreground
     attributes 1, 2, 4, and 8.


Extended Character Sets

     All of the video subsystems discussed in this chapter have enough
     character generator RAM to store definitions for more than 256
     characters, so they all provide a way for the character generator to
     recognize extended character codes larger than the usual eight bits.


     EGA and VGA
     On the EGA and the VGA, the usual range of 256 ASCII codes is doubled
     by using bit 3 of a character's attribute byte to designate one of the
     character definition tables in map 2 (see Figure 10-12). In this way,
     512 different characters can be displayed in an alphanumeric mode.

     Normally, the value of bit 3 of a character's attribute byte does not
     affect the character set displayed. This is why: The value of this bit
     selects one of two bit fields in the Sequencer Character Map Select
     register. In turn, the value in each of these two bit fields
     designates one of the available character definition tables in RAM.
     When the video BIOS establishes a video mode, it loads a default set
     of character definitions into the first character definition table in
     map 2 and clears both bit fields in the Character Map Select register.
     Thus, default alphanumeric characters are defined by the bit patterns
     in the first table in map 2, regardless of the value of bit 3 of the
     attribute bytes of the characters displayed.

     Changing the value in the Character Map Select register, however,
     changes the character definition tables associated with bit 3 of each
     character's attribute byte. If two different values appear in the bit
     fields in the Character Map Select register, the value of bit 3
     designates one of two different character definition tables. 


     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 
    ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
    ³High-order byte³Low-order byte ³
    ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
     º º º º º º º º ³ ³ ³ ³ ³ ³ ³ ³ 
     º º º º º º º º ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÄÄÄÄ8-bit character code
     º º º º ÈÍÊÍÊÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ4-bit foreground attribute
     ÈÍÊÍÊÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ4-bit background attribute
   a.

     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 
    ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
    ³High-order byte³Low-order byte ³
    ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
     º º º º º³º º º ³ ³ ³ ³ ³ ³ ³ ³ 
     º º º º ºÀÎÄÎÄÎÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÄÄÄÄ9-bit extended character code
     º º º º ÈÍÊÍÊÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ4-bit foreground attribute
     ÈÍÊÍÊÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ4-bit background attribute
   b.

     7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 
    ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
    ³High-order byte³Low-order byte ³
    ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
     º º º º ³ ³ ³ ³ ³ ³ ³ ³ ³ ³ ³ ³ 
     º º º º ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÄÄÄÄ12-bit extended character code
     ÈÍÊÍÊÍÊÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ4-bit attribute
   c.

     Figure 10-12.  Character codes and attributes. Figure 10-12a shows the
     usual 8-bit format. Figure 10-12b shows the extended 9-bit format used
     on the EGA, VGA, and MCGA. Figure 10-12c shows the extended 12-bit
     format used on the HGC+ and InColor Card.


     For example, in Figure 10-13, bit 3 is set to 1, so bits 2, 3, and 5
     of the Character Map Select register designate which character
     definition table to use. (This example pertains to the VGA; on the
     EGA, only bits 2 and 3 of the Character Map Select value would be
     meaningful.)


               ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿
 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄ¿ ³
 ³ x  x  x  x  1  x  x  x ³ ³

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³                                      Offset
       Attribute byte       ³               3-bit value            in map 2
                                                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
               Character Map Select register  111³                 ³
                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´E000H
                ³ 0   x   1   0    x   x ³    011³                 ³
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´C000H
                  ±±±±±±±±±±±±±               110³                 ³
                        ³                        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´A000H
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ010³                 ³
                                                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´8000H
                                              101³                 ³
                                                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´6000H
                                              001³                 ³
                                                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´4000H
                                              100³                 ³
                                                 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´2000H
                                              000³                 ³
                                                 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ0

     Figure 10-13.  Function of the VGA Character Map Select register.


     Listing 10-7 illustrates two methods of updating this register.
     Although the technique of using an INT 10H function call generally
     requires less code and is more portable, you might prefer to program
     the Sequencer directly in applications that require rapid switching
     between character sets.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-7.  Programming the Sequencer Character Map Select
     register on the EGA and VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     If both bit fields in the Character Map Select register contain the
     same value, the value of bit 3 of a character's attribute byte does
     not affect which character set is used. If the bit fields designate
     different character definition tables, then the value of bit 3 of each
     character's attribute byte selects between two different character
     sets. Keep in mind, however, that bit 3 is also part of each
     character's 4-bit foreground attribute. When bit 3 of a character's
     foreground attribute is set to 0, the character's displayed color is
     taken from one of the first eight palette registers (0000B through
     0111B). When bit 3 is set to 1, the color derives from one of the
     second eight palette registers (1000B through 1111B).

     Thus, the two 256-character sets selected by bit 3 are displayed with
     two different sets of eight palette register values. This is handy if
     you want to associate a particular set of colors with a character set.
     Otherwise, you might prefer to load the second eight palette registers
     with the same set of values as the first eight so that the value of
     bit 3 of a character's attribute byte has no effect on its displayed
     color. Another technique is to mask bit 3 of the foreground attribute
     by zeroing bit 3 of the Attribute Controller's Color Plane Enable
     register, as in Listing 10-8. Because the value in the Color Plane
     Enable register masks the 4-bit attribute value, zeroing bit 3 in this
     register allows only the first eight palette registers to be
     referenced, regardless of the value of bit 3 in a character's
     attribute byte.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-8.  Zeroing bit 3 of the Color Plane Enable register. This
     causes bit 3 of a character's attribute byte to have no effect on its
     displayed attribute.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     MCGA
     The MCGA supports 8-bit and 9-bit character codes with the same BIOS
     interface as the EGA and VGA, although the hardware implementation is
     different. On the MCGA, the two character definition tables selected
     by bit 3 of a character's attribute byte are the ones in the MCGA's
     two internal font pages. Although you can load the font pages by
     programming the MCGA's Character Generator Interface register (12H),
     Character Font Pointer register (13H), and Number of Characters to
     Load register (14H), it is easier to use INT 10H function 11H with
     AL = 3.

     As on the EGA and VGA, bit 3 of a character's attribute byte does
     double duty as part of the 9-bit character code as well as the high-
     order bit of the character's foreground attribute. If you want to use
     the same colors for both 256-character sets, you can call INT 10H
     function 10H to store the same set of color values in the second eight
     video DAC color registers as you do in the first eight. You can also
     call INT 10H function 10H to mask bit 3 out of alphanumeric attribute
     decoding (see Listing 10-8).


     HGC+ and InColor Card
     On the HGC+ and the InColor Cards, you can configure the character
     generator to regard the four low-order bits of each character's
     attribute byte as part of the character code. Do this by setting both
     bit 2 and bit 1 of the xMode register to 1. (Hercules calls this
     configuration "48K RamFont mode.")

     By using 12-bit character codes, you can display all characters
     defined anywhere in the Hercules adapter's 48 KB of character
     generator RAM. In practice, you can regard all 48 KB of character
     generator RAM as one continuous character definition table. However,
     in some applications, you might find it more convenient to think of
     character generator RAM as a set of twelve 256-character tables, where
     the four high-order bits of the character code designate one of the
     tables, and the eight low-order bits designate a character definition
     within a table.

     When 12 bits are used as an extended character code, only bits 4
     through 7 of the high-order byte specify a character's attribute (see
     Figure 10-12c). The attributes that Hercules assigned to these bits
     differ somewhat from the usual monochrome display attributes (see
     Figure 10-14).


               Enable Blink Bit = 1  Enable Blink Bit = 0
Attribute Bit  (blink enabled)       (blink disabled)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
7              High-intensity        Boldface
6              Blink                 Reverse
5              Overstrike            No overstrike
4              Underline             No underline
     Figure 10-14.  Extended attribute set on the HGC+ and the InColor
     Card.


       ÉÍÍÍ»     When using 12-bit character codes on the HGC+ and the 
       º T º     InColor Card, you can specify the scan line on which the 
       º I º     overstrike and underscore attributes appear. Bits 0 
       º P º     through 3 of the Underscore register (15H) control the 
       ÈÍÍÍ¼     position of the underscore. Bits 0 through 3 of the 
                 Overstrike register (16H) control the position of the 
                 overstrike. On the InColor Card, you can also control the 
                 displayed color of the underscore and overstrike by 
                 storing a value between 1 and 0FH in bits 4 through 7 of 
                 the corresponding control register.

     As on the HGC+, the 12-bit character codes on the InColor Card
     designate locations in the character definition tables. Attribute
     decoding is more complicated on the InColor Card, however (see Figure
     10-15). The 4-bit foreground attribute generated for each pixel in a
     character is derived by combining the character's 4-bit attribute with
     the pixel's value in the character definition table.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA-compatible Attributes (Exception register bit 5 = 1)
              Enable Blink On                 Enable Blink Off
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Foreground    (pixel value) OR (background)   (pixel value) XOR 
                                              (background)
Background    0 if bit 7 of attribute = 0     0 if bit 6 of attribute = 0
              8 if bit 7 of attribute = 1     0FH if bit 6 of attribute = 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Color Attributes (Exception register bit 5 = 0)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Foreground    (pixel value) AND (NOT attribute)
Background    0 

     Figure 10-15.  InColor Card color attribute decoding using 12-bit
     character codes.


     As was the case when using 8-bit character codes, the peculiar
     interaction of character attributes with the pixel values in the
     character definition table makes controlling colors difficult. To
     simplify matters, you can store the same character definitions in all
     four bit planes when using color attribute decoding; this allows each
     character's 4-bit attribute to specify all 16 colors. When using MDA-
     compatible attributes, you can store the same bit patterns in bit
     planes 0 through 2 and zero bit plane 3. Again, this allows each
     character's 4-bit attribute to completely control the displayed
     attributes.

     If you elect to store different character definition tables in each
     bit plane, each of a character's attribute bits can select one of the
     bit planes. Again, you should program the palette registers carefully
     so that characters from different bit planes are displayed with
     appropriate colors.


Compatibility Problems with Extended Character Codes

     Most PC and PS/2 programs, including the BIOS, MS-DOS, and most
     commercially available applications, expect you to use 8-bit ASCII
     character codes. This means you can update character generator RAM
     with an 8-bit ASCII character set in a different font, but you cannot
     take advantage of the extended 9-bit or 12-bit character codes
     supported by IBM and Hercules.

     If you use the INT 10H interface to display characters with extended
     character codes, you must be careful when you use certain ROM BIOS
     functions. For example, INT 10H function 0AH, which stores an 8-bit
     character code in the video buffer, is not very useful for writing

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     characters with a 9-bit or a 12-bit extended character code. On the
     other hand, you can use INT 10H function 9, which handles a 16-bit
     character code and attribute combination, to process extended
     character codes and attributes.

     When you run an application that uses extended character codes, you
     can encounter problems when your application interacts inadvertently
     with software that doesn't recognize the different character-attribute
     format. Consider what might happen if a RAM-resident utility program
     popped up in the middle of your application without being "aware" that
     you were using extended character codes. When the utility program
     placed 8-bit character codes and attributes in the buffer, the
     alphanumeric character generator would interpret them as extended
     character codes and attributes. The results would probably be
     unusable.


Changing the Displayed Character Matrix


     There is another dimension to customizing a RAM-based character
     definition table: You can control the height of the character matrix
     in which characters are displayed. The height of the displayed
     character matrix determines how many rows of characters appear on the
     screen. For example, a 350-line display accommodates 43 rows of 8-by-8
     characters but only 25 rows of 8-by-14 characters.

     With all of the subsystems discussed in this chapter, you can vary the
     displayed height of alphanumeric characters by programming the CRT
     Controller to display characters the same size as the characters
     defined in character generator RAM. Thus, to display 8-by-8 characters
     on a 350-line display, you place 8-by-8 character definitions into
     character generator RAM and then program the CRTC to display
     characters that are 8 pixels high.

     On the EGA and the VGA, you can perform both these tasks by calling
     INT 10H function 11H, although in some situations you may prefer to
     update the character definitions or program the CRTC explicitly.
     Hercules adapters, of course, have no ROM BIOS, so you must do the
     work yourself.


EGA

     Consider how you would display 43 rows of 8-by-8 characters in an EGA
     alphanumeric mode with 350-line vertical resolution, as in Listing 10-
     9. In this example, the call to INT 10H function 11H with AL = 12H
     copies the ROM's 8-by-8 character set (normally used in 200-line video
     modes) into the first of the four tables in map 2 and then calculates
     the proper CRTC register values based on the values of POINTS and ROWS
     in the BIOS Video Display Data Area.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-9.  Establishing an 80-by-43 alphanumeric mode on an EGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     INT 10H function 11H calls INT 10H function 1 to set the position of
     the alphanumeric cursor in the displayed character matrix. As
     described in Chapter 3, the EGA BIOS version of INT 10H function 1
     computes this cursor position incorrectly, leading to an improperly
     displayed cursor. Therefore, the routine in Listing 10-9 updates the
     CRTC Cursor Start and Cursor End registers directly.

       ÉÍÍÍ»     If your program changes the number of displayed character 
       º T º     rows, it should also call INT 10H function 12H to select 
       º I º     the EGA BIOS's alternate print screen routine. This 
       º P º     routine functions identically to the one in the 
       ÈÍÍÍ¼     motherboard BIOS except that it uses the Video Display 
                 Data Area value ROWS to determine how many lines to print. 
                 (The motherboard BIOS routine disregards ROWS and always 
                 prints 25 lines.)


VGA

     You can also use INT 10H function 11H on the VGA to establish an
     alphanumeric mode with a nondefault character matrix (see Listing
     10-10). On the VGA, you set the vertical resolution of the video mode
     using INT 10H function 12H (with BL = 30H) before calling function
     11H. Also, the cursor emulation computations are performed properly in
     the VGA BIOS, so no extra code is required to avoid cursor emulation
     on the VGA.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-10.  Establishing an 80-by-50 alphanumeric mode on a VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


MCGA

     The MCGA can only display characters with 2, 4, 6, 8, 10, 12, 14, or
     16 scan lines. (This is a limitation of the MCGA's Memory Controller.)
     To change the displayed character matrix, use INT 10H function 11H to
     load a new character set into the character generator. Then program
     the Scan Lines per Character register (09H) with a value from 0
     through 7; if the value is n, the number of scan lines displayed in
     the character matrix is (n + 1) * 2. Listing 10-11 shows how to set up
     an 8-by-10 character matrix using the MCGA's 400-line vertical
     resolution to produce 40 rows of 80 characters.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-11.  Establishing an 80-by-40 alphanumeric mode on an
     MCGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     For some values in the Scan Lines per Character register, the MCGA
     incorrectly displays the bottommost scan line of the screen.
     Specifically, when the value in the Scan Lines per Character register
     is 1, 3, 5, or 6, the MCGA replicates part of the topmost scan line on
     the screen at the bottom of the screen. Thus, you should generally
     avoid using these values for the Scan Lines per Character register.


HGC+ and InColor Card

     You must program the HGC+ CRTC explicitly to change the number of
     displayed lines in alphanumeric characters. The subroutine SetHercCRTC
     in Listing 10-14 illustrates a table-driven technique for setting up
     the CRTC's vertical timing parameters for a variety of character
     sizes. Figure 10-16 summarizes the CRTC timing parameters recommended
     by Hercules for any character matrix between 4 and 16 scan lines high
     as well as for characters that are either 8 or 9 pixels wide.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                    Width of Character Matrix
CRTC register      8 Pixels           9 Pixels
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H                6DH                61H 
01H                5AH                50H 
02H                5CH                52H 
03H                0FH                0FH 

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CRTC                  Height of Character Matrix (in pixels)
register  4    5    6    7    8    9    10   11   12   13   14   15   16
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
04H       5CH  4Ah  3DH  34H  2DH  28H  24H  20H  1DH  1BH  19H  17H  16H
05H       02H  00H  04H  06H  02H  01H  00H  07H  0AH  06H  06H  0AH  02H
06H       58H  46H  3AH  32H  2BH  26H  23H  1FH  1DH  1AH  19H  17H  15H
07H       59H  46H  3BH  33H  2CH  27H  23H  20H  1DH  1BH  19H  17H  16H

     Figure 10-16.  CRTC timing parameters for height and width of the
     alphanumeric character matrix (HGC+ and InColor Card).


     On the InColor Card, the techniques for changing the displayed
     character matrix parallel those used on the HGC+. The values you place
     in the CRTC registers for each possible character matrix are also the
     same.


     Programming Examples
     The routines on the following pages unify the programming techniques
     for changing the displayed character matrix on the EGA (see Listing
     10-12), on the VGA (see Listing 10-13), and on the HGC+ and InColor
     Card (see Listing 10-14). In each case, the function AlphaModeSet()
     programs the alphanumeric character generator and the CRTC to
     accommodate the dimensions of the specified character matrix and
     character code size.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-12.  Programming the EGA alphanumeric character
     size.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-13.  Programming the VGA alphanumeric character
     size.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-14.  Programming the alphanumeric character size on the
     HGC+ and InColor Card.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Graphics Windows in Alphanumeric Modes



Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     When you update a RAM-resident character definition table, you alter
     the appearance of any characters displayed using those definitions.
     The contents of the displayed portion of the video buffer need not be
     updated. You can exploit this characteristic of RAM-based character
     definitions to display pixel-addressable graphics images in an
     alphanumeric mode, thereby displaying text with maximum speed while
     including pixel-by-pixel graphics images on the same screen.

     The technique is similar on both IBM and Hercules subsystems. Tile an
     area of the screen with a sequence of characters whose attribute
     selects a character definition table that contains the graphics image
     (see Figure 10-17). The graphics image is created and modified by
     updating the appropriate character definitions in the table. You can
     regard the character definition table as a sort of virtual graphics
     buffer and access individual pixels within it just as you do in the
     usual graphics modes.

     On the InColor Card, you can specify the value of each individual
     pixel you store in the character definition table as though you were
     using 720-by-348 16-color graphics mode. On other subsystems, however,
     only one memory map is used for character definitions, so you do not
     have pixel-by-pixel attribute control. Instead, pixels in the
     character definition table have a value of 0 or 1; the attributes with
     which the character codes are stored in the video buffer determine the
     appearance of the pixels.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 10-17 is found on page 338     º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 10-17.  A tiled graphics window in an alphanumeric mode.


     Listing 10-15 illustrates the technique for producing a tiled graphics
     window in 80-column alphanumeric mode on the EGA and VGA. The first
     part of the program creates the tiled window by storing the second 128
     ASCII characters in four rows of 32 at the start of the video buffer
     (that is, in the upper left corner of the screen). Then the program
     clears the window by setting the second 128 character definitions to
     0.

     To update a pixel in the window, the subroutine SetPixel() computes a
     byte offset in the character definition table that corresponds to the
     pixel's location in the tiled window. As in graphics modes, the
     routine accesses each individual pixel with a bit mask.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-15.  Creating a tiled graphics window on the EGA or
     VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC+ and InColor Card

     Clearly, the size of a tiled graphics window is restricted if you use
     8-bit character codes because the 8-bit ASCII character set contains
     only 256 characters. If you configure a Hercules adapter for 12-bit
     character codes, however, you can create much larger tiled windows
     without running out of character codes. Also, you can create larger
     windows by displaying taller characters (that is, by increasing the
     height of the displayed character matrix). Of course, if you use
     taller characters you decrease the number of rows of text that you can
     display at the same time; this can be a drawback in some applications.

     You can use similar programming techniques for alphanumeric graphics
     on Hercules adapters and on IBM subsystems. For example, Listing
     10-15 can be modified for use with the HGC+ and InColor Card by
     changing the values of CGenDefSize and CharDefTable and removing the
     calls to the functions CGenModeSet() and CGenModeClear().

       ÉÍÍÍ»     In establishing a graphics window on a Hercules card, 
       º T º     avoid using a character matrix that is 9 pixels wide. 
       º I º     Because the ninth (rightmost) pixel in each character is 
       º P º     actually a hardware-generated copy of the eighth dot, you 
       ÈÍÍÍ¼     cannot control it independently by updating the character 
                 definition table.


EGA and VGA

     On the EGA and VGA, you can create larger tiled graphics windows if
     you use 9-bit extended character codes. For instance, you could
     dedicate one 256-character definition table to text characters and a
     second character definition table to graphics tiling characters.
     Nevertheless, the EGA and VGA are still limited to displaying no more
     than 512 different characters at a time, so the largest tiled graphics
     window is much smaller than it can be on a Hercules adapter.

       ÉÍÍÍ»     When you update pixels in the tiled window, you should 
       º T º     minimize  the number of times your program resets the
       º I º     Sequencer (for example, in the routines CGenModeSet() and 
       º P º     CGenModeClear()). If you reset the Sequencer each time 
       ÈÍÍÍ¼     you update a pixel, you might create screen interference. 
                 (Synchronizing Sequencer resets with the vertical retrace 
                 interval can eliminate this interference but can also 
                 greatly decrease the speed of a program.) If you draw a 
                 complicated graphics figure containing many pixels, draw 
                 the entire figure at one time as in Listing 10-15.


MCGA

     Character definition tables in MCGA character generator RAM are
     formatted differently than those on the EGA and VGA, so a routine that
     manipulates pixels in character generator RAM must address the tables
     differently (see Listing 10-16). Also, remember that the screen does
     not reflect changes to the MCGA's character definition tables until
     you load the character generator's font pages (see Listing 10-5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-16.  A routine to set pixels in a tiled graphics window on
     the MCGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



                    11  Bit Blocks and Animation


                           Bit Block Move
           CGA and MCGA ş EGA and VGA ş HGC ş InColor Card

                      Bitwise Pixel Operations
                        XOR ş NOT ş AND ş OR

                          Bit Block Tiling

                              Animation
                            XOR Animation
                     Overlapping Bit Block Moves

                       A Graphics-Mode Cursor
                        XOR ş Bit Block Move



     This chapter is about moving things around in the video buffer and on
     the screen. Some of the most useful and entertaining graphics-mode
     programs create the appearance of on-screen motion. Objects as mundane
     as a cursor or as unusual as an alien spaceship can appear to move
     across the screen if you erase them and then immediately redraw them
     in successive locations. PC and PS/2 video subsystems are not
     particularly well equipped to support this kind of real-time
     animation, but the techniques in this chapter should help you fully
     exploit their capabilities.

     You might think of video animation in the same context as video games,
     but animation has other uses in computer graphics. For instance, all
     interactive graphics programs require a moving cursor that allows the
     user to point to screen locations. Many drawing or design programs let
     the user move shapes and images around the screen. Robotic control
     programs indicate the status of a robot arm with an animated
     representation of its position. You can create such animation effects
     using the techniques in this chapter.


Bit Block Move


     The basic software tool for many animation techniques is the bit block
     move--a routine that copies a rectangular block of pixels into, out
     of, or within the video buffer. The name "bit block move" describes
     this routine well. After all, a rectangle of pixels is in essence
     nothing more than a block of bits. Still, a bit block move routine can
     do more than simply copy pixel values. As can other video graphics
     drawing routines, a bit block move routine can update pixel values
     using the bitwise logical operations AND, OR, and XOR. These
     operations can create attractive effects when used as part of bit
     block moves.

     To copy a bit block from one location to another within the video
     buffer in PC and PS/2 video subsystems, it is usually more efficient
     to use an intermediate buffer in system RAM. You first copy pixel
     values from the video buffer into the intermediate buffer, then copy
     the values from this buffer to the desired position in the video
     buffer.

     Creating an intermediate copy of the pixels in a bit block might seem
     superfluous, but in most situations it is preferable to trying to move
     the bit block entirely within the video buffer. For example, neither
     the EGA nor the InColor Card supports direct logical operations (AND,
     OR, and XOR) between pixels in the bit planes. Also, CPU accesses to
     video RAM are slower than equivalent accesses to system RAM. Thus,
     when multiple copies of the same bit block are to be stored in the
     video buffer, making a single copy in system RAM and then making
     multiple copies from system RAM to video RAM is more efficient.


CGA and MCGA


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     Listing 11-1 is a bit block move routine for the CGA. The routine
     GetBitBlock() copies a block of pixels from the video buffer to a
     buffer in system RAM. The complementary routine StoreBitBlock(), in
     Listing 11-2, copies pixels from system RAM to the video buffer.
     StoreBitBlock()contains subroutines to perform AND, OR, or XOR
     operations on the pixels in system RAM using the previous contents of
     the video buffer.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-1.  A routine to copy a block of pixels from the CGA video
     buffer to system RAM.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-2.  A routine to copy a block of pixels from system RAM to
     the CGA video buffer.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In the MCGA's 640-by-480 2-color and 320-by-200 256-color modes, pixel
     addressing is different than in the two CGA-compatible modes.
     Otherwise, versions of GetBitBlock() and StoreBitBlock() are similar
     in all MCGA modes.


EGA and VGA

     In native EGA and VGA graphics modes, the bit block move routine must
     move the contents of all four bit planes to system RAM. The
     GetBitBlock() routine in Listing 11-3 extracts bytes from each
     bit plane using read mode 0 and selecting each bit plane in turn with
     the Graphics Controller's Read Map Mask register. StoreBitBlock(), in
     Listing 11-4, then uses write mode 0 to copy data into the bit
     planes. The bit planes are isolated in write mode 0 by programming the
     Sequencer's Map Mask register.

     Do not use the routines in Listings 11-3 and 11-4 on an EGA with
     only 64 KB of video RAM. Because the memory maps are chained together
     to form the two bit planes used in 640-by-350 graphics modes, these
     routines will not work properly in this situation. (Chapter 4
     discusses this in greater detail.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-3.  A routine to copy a block of pixels from the EGA or VGA
     video buffer to system RAM in native graphics modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-4.  A routine to copy a block of pixels from system RAM
     to the EGA or VGA video buffer in native graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC

     Bit block move routines for HGC and HGC+ 720-by-348 monochrome
     graphics mode are similar routines for CGA 640-by-200 2-color mode.
     The differences  are in how they calculate pixel addresses and in the
     way the video buffer is interleaved.


InColor Card

     The routines for the InColor Card's 720-by-348 16-color mode resemble
     the EGA routines in Listings 11-3 and 11-4, because both adapters'
     video buffers are mapped in parallel bit planes. Differences between
     the routines lie in the way pixel addresses are computed, in how the
     video buffer is interleaved, and in how individual bit planes are
     accessed. On the InColor Card, you can use the same technique as
     ReadPixelInC() (discussed in Chapter 5) to program the Read/Write
     Control and Color registers and isolate the contents of each bit
     plane. Similarly, a bit block store routine for the InColor Card
     follows  StorePixelInC() in its use of the Plane Mask register and the
     Read/Write Control and Color registers.


Bitwise Pixel Operations


     If you experimented with the pixel-programming and line-drawing
     examples in previous chapters, you probably know why the bitwise
     logical operations--XOR, AND, and OR--are useful in video graphics
     programming. In this case, you can skip the next few paragraphs.
     Otherwise, read on to see how video graphics programs can exploit the
     ability to perform XOR, AND, and OR on pixel values.


XOR

     The XOR operation is useful because it is reversible. When you change
     a pixel's value in the video buffer using the XOR function, you can
     restore its original value by repeating the operation. For example, if
     a pixel in the video buffer has the value 9, setting its value by
     XORing it with a value of 5 results in a pixel value of 0CH. XORing
     the resulting pixel value (0CH) with a value of 5 restores the
     original pixel value of 9.

     This implies that you can XOR objects into the video buffer and onto
     the screen, and then erase them, without worrying about saving and
     restoring the contents of the video buffer. The use of XOR has
     limitations, however. One is that an image containing zero-value
     pixels cannot be XORed into the video buffer. Because XORing a pixel
     with 0 leaves the pixel's value unchanged, only nonzero pixels in the
     image affect the video buffer.

     Another more serious limitation is that a patterned background can
     obscure the image you are trying to XOR into the video buffer.
     Consider Figure 11-1, in which a text string is XORed against
     progressively distracting backgrounds. The text is perfectly readable
     against a solid background, but a striped background significantly
     obscures the letters. In the worst case, XORing a single-color image
     into a pattern of random pixels results only in another pattern of
     random pixels.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-1 is found on page 361      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-1.  Effects of XORing a text string against various
     backgrounds.


NOT

     A bitwise NOT operation on a pixel value toggles all 1 bits to 0 and
     all 0 bits to 1. Obviously, two sequential NOT operations will leave
     the pixel value unchanged. A common programming practice in monochrome
     graphics modes is to use NOT to toggle a reverse video state. For
     instance, a black-on-white character can be reversed to white-on-black
     by performing NOT operations on its pixels.

     The effect of NOT on multibit pixel values is less clear. In this
     situation, the NOT operation converts one pixel value into some other
     pixel value, but the colors corresponding to these two values may be
     unrelated. Thus, in a color graphics mode, performing a NOT operation
     on all pixels in a character matrix changes both the foreground and
     background values, but the resulting color combination may not be
     particularly attractive or even readable. In manipulating pixels in
     color graphics, use NOT with caution.

       ÉÍÍÍ»     A bitwise NOT is equivalent to performing a bitwise XOR
       º T º     using a binary value of all 1 bits. This means you can use
       º I º     any of the pixel XOR routines developed in this book to
       º P º     perform NOT operations as well. Thus, little can be gained
       ÈÍÍÍ¼     by writing special-purpose NOT routines for pixel
                 manipulation.


AND

     The bitwise logical operation AND is also useful in manipulating
     graphics images. Consider, for instance, how you might go about
     drawing the striped circle in Figure 11-2b. You could do it the hard
     way, by intersecting a set of parallel lines with the circle. This
     procedure would be laborious, however, because of the extra
     programming and increased computational overhead involved in
     determining the intersection points.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-2 is found on page 362      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-2.  Using AND to draw a striped circle. The circle in Figure
     11-2a consists of pixels of the maximum possible value. The lines are
     drawn across the circle using a pixel AND operation to produce the
     striped circle in Figure 11-2b.


     It is much easier to draw a filled circle (see Figure 11-2a) with
     pixels of the maximum possible value (that is, all bits set to 1)
     against a background of zero-value pixels. This circle is used as a
     mask against which you AND the pixels in the parallel lines. When
     pixels in each line are ANDed with pixels inside the circle, their
     original values are stored intact in the video buffer. Outside the
     circle, the result of ANDing the line pixels with the zero background
     always results in zero-value pixels being stored in the buffer. The
     result: a striped circle.

     You can apply this technique to any graphics form, but it is
     particularly attractive in conjunction with a bit block move routine.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     You can superimpose patterned images with a short sequence of bit
     block moves using pixel AND and OR operations. In Figure 11-3, a
     circular chunk of pattern B is superimposed on pattern A by using a
     mask to isolate a "hole" in pattern A. The inverse of the same mask
     extracts the congruent piece of pattern B. The two masked patterns are
     then superimposed by a third bit block move that uses OR (or XOR) to
     update pixels.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-3 is found on page 362      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-3.  Masking patterned images with pixel AND operations.


OR

     The bitwise OR operator is less frequently used than XOR for
     manipulating pixel values. The OR operation, unlike XOR or NOT, is not
     reversible. The result of ORing pixels always depends on their
     previous values in the video buffer.

     One typical use of the pixel OR operation is to accentuate
     intersections of forms in the video buffer. Consider what happens when
     you OR two different-colored areas into a 16-color video buffer (see
     Figure 11-4). If one rectangle is filled with pixels of value 3 and
     the other rectangle with pixels of value 5, the pixels at the
     intersection points have the value 7 (3 OR 5). With the usual default
     color palette, the upper rectangle appears cyan, the lower rectangle
     is violet, and the intersection is white.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿          
     ³°°°°°°°°°°°°°°°°°°°°³          
     ³°Cyan°°°°°°°°°°°°°°°³          
     ³°°°°°°°°°°°°°°°°°°°°³          
     ³°°°°°°°°°°ÚÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄ¿
     ³°°°°°°°°°°³         ³±±±±±±±±±³
     ³°°°°°°°°°°³ White   ³±±±±±±±±±³
     ³°°°°°°°°°°³         ³±±±±±±±±±³
     ÀÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÙ±±±±±±±±±³
                ³±±±±±±±±±±±±±±±±±±±³
                ³±±±±±±±±±±±±Violet±³
                ³±±±±±±±±±±±±±±±±±±±³
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 11-4.  ORing two colored areas into a 16-bit video buffer.


Bit Block Tiling


     You can use bit block move routines to fill an area of the video
     buffer with any arbitrary pattern. Do this by tiling the buffer
     through bit block moves to adjoining rectangular areas of the buffer
     (see Figure 11-5). Using the AND mask technique, you can fill any
     arbitrary form, such as the circle in Figure 11-6, with a pattern
     contained in a bit block.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-5 is found on page 363      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-5.  Bit block tiling.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-6 is found on page 364      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-6.  Tiling with AND mask.


       ÉÍÍÍ»     You can use a variation of bit block tiling as a sort of
       º T º     software character generator. If you define a group of bit
       º I º     blocks, each of which represents a character in a
       º P º     character set, you can tile the screen with characters.
       ÈÍÍÍ¼     This is one technique for displaying proportionally
                 spaced characters.


Animation


     PC and PS/2 video subsystems have no built-in hardware to support
     animation. Consequently, moving images across the screen is a task
     relegated to software. (This is a good reason to make your video
     graphics routines as efficient as possible.) Several software
     techniques can produce real-time video animation. Each technique is
     best suited to a particular type of animation.


XOR Animation

     You can take advantage of the reversibility of the logical XOR
     operation to make any pixel or set of pixels appear to move across the
     display. To make an object appear to move, XOR it into the video
     buffer twice. The object flickers onto the screen the first time it is
     drawn. It immediately disappears the second time it is drawn. If you
     repeatedly redraw the object in a slightly different position, it
     appears to move across the screen.


     Outlining
     Consider the C fragment in Listing 11-5. This bit of code makes a
     circle appear to grow outward from its center by repeatedly XORing it
     into the video buffer with a gradually increasing radius.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-5.  XORing a circle into the video buffer.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     This technique is frequently used interactively to outline a
     rectangular area of the display. The outline is rapidly XORed into and
     out of the video buffer as the user moves a pointing device such as a
     mouse. Just as the circle created by the routine in Listing 11-5
     appears to grow, a rectangular outline can appear to move, grow, or
     shrink in response to the user's actions.

     The routine in Listing 11-6 slides a rectangle across the screen. At
     each iteration, the rectangle is drawn and then erased using lines
     that are XORed into the video buffer. In this example, the rectangle's
     onscreen location is changed within an iterative loop. In practice,
     however, the rectangle's size and location could be changed in
     response to input from the keyboard or from a pointing device. In this
     case, the rectangle would be erased and redrawn whenever the input
     indicated a change in position.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-6.  XORing a rectangle into the video buffer.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Rubberbanding
     A related technique based on the XOR operation is rubberbanding, in
     which a moving object remains attached to a stationary object by a
     straight line. The technique is called rubberbanding because the line
     that connects the two objects appears to stretch as it moves. Listing
     11-7 is similar to Listing 11-6, but moves a rubberbanded line around
     the point at (150,100).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-7.  XORing a line into the video buffer.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Bit Block Moves
     You can use XOR with a bit block move to animate any arbitrary group
     of pixels. But use this technique only with a relatively small bit
     block, since generally a bit block contains many more pixels to be
     drawn and redrawn than does a line or a rectangle. The longer it takes
     to maneuver the bit block around the screen, the slower your video
     routine performs.


     Problems with XOR Animation
     Objects that are animated by XOR operations always flicker. The reason
     is obvious: An object is visible only after you first XOR it into the
     buffer. The second XOR makes it disappear. The resulting flicker draws
     attention to the animated object, and may be desirable, particularly
     if the object is repeatedly XORed even when you aren't moving it. On
     the other hand, the flickering can be distracting, particularly on
     color displays where the XORed object alternates between two garish
     colors.

     You can sometimes alleviate flickering during XOR animation by
     inserting a software "pause" between the first and second XOR
     operations. This pause can be an empty loop, a call to some short
     subroutine, or perhaps a wait for the next vertical blanking interval.
     In any case, because the XORed object remains on the screen slightly
     longer, it may flicker less.

     The animated image can disappear if the loop that performs the XOR
     operations inadvertently becomes synchronized with the display refresh
     cycle. In this situation, the animated object is never visible if both
     XOR operations occur outside the relatively brief time interval when
     the raster is displaying the relevant portion of the video buffer.
     Solving this sort of problem is tricky because it involves both the
     speed of your program and the size of the animated image.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


Overlapping Bit Block Moves

     In some applications, you can avoid XOR animation problems by rapidly
     redrawing a block of pixels in overlapping locations in the video
     buffer (see Figure 11-7 and Listing 11-8). The bit block in Figure
     11-7 has a margin of background pixels along its left edge. Each time
     you store the bit block in the video buffer, this margin overlaps the
     foreground pixels in the previously drawn block. Without this margin,
     unexpected streaks of foreground pixels trail the bit block as it
     moves to the right across the screen.

     Although they are fast enough for most purposes, the bit block move
     routines in this chapter are too slow for such performance-intensive
     applications as arcade-style video games. You can tailor the code in
     several ways to increase the animation speed if you're willing to
     sacrifice their general-purpose approach.


     ÚÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿        ÚÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄ¿
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ÃÄÄÄÄÄÄÄ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ³°°³                  ³        ³°°³°°³            |  ³
     |°°³                  ³        |°°³°°³            |  ³
     ÀÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ        ÀÄÄÁÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÙ
                                      
      ³                              ³  ³ Margin
      ³ Margin of                    ³
      ³ background pixels            ³ Previous margin
    a.            b.

     Figure 11-7.  Overlapping bit block moves. The bit block is drawn
     (Figure 11-7a), then drawn again slightly to the right (Figure
     11-7b). The margin of background pixels restores the background as
     the bit block is "moved" to the right.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 11-8.  A program to move a block of pixels using the
     overlapping technique.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     One technique is to limit the bit block routines to byte-aligned (or,
     on the CGA and the HGC, word-aligned) blocks of pixels. This
     eliminates much of the bit-mask logic and lets you make full use of
     the 80x86 MOVs instruction. Another approach is to write routines that
     handle bit blocks of a fixed, predetermined size. This lets you
     replace some iterative loops in the routines with repetitive sequences
     of in-line code. Unfortunately, even highly optimized CGA and EGA
     animation routines rarely come close to the speed you can expect from
     arcade-style video display hardware.


A Graphics-Mode Cursor


     In alphanumeric modes, the on-screen cursor indicates the location
     where your program expects the user's next input. Most alphanumeric-
     mode programs rely on the hardware-generated blinking cursor to
     indicate the current input location. In graphics modes, on the other
     hand, hardware does not support a cursor; your software must generate
     one.

     Implementing a cursor in a graphics mode is somewhat complicated,
     because you must draw the form that represents the cursor directly
     into the video buffer, while preserving the pixels that the operation
     overwrites. You can do this in two ways: by using XOR to display the
     cursor, or by saving and restoring the bit block that is overlaid by
     the cursor.


XOR

     The simplest way to display a graphics cursor is to XOR it into and
     then out of the video buffer. This technique is the same one used to
     animate graphics images, and the same pros and cons apply.

     Probably the worst side effect of XORing a graphics cursor into the
     video buffer is that the color displayed for the XORed cursor can
     change with the background. The cursor can all but disappear on a
     patterned background or on a background with a displayed color near
     that of the XORed cursor.

     Palette programming can prevent this problem. For example, the EGA
     palette in Figure 11-8 is set up assuming that all pixels in the
     cursor shape have the value 8 (1000B) and that all preexisting pixels
     in the video buffer have a value from 0 through 7. With this
     arrangement, XORing the cursor into the video buffer causes it always
     to be displayed with color value 3FH (high-intensity white). The
     obvious drawback is that this technique halves the number of colors
     you can display.


Palette Register   Color Value
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H                0
01H                1
02H                2
03H                3
04H                4
05H                5
06H                6
07H                7
08H                3FH
09H                3FH
0AH                3FH
0BH                3FH
0CH                3FH
0DH                3FH
0EH                3FH
0FH                3FH
     Figure 11-8.  EGA palette values for a high-intensity white XOR
     graphics cursor.


Bit Block Move

     Another approach is to make a copy of the bit block of pixels that the
     cursor replaces. You can then erase the cursor by restoring the pixels
     in the video buffer from the copy. This technique is attractive
     because it lets you use any means you choose to draw the cursor.

     A good way to draw the cursor, once you have made a copy of the
     underlying pixels in the video buffer, is to copy the cursor shape
     into the buffer with a bit block move. Obviously, this technique works
     best with a rectangular cursor. To draw a cursor of any arbitrary
     shape, use a two-step process (see Figure 11-9). First, zero a group
     of pixels in the shape of the cursor in the video buffer with a bit
     block AND operation. Then draw the cursor with a bit block OR or XOR
     operation.

       ÉÍÍÍ»     Whenever you use a graphics-mode cursor, you must ensure
       º T º     that the cursor is erased before updating the video
       º I º     buffer. If you do not, your program may inadvertently
       º P º     update the portion of the video buffer that contains the
       ÈÍÍÍ¼     cursor image. The next cursor move will restore the
                 contents of the buffer to what they were before the cursor
                 was drawn, leaving a "hole" where the cursor was (see
                 Figure 11-10).


     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛ     ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛÛÛ ÛÛÛ ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛ   ÛÛÛ   ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ         ÛÛÛÛÛÛÛ         ÛÛÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ         ÛÛÛÛÛÛÛ         ÛÛÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛ ÛÛÛÛÛÛÛÛÛ
     ÛÛÛ         ÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛ   ÛÛÛ   ÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ           ÛÛÛ           ÛÛÛÛÛÛÛÛÛÛÛ ÛÛÛ ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛ     ÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛ     ÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ                         ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
     a.                    b.                c.

     Figure 11-9.  Drawing a graphics cursor with a 2-step mask-and-replace
     technique: First, a mask (Figure 11-9a) is ANDed into the video
     buffer. Then the cursor shape (Figure 11-9b) is ORed into the buffer
     to give the result in Figure 11-9c.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 11-10 is found on page 371     º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 11-10.  If a graphics cursor is accidentally overwritten
     (Figure 11-10a), a "hole" appears when the cursor is erased (Figure
     11-10b).



           12  Some Advanced Video Programming Techniques


                    A Vertical Interrupt Handler
                         EGA and VGA ş MCGA

                     Panning on the EGA and VGA
               Positioning the Screen Window ş Panning
                      Resizing the Video Buffer

                         Bit-Plane Layering
                                  
                      EGA and VGA Split Screen
                                  
                       The Light Pen Interface
                Light Pen Position ş Light Pen Switch

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                  Determining Hercules Video Modes



     This chapter deals with some of the less frequently exploited
     capabilities of PC and PS/2 video subsystems. Most programmers do not
     concern themselves with these hardware features, because they are
     infrequently used in most video software. Still, each of these
     hardware features lends itself to programming techniques that can be
     used in certain applications where nothing else is as effective.

     Nothing in this chapter requires "gonzo programming" or any magical
     knowledge of the hardware. You should nevertheless be comfortable with
     80x86 assembly-language programming before tackling the details of
     this material. Most of the chapter describes programming techniques
     for the EGA and the VGA, but the discussions of the light pen
     interface and bit-plane layering are pertinent to Hercules adapters as
     well.


A Vertical Interrupt Handler


     It's neither the interrupt nor the handler that's vertical--it's the
     fact that the CRTC on the EGA, the VGA, and the MCGA can generate a
     hardware interrupt at the start of the vertical blanking interval,
     that is, at the start of the scan line after the bottom line of
     displayed video buffer data. An interrupt handler for this Vertical
     Interrupt can thus update the video buffer or program the video
     hardware without interfering with the display.

     The interrupt is generated on interrupt request line 2 (IRQ2). The
     computer's programmable interrupt controller (PIC) is set up during
     the ROM BIOS coldstart to map IRQ2 to interrupt vector 0AH, so a
     Vertical Interrupt handler should be designed to handle interrupt 0AH.

       ÉÍÍÍ»     The programmable interrupt controller used in the IBM PC,
       º T º     PC/AT, and PS/2 Models 50, 60, and 80 is the Intel 8259A;
       º I º     in the PS/2 Model 30, the same functions are supported in
       º P º     a proprietary VLSI chip, the I/O Support Gate Array. In
       ÈÍÍÍ¼     all cases, however, the programming interface to the PIC
                 for managing Vertical Interrupts is the same.


EGA and VGA

     The scan line number at which the interrupt is issued is 1 greater
     than the value in the CRTC's Vertical Display Enable End register
     (12H). The value in this register specifies the number of scan lines
     of video buffer data that are displayed, so the CRTC generates
     Vertical Interrupts at the start of the vertical blanking interval.

     Bits 4 and 5 of CRTC's Vertical Retrace End register (11H) control
     whether and when the CRTC  signals a Vertical Interrupt. You set bit 5
     to 1 to enable the CRTC to generate the interrupt. Bit 4 controls a 1-
     bit latch whose status appears in bit 7 of Input Status Register Zero
     (3C2H). You must zero bit 4 to clear the status latch. When you set
     bit 4 to 1, the latch status bit changes from 0 to 1 when the next
     vertical interrupt occurs, and remains set to 1 until you again clear
     the latch.

     To use the Vertical Interrupt feature, you must perform the following
     actions:

     ş  Point the interrupt 0AH vector to a Vertical Interrupt handler.

     ş  Enable IRQ2.

     ş  Enable the Vertical Interrupt.

     The routine in Listing 12-1 shows how to do this. Note how this
     routine is coordinated with the interrupt handler itself. The routine
     preserves the interrupt 0AH vector so the interrupt handler can chain
     to the previous handler if necessary, and so the routine can
     eventually restore the previous interrupt vector when the interrupt
     handler is no longer needed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-1.  Handling Vertical Interrupts on the EGA and VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The handler itself, in procedure ISR0A, gains control whenever
     interrupt 0AH occurs. To distinguish between the hardware Vertical
     Interrupt on IRQ2 and a possible software interrupt 0AH, the handler
     examines bit 7 of Input Status Register Zero. If this bit is 1, a
     Vertical Interrupt has occurred, and the handler continues about its
     business. If the bit is 0, no Vertical Interrupt has occurred, so the
     handler chains to the previous interrupt 0AH handler.

       ÉÍÍÍ»     A drawback to using the Vertical Interrupt is that any
       º T º     hardware interrupt on IRQ2 causes the status bit in Input
       º I º     Status Register Zero to be set. Thus, although the status
       º P º     bit can be used to detect software interrupt 0AH, an
       ÈÍÍÍ¼     interrupt handler cannot distinguish between EGA Vertical
                 Interrupts and IRQ2 interrupts generated by other hardware
                 unless the other hardware can be reliably interrogated.
                 Since some other IBM PC adapters can use IRQ2 (for
                 example, the bus version of the Microsoft Mouse), you can
                 reliably use the Vertical Interrupt only when certain
                 about the exact hardware configuration of the PC on which
                 your program is running. 

     Once the handler detects a Vertical Interrupt (that is, bit 7 of
     Input  Status Register Zero is 1), it issues a nonspecific end-of-
     interrupt (EOI) instruction to the interrupt controller so that
     subsequent IRQ2 interrupts can be processed. Reentrance is not a
     problem, because additional Vertical Interrupts will not be signalled
     until the handler itself clears and reenables the status latch. Once
     the EOI has been issued, the handler is free to perform some useful
     action. In this example, it simply increments a counter. Just before
     exiting, the handler reprograms the Vertical Retrace End register to
     enable the next Vertical Interrupt.

     The example in Listing 12-2 shows how you can integrate a Vertical
     Interrupt handler into a high-level program. The example is
     intentionally simple. It does nothing but count a designated number of
     Vertical Interrupts and display a message. Of course, your own
     Vertical Interrupt handler might perform more complicated actions than
     simply updating a variable. For instance, you could perform animation
     by updating the video buffer each time the interrupt occurs. You might
     also update the CRT and Attribute controllers to produce a panning
     effect using techniques described later in this chapter.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-2.  Using a Vertical Interrupt handler in a C program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Hardware support for the Vertical Interrupt feature can
       º T º     vary. IBM's VGA adapter, for example, does not support
       º I º     Vertical Interrupts at all. On some EGA clones, the
       º P º     polarity of bit 7 in Input Status Register Zero is
       ÈÍÍÍ¼     opposite to that of the equivalent EGA bit; that is, a
                 Vertical Interrupt has occurred when bit 7 is 0. (Second-
                 source manufacturers of EGA-compatible adapters do not
                 always emulate every detail of the EGA's occasionally
                 inscrutable hardware design.) To ensure that your Vertical
                 Interrupt handler works correctly on EGA clones, determine
                 the status bit's polarity when the bit is in a known state
                 and devise your test for the Vertical Interrupt
                 accordingly.


MCGA

     A Vertical Interrupt handler for the MCGA, such as the one in Listing
     12-3, is similar to the handler for the EGA and the VGA. On the MCGA,
     the Interrupt Control register (11H) contains the control and status
     bits used to set up and detect a Vertical Interrupt. Zeroing bit 5 of
     the Interrupt Control register enables the MCGA to generate a Vertical
     Interrupt. Zeroing bit 4 clears the interrupt status latch. Setting
     bit 4 to 1 allows the MCGA to detect subsequent interrupts. Bit 6 is
     the interrupt status bit. The MCGA sets this bit to 1 to indicate that
     a Vertical Interrupt has occurred.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-3.  Handling Vertical Interrupts on the MCGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     On the EGA and MCGA, if a Vertical Interrupt handler gains
       º T º     control while a video BIOS (INT 10H) function is
       º I º     executing, the interrupt handler may inadvertently disrupt
       º P º     BIOS CRTC programming. The reason can be traced to a
       ÈÍÍÍ¼     subroutine buried in the IBM BIOS in these video
                 subsystems. This subroutine is called by several video
                 BIOS routines to perform I/O port output to video hardware
                 registers, including CRT Controller, Sequencer, Graphics
                 Controller, and Attribute Controller registers.

                 Unfortunately, this subroutine is not impervious to
                 interrupts. It contains a sequence of two 8-bit port
                 writes (OUT DX,AL). The first OUT loads the designated
                 address register. The second OUT writes a data byte to the
                 corresponding data register. If an interrupt occurs
                 between the two port writes, and if the interrupt handler
                 itself writes to the same port, the BIOS subroutine's
                 second port write may be invalid.

                 To avoid this situation on the EGA and MCGA, the Vertical
                 Interrupt handlers in Listings 12-1 and 12-3 read the
                 value of the CRTC Address register at port 3D4H (3B4H on
                 an EGA with a monochrome display). On the EGA, this value
                 is only readable for about 15 milliseconds after the port
                 has been written, but this is enough time for the Vertical
                 Interrupt handler to read and preserve the value of the
                 CRTC Address register. The handler can thus restore the
                 value before it returns from the interrupt.



Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
Panning on the EGA and VGA


     The 256 KB video buffer of the EGA and the VGA can store several
     screens of data. Thus, in a sense, what is displayed represents a
     "screen window," a sort of hardware window into the contents of the
     video buffer.


Positioning the Screen Window

     On an adapter such as the MDA or the CGA, the CRT Controller's Start
     Address registers control which portion of the video buffer is
     displayed. Because these registers contain a byte offset into the
     video buffer, you can control the position of the screen window only
     to the nearest byte. On the other hand, the CRT Controller on the EGA
     and the VGA can position the start of the screen window at any given
     pixel position.

     In graphics modes, the contents of the CRTC's Start Address High and
     Start Address Low registers (0CH and 0DH) locate the screen window to
     the nearest byte offset in the video buffer. The contents of the
     CRTC's Preset Row Scan register (08H) and the Attribute Controller's
     Horizontal Pel Pan register (13H) "fine-tune" the screen window's
     position pixel by pixel (see Figure 12-1).

     When you change the screen window's position smoothly, pixel by pixel,
     the displayed image appears to pan across the screen. A convenient way
     to do this is to write a routine that locates the screen window at a
     specified pixel position and then call the routine iteratively from
     within a loop. This routine, as demonstrated in Listing 12-4, must
     distinguish between alphanumeric and graphics modes. It must also
     handle a 9-pixel-wide character matrix in VGA and EGA monochrome
     alphanumeric modes.


              ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿
     ÚÄÄÄÄÄÄ0³   ³ ³   ³ ³   ³ ³²²²³ ³²²²³ ³   ³ ³   ³ ³   ³
     ³        ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ
Start Address ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿
registers    1³   ³ ³   ³ ³²²²³ ³   ³ ³   ³ ³²²²³ ³   ³ ³   ³
specify this  ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ
character     ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿
             2³   ³ ³²²²³ ³   ³ ³   ³ ³   ³ ³   ³ ³²²²³ ³   ³ Origin
              ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ of screen
              ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ window
             3³   ³ ³²²²³ ³   ³ ³   ³ ³   ³ ³   ³ ³²²²³ ³   ³   º
              ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÉÍÍÍÁÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
              ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿
       ÚÄÄÄÄ4³   ³ ³²²²³ ³²²²³ ³²²²³ ³ÛÛÛ³ ³²²²³ ³²²²³ ³   ³ÍÍÍÍÍÍ»
       ³      ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ       º
       ³      ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿       º
       ³     5³   ³ ³²²²³ ³   ³ ³   ³ ³   ³ ³   ³ ³²²²³ ³   ³       º
       ³      ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ       º
       ³      ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿       º
       ³     6³   ³ ³²²²³ ³   ³ ³   ³ ³   ³ ³   ³ ³²²²³ ³   ³       º
       ³      ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ       º
       ³      ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿ ÚÄÄÄ¿       º
       ³     7³   ³ ³   ³ ³   ³ ³   ³ ³   ³ ³   ³ ³   ³ ³   ³       º
       ³      ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ       º
       ³        0     1     2     3     4     5     6     7         º
       ³                                                           º
       ³                                ³                           º
Value for Preset               Value for Horizontal                 º
Row Scan register              Pel Pan register                     º
                                            ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
                                         ÚÄÄÎÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                         ³  ABCDEFGÄÄÄÄÄÄÄÄÄÄ¿     ³
                                         ³  HIJKLMN          ³     ³
                                         ³  OPQR             ³     ³
                                         ³  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     ³
                                         ³  Displayed portion      ³
                                         ³  of buffer              ³
                                         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                                Video buffer

     Figure 12-1.  Control of the displayed portion of the video buffer in
     alphanumeric modes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-4.  Setting the screen origin on the EGA and VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     ScreenOrigin() accepts as input the x- and y-coordinates of the pixel
     that identifies the origin (the upper left corner) of the screen. The
     routine first updates the CRTC's Start Address registers. In effect,
     this positions the screen at the upper left pixel of the character
     that contains the origin in alphanumeric modes, or at the leftmost
     pixel in the byte that contains the origin in graphics modes. Then
     ScreenOrigin() positions the virtual screen exactly by updating
     the Horizontal Pel Panning and Preset Row Scan registers.

     The content of the Attribute Controller Horizontal Pel Panning
     register corresponds to the bit offset of the pixel in the screen's
     upper left corner. The value to store in this register is thus

     x MOD 8

     In the case of 9-pixel characters in VGA alphanumeric modes and in 80-
     by-25 monochrome mode on the EGA, the value is

     (x + 8) MOD 9

     The Horizontal Pel Panning register is programmed the same way in both
     alphanumeric and graphics modes. This is not the case, however, for
     the CRTC's Preset Row Scan register, which controls the vertical
     position of the start of the screen.

     In alphanumeric modes, the number of rows of pixels displayed for each
     row of characters in the video buffer depends on the height of the
     displayed character matrix. This is the value stored as POINTS in the
     ROM BIOS Video Display Data Area. The Start Address registers position
     the virtual screen to the particular character in the video buffer,
     and the Preset Row Scan register indicates which line in the character
     matrix contains the origin of the virtual screen. The Preset Row Scan
     register thus contains a value between 0 (the top line of the
     character) and POINTS-1 (the bottom line). In graphics modes, the
     pixels in each byte in the video buffer correspond one-to-one with
     pixels on the screen, so the Preset Row Scan register always contains
     0.

     To avoid interference with the display, updates to the Horizontal Pel
     Panning, Preset Row Scan, and Start Address registers should be
     synchronized with the display refresh cycle. The Horizontal Pel
     Panning register must be updated during the vertical blanking
     interval. On the other hand, the CRTC samples the values in the Start
     Address and Preset Row Scan registers at the beginning of vertical
     retrace, so these registers should be updated when vertical retrace is
     not active.


Panning

     The routine in Listing 12-5 shows how you can call ScreenOrigin() to
     pan the screen up and down or across the video buffer. Because the
     position of the virtual screen always changes during a vertical
     blanking interval, the panning effect is smooth, with no interference
     on the screen.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-5.  A routine to perform smooth pixel-by-pixel panning on
     an EGA or VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Resizing the Video Buffer

     Horizontal panning introduces a problem. The way the video buffer is
     normally mapped, the first byte of each line of data in the buffer
     immediately follows the last byte of the previous line. If you try to
     pan horizontally with this map, each line appears to wrap around the
     screen as the screen window moves across the video buffer. To perform
     horizontal panning usefully, you should resize the video buffer so
     each line of data in it is wider than the screen window.

     The value in the CRT Controller's Offset register (13H) controls the
     way the CRTC maps lines in the video buffer. As it scans the raster,
     the CRTC uses the value in this register to locate the start of each
     line in the video buffer map. Normally, lines in the video buffer are
     the same width as displayed lines. Increasing the value in the Offset
     register widens the lines in the video buffer map so only part of each
     line can be displayed at one time. This lets you pan horizontally
     without wraparound.

     For example, consider how you could double the logical width of the
     video buffer in 80-by-25 alphanumeric mode. By default, the video BIOS
     stores the value 28H in the CRTC's Offset register, so the CRTC
     regards each line in the buffer as being 40 words (80 bytes) wide.
     Although each logical line in the buffer contains 160 bytes of data
     (80 character codes and 80 attribute bytes), character codes and
     attributes are stored in different video memory maps (see Figure 10-3
     in Chapter 10). Thus, to double the logical line width, store 50H (80
     decimal) in the CRTC's Offset register. The CRTC will still display 80
     characters in each row on the screen, but it skips 160 characters of
     data between rows of characters in the  video buffer.

     When you resize the video buffer by programming the CRTC's Offset
     register, be careful not to exceed the bounds of the 256 KB video
     buffer. For example, in 640-by-350 16-color graphics mode, one
     screen's worth of pixels occupies 28,000 bytes (80 bytes per line *
     350 lines) in each of the 64 KB video memory maps. If you resize the
     video buffer by increasing the value stored in the CRTC Offset
     register, you cannot go beyond 187 bytes per line in this video mode
     without exceeding the 64 KB limit.

     The routine BufferDims() in Listing 12-6a can be called to
     redimension the video buffer in either graphics or alphanumeric modes.
     It accepts as parameters the desired horizontal and vertical
     dimensions of the buffer in pixels. The routine updates the relevant
     variables in the video BIOS data area and then programs the CRTC
     Offset register with the appropriate value. The example in Listing 12-
     6b shows how BufferDims() could be called to transform a default
     80-by-25 alphanumeric mode into a 160-by-102 mode in which the Pan()

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     routine in Listing 12-5 can be used.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-6a.  Redimensioning the video buffer.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-6b.  Creating a 160-by-102 alphanumeric mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Bit-Plane Layering


     In EGA and VGA 16-color graphics modes and in the InColor Card's 720-
     by-348 16-color mode, you can display any combination of the four bit
     planes. On the EGA and VGA, the four low-order bits of the Attribute
     Controller's Color Plane Enable register (12H) control which bit
     planes are displayed. Similarly, on the InColor Card, the four low-
     order bits of the Plane Mask register (18H) determine which bit planes
     are displayed. In all three subsystems, all four bits are set to 1 to
     enable the display of all four bit planes. You can zero any
     combination of these bits to prevent display of the corresponding bit
     planes.

     When you disable a bit plane in this way, pixel values are interpreted
     as though the corresponding bit in each pixel were set to 0. The
     contents of a disabled bit plane are unaffected. This means you can
     draw different images into different bit planes and display them
     selectively. When bit planes containing different images are displayed
     together, the images appear to overlap, as if the bit planes were
     transparent and layered one above the other.

     Consider the example in Figure 12-2. The grid is drawn in bit plane 3
     and the cylinder in bit planes 0 through 2. (A quick way to draw both
     figures into the bit planes is to OR the appropriate pixel values into
     the video buffer.) If you use a default 16-color palette, the grid
     appears gray, and the cylinder can have any of the usual eight
     unintensified colors.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 12-2 is found on page 395      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 12-2.  Bit-plane layering. The cylinder's pixels have values
     between 0 and 7 (bit planes 0 through 2); the grid's pixels have the
     value 8 (bit plane 3 only). Selectively enabling or disabling bit
     planes 0 through 2 and bit plane 3 displays the cylinder, the grid, or
     both.


     If all four bit planes are displayed, both grid and cylinder appear on
     the screen. If you disable bit plane 3, the grid disappears. If you
     disable bit planes 0 through 2, displaying only bit plane 3, the
     cylinder disappears and only the grid is visible. In all three cases,
     the contents of the bit planes remain intact.

     In using the default palette register values with the grid and
     cylinder, you'll find the pixels at which the grid and cylinder
     intersect are displayed with intensified colors. You can avoid this by
     updating the palette so that the colors displayed for the intersection
     points (pixel values 9 through 0FH) are the same as the corresponding
     unintensified colors (1 through 7). Then, when both grid and cylinder
     are displayed, the cylinder appears in front of the grid.


EGA and VGA Split Screen


     You can configure the CRT Controller on the EGA and the VGA to display
     two different portions of the video buffer on the same screen (see
     Figure 12-3). To do this, program the CRTC's Line Compare register
     (18H) with the raster line at which you want to split the screen, as
     shown in Listing 12-7a and Listing 12-7b.


                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
CRTC StartÄÄÄÄÄÄÄ ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ³
Address registers  ³ ³  ÄÄÄÄÄÄ                                         ³ ³
                   ³ ³  ÄÄÄÄÄÄÄÄÄÄÄÄÄ                                  ³ ³
                   ³ ³  ÄÄÄÄÄÄÄÄ  ÄÄÄÄÄÄ                               ³ ³
                   ³ ³  ÄÄÄÄÄ ÄÄÄÄÄÄÄÄ ÄÄ                              ³ ³
                   ³ ³                                                 ³ ³
Start of videoÄÄÄÄ³ ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³
buffer             ³ ³  ÄÄÄÄÄ  ÄÄÄÄÄ                                   ³ ³
                   ³ ³  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ                   ³ ³
                   ³ ³  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ                   ³ ³
                   ³ ³  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ                   ³ ³
                   ³ ³  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ  ÍÍÍÍ                   ³ ³
                   ³ ³                                                 ³ ³
                   ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 12-3.  Appearance of an EGA or VGA split screen. The top part
     of the screen displays data from the location in the video buffer
     specified by the CRTC Start Address registers. The bottom part of the
     screen displays data from the start of the video buffer.


     The contents of the CRTC Start Address registers determine which
     portion of the video buffer is displayed in the top part of the
     screen. As the raster is drawn during each display refresh cycle, the
     CRTC compares the current scan line with the value in the Line Compare
     register. When the values are equal, the CRTC resets its internal
     address counter so that the remaining scan lines in the raster are
     drawn using data from the start of the video buffer. Thus, the top of
     the video buffer is always displayed in the bottom part of the split
     screen.

     Both the EGA and the VGA accommodate Line Compare values larger than
     eight bits (0FFH or 255 scan lines) by using other CRTC registers to
     contain additional high-order bits. Thus, bit 8 of the Line Compare
     value is represented in bit 4 of the CRTC Overflow register (07H).
     On the VGA, a ninth bit must also be specified for the Line Compare
     value; this bit is represented in bit 6 of the the Maximum Scan Line
     register (09H). Programming the CRTC with a Line Compare value thus
     requires you to update two different registers on the EGA and three
     different registers on the VGA.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-7a.  Splitting the screen on the EGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-7b.  Splitting the screen on the VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Because the CRTC uses the Line Compare value while it is
       º T º     actively updating the raster, the best time to change this
       º I º     value is during a vertical retrace interval as in Listings
       º P º     12-7a and 12-7b.
       ÈÍÍÍ¼

                 The video BIOS default Line Compare value is the maximum
                 possible value (1FFH on the EGA, 3FFH on the VGA). Use
                 this default value to "unsplit" the screen. There are also
                 certain values that the CRTC does not handle in a useful
                 manner. On both the EGA and VGA, do not specify a Line
                 Compare value that is between the Vertical Retrace Start
                 and Vertical Total values. Also, in 200-line modes on the
                 VGA, the Line Compare register value should be an even
                 number.

                 In native graphics modes in the IBM EGA, the CRTC
                 duplicates the scan line at which the screen is split.
                 This anomaly is also found in some EGA clones.

     You might find it convenient to regard the bottom portion of the split
     screen as a sort of window superimposed on the top portion. Use the
     first portion of the video buffer for the window foreground (the lower
     part of the split screen) and some other portion of the buffer for the
     background.

     One attractive way to use the split-screen feature is to scroll the
     split smoothly up or down the screen. Do this by incrementing or
     decrementing the value in the Line Compare register within a loop, as
     is done by the routine in Listing 12-8.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-8.  Smooth vertical scrolling of a split screen on the EGA
     or VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


The Light Pen Interface


     On most video subsystems covered in this book, the CRT Controller can
     return the position of a light pen. When you trigger a light pen, it
     sends a signal to the CRTC at the moment the video display's electron
     beam sweeps past the pen's light sensor. The CRTC responds by storing
     the current value of its internal address counter into its Light Pen
     High and Light Pen Low registers. This value corresponds to the offset
     in the video buffer of the data displayed in the raster at the point
     where the light pen was triggered. Thus, the value in the Light Pen
     High and Low registers can be translated into row and column
     coordinates for screen locations.

       ÉÍÍÍ»     You can't attach a light pen to IBM's MDA, but Hercules
       º T º     monochrome adapters can support one. However, a light pen

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
       º I º     used with a monochrome display must be capable of
       º P º     operating with the high-persistence P39 phosphor used in
       ÈÍÍÍ¼     green monochrome displays.


Light Pen Position

     The light pen position that the CRTC returns is not an exact pixel
     location. One reason is simply that the value returned in the CRTC's
     Light Pen registers is a byte offset into the video buffer, so the
     light pen's horizontal position can be determined only to the nearest
     byte of pixels. Another source of inaccuracy is that the CRTC chip
     itself introduces a small amount of delay between the time it receives
     a signal from the light pen and the time it stores a value in its
     Light Pen registers. The value returned in the Light Pen registers
     thus can be as much as 5 bytes too large; the actual amount of error
     must be determined empirically.

     The light pen programming interface, shown in Figure 12-4, is similar
     on all IBM and Hercules adapters. To determine a light pen's position,
     your program must first reset the CRTC's light pen latch by writing a
     0 to I/O port 3DBH (3BBH on an MDA, a Hercules adapter, or an EGA with
     a monochrome display). Then it must poll the Status Port at 3DAH (3BAH
     in monochrome modes). When bit 1 of the Status Port value changes from
     0 to 1, the light pen has been triggered and the routine can obtain
     its location from the CRTC (see Listing 12-9a).

     After reading the light pen location from the Light Pen registers, you
     must apply an empirical correction for the intrinsic delay in the
     CRTC. The routine in Listing 12-9b, for the EGA's 80-by-25
     alphanumeric mode, subtracts 7 from the value that the CRTC returns.
     To convert the result into a pixel location, subtract the value in the
     Start Address High and Start Address Low registers from the corrected
     CRTC value. (You can get the Start Address value by dividing the value
     in CRT_START in the Video Display Data Area by 2. You can also read it
     from the Start Address High and Start Address Low registers on the
     EGA, the HGC+, and the InColor Card.) Then divide the difference by
     the number of characters in each row of the video buffer. (This value
     is represented in the CRTC's Horizontal Displayed register, or in
     CRT_COLS on the EGA.) The quotient is the y-coordinate of the light
     pen location. The remainder is the character column corresponding to
     the position of the light pen.


I/O Port                         Function
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA, HGC, HGC+, and InColor Card
3B9H                             Set light pen latch
3BAH bit 1                       Light pen trigger
3BAH bit 2                       Light pen switch (IBM adapters only)
3BBH                             Reset light pen latch

CGA, EGA
3DAH bit 1                       Light pen trigger
3DAH bit 2                       Light pen switch (IBM adapters only)
3DBH                             Reset light pen latch
3DCH                             Set light pen latch
     Figure 12-4.  Light pen programming interface. Note: In EGA
     monochrome modes, read light pen trigger and switch status from 3BAH
     instead of 3DAH.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-9a.  Getting the light pen's location from the
     CRTC.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-9b.  Using GetLightPen in a C program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     If this seems like more trouble than it's worth, you're probably
     right. On IBM video adapters, as well as in Hercules adapters'
     alphanumeric modes, you can call INT 10H function 4 to return the
     light pen location. If you plan to use a light pen in Hercules
     graphics modes, however, you're on your own.


Light Pen Switch

     On IBM adapters, you can determine whether the light pen switch is
     depressed by examining bit 2 of the Status Port value returned from
     port 3DAH (3BAH in monochrome modes). This bit is set to 1 while the
     switch is closed. It returns to 0 when the switch is opened. You
     should usually test the status of the light pen switch before
     attempting to read the CRTC's Light Pen registers.


Determining Hercules Video Modes

     The Light Pen registers can also be used to determine video modes on
     Hercules adapters. In most applications, determining the current video
     mode is not a problem, because the application itself establishes the
     mode. Sometimes, however, a program may not know the video mode a
     priori. For example, a screen dump program (see Appendix B) may need
     to determine the video mode to correctly interpret the contents of the
     video buffer. Similarly, a RAM-resident "pop up" program should save
     and then restore the video mode into which it "pops."

     You can easily determine the current ROM BIOS video mode by calling
     INT 10H function 0FH. The task is more difficult for the Hercules
     adapters, because the BIOS does not keep track of the video mode. You
     can sometimes infer the video mode from the Video Display Data Area
     variables CRT_COLS, CRT_LEN, and POINTS, but not everybody who writes
     programs for Hercules adapters keeps these variables updated.

     Moreover, there is no direct way to interrogate the hardware to
     determine the video mode. For example, the Mode Control register
     (3B8H), used to select the video mode, is unfortunately a write-only
     register. Nevertheless, you can infer a Hercules adapter's video mode
     by latching the 6845's Light Pen High and Low registers (10H and 11H)
     at the start of vertical retrace, as shown in Listing 12-10.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 12-10.  Identifying the current video mode on a Hercules
     adapter.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routine in Listing 12-10 waits for the start of vertical retrace
     and triggers the light pen at this point with an OUT instruction to
     port 3B9H. The Light Pen registers reflect the value of the CRTC's
     internal address counter at the point where vertical retrace begins.
     (This value is the product of the values in the CRTC Horizontal
     Displayed and Vertical Sync registers.) You can expect the Light Pen
     registers to contain at least 7D0H (80 words per character row x 25
     rows) in 80-by-25 alphanumeric mode and 0F4BH (45 words per character
     row x 87 rows) in 720-by-348 graphics mode. Inspecting the Light Pen
     value thus reveals whether the HGC is in alphanumeric or graphics
     mode.

       ÉÍÍÍ»     In practice, the Light Pen value returned is somewhat
       º T º     larger than these expected values because of the delay in
       º I º     the CRTC timing. This imprecision makes the technique
       º P º     somewhat less useful on the HGC+ and InColor cards, where
       ÈÍÍÍ¼     you must distinguish among all the different character
                 sizes that can be displayed by the CRTC in alphanumeric
                 mode. For example, the value returned by GetHercMode()
                 when 9-by-8 characters are displayed is near 0DC0H (80 x 
                 44)  and near 0DB6H (90 * 39) when 8-by-9 characters are
                 displayed. Because the Light Pen value is inexact, you may
                 not be able to distinguish these two different CRTC
                 configurations.



          13  Graphics Subroutines in High-Level Languages


                    Linking Graphics Subroutines
                          Subroutine Calls
                Interrupts to a Memory-Resident Driver
                             Inline Code

                          Global Data Areas

                     Layered Graphics Interfaces
                     Direct Hardware Programming
                       Extended BIOS Interface
                        High-Level Interface



     Most programming examples in this book are written in assembly
     language, the language of choice for programs that need to control
     hardware precisely and to run as fast as possible. Nevertheless, most
     IBM PC programmers prefer not to write large applications entirely in
     assembly language because they can write, debug, and maintain a
     program in a high-level language much more effectively.

     As you write the code for a program that produces video output, you
     must balance the convenience and conceptual clarity a high-level
     language provides against the speed and exact control provided by
     assembly language. A good rule of thumb is to use assembly language
     whenever you directly access the video buffer or the video subsystem's
     control registers. The rest of the time, you can generally obtain
     satisfactory performance using any compiled high-level language.

     This chapter focuses on the interface between programs written in
     high-level languages and the low-level, assembly-language drivers that
     actually access the video hardware. You can implement the interface in
     several ways. The method you select should depend on the language you
     are using, your familiarity with the memory models and parameter-
     passing techniques that your compiler uses, and (as always) your own
     good judgment in evaluating the alternatives.

     The last part of the chapter introduces several different high-level
     video programming interfaces. The focus is on the reasons why high-
     level programming interfaces are used and the programming approach

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     involved in using them.


Linking Graphics Subroutines


     You can tie low-level graphics subroutines to high-level applications
     in several ways. The three techniques discussed here--subroutine
     calls, calling a set of memory-resident routines, and using inline
     code in a high-level-language program--have all been proved in various
     graphics applications. As usual, the "best" method to use in any given
     application is a matter of judgment.


Subroutine Calls

     This book contains numerous subroutines that are designed to be called
     from within a high-level-language program. Most are to be linked to
     programs compiled with the Microsoft C compiler. However, you can link
     these subroutines to any high-level-language program if you know the
     proper protocol for structuring executable code, and for passing
     parameters to a subroutine and returning values from it. The routines
     in Listings 13-1 through 13-4 show how to call the same assembly-
     language subroutine from Microsoft C, Microsoft FORTRAN, Turbo Pascal,
     and interpreted BASIC.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-1a.  The SetPixel subroutine (Microsoft C small-model
     calling conventions).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-1b.  Calling SetPixel() from a C program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-2a.  The SETPEL subroutine (Microsoft FORTRAN calling
     conventions).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-2b.  Calling SETPEL() from a FORTRAN program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-3a.  The SETPEL subroutine (Turbo Pascal calling
     conventions).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-3b.  Calling SETPEL() from a Turbo Pascal program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-4a.  The SETPEL subroutine (BASICA calling convention).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-4b.  Calling SETPEL from a BASICA program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     One of the ways these assembly-language subroutines differ is that
     they use different memory models. A memory model describes the segment
     organization of a program--whether executable code is separated from
     program data, and whether segments are accessed with 16-bit (near) or
     32-bit (far) addresses. For example, a small-model program has one
     near code and one near data segment; a large-model program can have
     multiple far code and far data segments. The subroutines in Listings
     13-1 through 13-4 conform to the default memory models used by the
     different language translators.

     The protocol for passing parameters also varies among compilers and
     programming languages. In Pascal, for example, parameters are pushed
     on the stack in the order they appear in the PROCEDURE statement,
     while in C, parameters are pushed in reverse order. Also, either the
     actual value of a parameter or its address may be passed; this depends
     on the programming language you use as well as on the type of data
     involved. Each compiler's reference manual contains details on its
     parameter-passing protocol.


     Microsoft C
     Source code examples in previous chapters that can be called from a C
     program are all designed to be linked with small- or compact-model
     programs. To call them from a medium- or large-model program, you must
     make three modifications to the source code to make it conform to
     these memory models' subroutine-calling conventions.

     ş  Change the name of the executable code segment.

     ş  Use the far keyword in assembler PROC directives.

     ş  Modify the stack frame addressing to accommodate the calling
        routine's 32-bit return address.

     For example, to call SetPixel10() within a medium-model C program,
     change the name of the _TEXT segment in SetPixel10()'s source
     code to a name of the form module_TEXT and use the far keyword
     in the routine's PROC directive. Also, adjust the stack frame
     addresses by two bytes to account for the 32-bit return address.


     Microsoft FORTRAN
     Microsoft's FORTRAN compiler does not generate small- or compact-model
     programs, so the far addressing conventions applicable to medium- and
     large-model programs apply to FORTRAN-callable assembly-language
     graphics subroutines. The C-callable version in Listing 13-1a and the
     FORTRAN equivalent in Listing 13-2a differ in several ways. These
     differences relate to the way parameters are passed on the stack to
     the subroutine.

     The C compiler passes the current values of each subroutine argument
     in reverse order, so the first argument is on top of the stack. The
     FORTRAN compiler passes the 32-bit address of each argument's value in
     the order in which the arguments appear in the subroutine's
     argument list. The C subroutine obtains the argument values directly
     from the stack; the FORTRAN routine must obtain the arguments'
     addresses from the stack, then use the addresses to obtain the values.
     Also, in C, the routine that called the subroutine discards the
     arguments on the stack. In contrast, in FORTRAN the called subroutine
     cleans up the stack when it exits.

       ÉÍÍÍ»     The Microsoft C, FORTRAN, and Pascal compilers let you
       º T º     specify the parameter-passing protocol used to call a
       º I º     particular subroutine. For  example, you can write a C-
       º P º     callable subroutine and then access it using the
       ÈÍÍÍ¼     appropriate compiler directive in your FORTRAN or Pascal
                 program. This interlanguage linking capability became
                 available in MS C version 3.00, MS Pascal version 3.3, and
                 MS FORTRAN version 3.3.

                 Including a compiler directive in your high-level source
                 code can be more convenient than modifying an assembly-
                 language subroutine. For example, a C subroutine can be
                 called from a FORTRAN program by declaring the subroutine
                 in a FORTRAN INTERFACE unit:

                 interface to subroutine SP10[C](x,y,n)
                 integer*2 x,y,n
                 end

                 This INTERFACE unit instructs the FORTRAN compiler to
                 generate code that calls the subroutine _sp10() using C's
                 parameter-passing protocol. However, this technique does
                 not affect the memory model used; the C-callable routine
                 is called with a far call, because it lies in a different
                 segment from the FORTRAN caller. Thus, _sp10() must still
                 be declared with the far keyword, and the stack frame must
                 be addressed with the assumption that a 32-bit far return
                 address lies on top of the stack when the procedure is
                 called.

                 If you intend to write graphics routines that can be
                 called from either Microsoft C, Pascal, or FORTRAN, you
                 should use a medium or large memory model, so the routine
                 can be called as a far procedure. You can use any
                 parameter-passing protocol; the Microsoft language
                 translators can generate code for all of them.


     Turbo Pascal
     Turbo Pascal links EXTERNAL assembly-language subroutines dynamically.
     However, Turbo Pascal's dynamic linker does not perform address
     relocation or resolve symbolic references between the main program and
     the subroutine. Thus, the assembly-language subroutine has a very
     simple structure. Listing 13-3a is an example of this type of
     subroutine. Note how the subroutine performs "self-relocation" by
     initializing a register with the starting offset of the subroutine
     (using a CALL L01 followed by a POP), then adding this value to all
     references to labels within the subroutine.


     BASIC
     IBM BASICA and Microsoft GWBASIC have their own intrinsic video output
     routines. However, you can use assembly-language subroutines to

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     customize your BASIC programs for video modes or hardware not
     supported by these BASIC interpreters. Listings 13-4a and 13-4b
     show how to do this.

     Like Turbo Pascal, BASICA requires you to link your subroutine
     dynamically. In Listing 13-4a, the subroutine is assembled in the
     form of a binary file that can be loaded with the BASIC BLOAD command,
     as in lines 220-250 of Listing 13-4b. In BASICA, as in Pascal,
     parameters are passed to the subroutine in the order they are
     specified in the high-level source code. Unlike the Turbo Pascal
     subroutine, however, the BASIC subroutine is a far procedure. Also, in
     BASIC the addresses of parameters are passed instead of the values of
     the parameters themselves.


Interrupts to a Memory-Resident Driver

     Another way to implement the interface between high-level-language
     programs and machine-language graphics routines is to make the
     graphics routines resident in memory. When they are, programs can
     access the graphics routines by executing a software interrupt. This
     is the design of the interface used by all video BIOS routines in the
     PC and PS/2 families. The routines reside at a fixed address in ROM.
     Interrupt vector 10H is initialized at bootup to point to a service
     routine that calls the BIOS routines.

     Your own video output routines can be accessed in a similar manner if
     you make them resident in RAM and set an interrupt vector to point to
     them. (On the PC and PS/2s, interrupt numbers 60H through 67H are
     reserved for such user-defined interrupts.) Listing 13-5 is an
     example of a simple RAM-resident routine that stores pixels in the
     EGA's 640-by-350 16-color mode. The source for this routine assembles
     to a .EXE file that installs the routine in RAM and sets interrupt
     vector 60H to point to the code that sets the pixel value. After the
     interrupt vector is initialized, any program can access the routine by
     loading the CPU registers with the pixel location and value and then
     executing interrupt 60H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-5.  A RAM-resident routine to write pixels in 640-by-350
     graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Inline Code

     A technique familiar to many C, Modula-2, and Turbo Pascal programmers
     is to implement low-level subroutines as inline machine instructions
     in high-level source code. Doing so can simplify the problem of using
     consistent memory-model and parameter-passing protocols, because the
     high-level-language compiler handles these implicitly. However, inline
     code is rarely portable and can be difficult to adapt for use with
     other languages.


Global Data Areas


     When you link video output subroutines to a high-level program, you
     face the problem of transferring information about the current state
     of the video hardware between the high-level program and the
     subroutines. Although you can pass such information to subroutines
     using argument lists, a better approach is to use a global data
     structure that both the high-level program and the low-level
     subroutines can access. Information contained in a global data area
     can include:

     ş  Hardware identification ("EGA with 350-line color display")

     ş  Hardware coordinate system (orientation of x- and y-axes,
        maximum x- and y-coordinates)

     ş  Video buffer status, including video mode, buffer dimensions
        (maximum x- and y-coordinates), and currently displayed
        portion of the buffer

     ş  Foreground and background pixel values for text and graphics
        output

     ş  Color values for palette registers

     ş  Current pixel operation (replace, XOR, AND, OR, or NOT)

     ş  Current region fill pattern

     ş  Current line-drawing style (thick or thin line, dashed or broken
        line)

     In many applications it is better to maintain several global areas
     instead of just one. Because almost all PC and PS/2 video hardware
     supports more than one display mode, you can create a separate global
     data block for each mode and make an entire block "current" when you
     select a video mode. In a windowing environment, a block of global
     data can apply to each displayable window. In addition to the above
     information, such a block can also describe the way graphics images
     and text are mapped into a window. This can include clipping
     boundaries, vertical and horizontal scaling, or window visibility
     (whether a window is on or off the screen, overlapping another window,
     and so on).

     Using a global data area has several advantages. Because both high-
     level and low-level routines can determine output hardware status, you
     can write hardware-independent programs that examine the descriptive
     information in the global data area to determine how to format their
     output. This information is relatively static, so maintaining it in a
     global area helps minimize redundant parameter passing between
     graphics routines. Moreover, global data areas can be used
     contextually: the contents of a global data area can be saved,
     modified transiently, and restored.

       ÉÍÍÍ»     Of course, the information in a global data area can
       º T º     pertain to output devices other than video adapters and
       º I º     displays. A graphics interface that accommodates printers
       º P º     or plotters can also incorporate information about their
       ÈÍÍÍ¼     status in a global data area.


Layered Graphics Interfaces


     After implementing an interface between your low-level video output
     routines and your high-level program, you may still find that a
     certain amount of high-level source code is concerned with low-level
     hardware-dependent manipulations such as pixel coordinate scaling and
     clipping. You can insulate high-level application code from
     considerations about hardware capabilities by creating one or more
     intermediate layers of functionality between the high-level
     application and the hardware drivers.

     A simple layered graphics interface is depicted schematically in
     Figure 13-1. The bottom layer comprises a set of hardware driver
     routines like the ones in this book. The top layer provides a set of
     subroutines that can be called by a high-level application.The
     routines in the top layer may call the hardware drivers in the bottom
     layer directly, or there may be one or more intermediate binding
     layers interposed between the high-level routines and the hardware
     drivers. In any case, the top-level subroutines present a consistent,
     hardware-independent software interface to the programmer who uses a
     high-level language, and thereby insulate high-level programs from the
     vagaries of video hardware programming.

     The ROM video BIOS provides an example of this sort of layering. The
     set of routines that you invoke by issuing INT 10H serves as an
     intermediate layer between assembly-language applications and the low-
     level routines that actually program the hardware. From the
     application's point of view, the INT 10H interface is relatively
     hardware-independent; the video BIOS programs the graphics controller,
     updates the video buffer, and performs many other hardware-dependent
     programming tasks. Because the video BIOS routines contain the
     hardware-dependent code, a program that uses the BIOS is to some
     extent portable to different types of video hardware.

     You can, of course, build many more functions into a layered interface
     than the video BIOS provides. For example, commercially available
     video graphics interfaces can produce sophisticated graphics and
     perform video control functions, including geometric transformations
     (scaling, translation, rotation of graphics images), three-dimensional
     graphics (hidden-line removal, three-dimensional surface represen-
     tation), or sophisticated color mixing and shading. Such graphics
     packages can support output to printers or plotters, as well as to
     video displays. In this case, the layered interface provides a set of
     routines and data structures that allow a high-level program to
     determine the status of an output device and  to select appropriate
     output attributes (line style, drawing color, and so on) on each
     device.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³High-level-language interface³ "Top layer"
     ³  (independent of hardware)  ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    ³
                    ³
                    ³Language binding
                    ³
                    ³
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³        Device driver        ³ "Bottom layer" 
     ³    (hardware-dependent)     ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 13-1.  A simple layered graphics interface.


     In an operating environment that relies heavily on a graphics-oriented
     video interface, access to operating system functions can be combined
     with video output routines in a high-level application program
     interface (API). This is the approach taken in Apple's Macintosh and
     in Microsoft Windows. In both these environments, support for system
     functions like windows, pull-down menus, and icons is integrated into
     a unified, graphics-oriented API.

     Most layered graphics interfaces comprise more than one intermediate
     layer. Furthermore, each layer can be broken into several independent
     modules. The desire to preserve software portability, particularly as
     existing software is adapted to new video hardware, is the main reason
     for this. Many PC graphics programs are designed so that the end-user

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     can customize the hardware-dependent layer(s) to a particular hardware
     configuration. This is a great convenience for the user, since
     adapting a program with a layered video interface to a newly acquired
     piece of hardware is no more difficult than installing a new device
     driver or relinking the program with a new subroutine library.

     The price you pay for this flexibility is a certain amount of extra
     code needed to support the layered interface, so programs run somewhat
     slower. You must consider this trade-off whenever you write an
     application that relies on video display output. Although the benefits
     of using a layered graphics interface are great, many applications are
     simpler to develop and run faster when you dispense with the formal
     graphics interface and use only the necessary low-level drivers.

     To get an idea of the type of programming required when you use a
     layered graphics interface, consider how you might draw a filled
     rectangle in a video graphics mode. The following examples show how
     you could do this using one  of the routines developed earlier in this
     book and using two different layered graphics interfaces. As you
     compare the source code and the programming technique in each of the
     following examples, you will see where the advantages and
     disadvantages of each graphics interface might lie.


Direct Hardware Programming

     The routine in Listing 13-6 draws a filled rectangle directly, by
     computing the endpoints of the set of adjacent line segments that make
     up the rectangle and using a horizontal line-drawing routine to update
     the video buffer. Strictly speaking, this routine could be written
     entirely in assembly language by adapting one of the line-drawing
     routines from Chapter 6. The high-level routine in Listing 13-6 runs
     nearly as fast, however, since most of the time is spent drawing the
     lines, not computing their endpoints.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-6.  Using C to draw a filled rectangle.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     If raw speed is the major constraint on your program, this is the best
     way to draw a rectangle. The code, however, is relatively nonportable,
     because it makes implicit assumptions about such hardware-dependent
     constraints as the (x,y) coordinate system and color capabilities of
     the video subsystem. You could not use a routine such as the one in
     Listing 13-6 in a multitasking or windowing operating environment,
     because it programs the video hardware directly and could therefore
     inadvertently corrupt video output from a concurrently executing
     program.


Extended BIOS Interface

     As mentioned previously, the video ROM BIOS provides a certain amount
     of hardware independence and portability through the interrupt 10H
     interface. The tradeoff, of course, is speed and a certain amount of
     flexibility. Apart from inefficient implementations, the INT 10H
     routines are relatively unstructured and limited in their
     capabilities. As IBM video subsystems have become more complex,
     additional functionality has been grafted onto the INT 10H interface,
     making it more powerful but increasingly difficult to master.

     Direct Graphics Interface Standard (DGIS) is a firmware interface
     developed by Graphics Software Systems that extends the capabilities
     of the INT 10H interface in a structured manner. DGIS was designed to
     provide a uniform low-level interface to video hardware based on
     graphics coprocessors such as the Intel 82786 or the Texas Instruments
     TMS34010. Programming with DGIS is reminiscent of programming with
     IBM's video BIOS, but many elements of a high-level graphics interface
     have also been incorporated into DGIS.

     DGIS implements a hardware-independent interface by describing actual
     video subsystems, or devices, in terms of their possible display
     modes, or configurations. An application can interrogate DGIS to
     determine what devices are supported in the computer. It then selects
     a subsequent video output configuration, based on the configuration's
     resolution, number of colors, graphics and/or alphanumeric text
     support, and so on.

     For example, Listing 13-7 calls DGIS to draw the same filled
     rectangle as before. This time, however, instead of programming the
     hardware, the source code is concerned primarily with programming the
     interface. The routine first establishes the presence of a suitable
     graphics output device in the computer by calling the DGIS Inquire
     Available Devices function. This function returns a list of available
     DGIS devices; in a system with an EGA, for example, the configurations
     associated with the "EGA" device correspond to the EGA's video modes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-7.  Using DGIS to draw a filled rectangle.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The application program "connects" to an appropriate configuration,
     which DGIS identifies with a handle. The application can then
     associate an attribute context with the handle; the attribute context
     is a data structure that defines drawing colors, line styles, clipping
     boundaries, and so on. Subsequent calls to DGIS graphics output
     functions like OutputFilledRectangle refer to the attribute context
     associated with a specified handle.

     This general sequence of operations is inherently flexible. One reason
     is that it lets an application program access hardware features
     without actually programming the hardware. For example, an application
     can use DGIS functions to change a color palette or update pixels
     without writing directly to hardware control registers or to the video
     buffer.

     However, an application that performs video output through a DGIS
     interface runs slower than an equivalent application that programs the
     video hardware directly. As always, when you interpose a layer of
     functionality between your application and the hardware, you gain
     increased functionality and portability at the price of a decrease in
     speed. You must decide whether this trade-off is worthwhile in your
     own applications.


High-Level Interface

     There are several high-level graphics interface implementations
     available for IBM video subsystems. These high-level interfaces differ
     from DGIS and the IBM video BIOS in that they are implemented as
     software libraries or RAM-loadable device drivers instead of firmware
     routines. All of them relieve you of the need to program the hardware
     directly, and all provide a structured programming interface that can
     be used in a program written in a high-level language.

     The differences between the high-level graphics interfaces lie in the
     amount and type of functionality built into them. For example, the
     Virtual Device Interface (VDI) is a proposed ANSI standard designed to
     promote hardware independence in programs written in high-level
     languages. VDI presents a consistent programming interface to all
     graphics output hardware, including video subsystems, printers, and
     plotters. (The Graphics Development Toolkit sold by Graphics Software
     Systems and IBM support VDI.)

     Another well-known interface is the Graphical Kernel System (GKS), an
     internationally recognized ANSI standard. GKS offers a highly
     structured interface with powerful graphics data manipulation
     features. GKS deals not with individual hardware devices but with
     workstations that can include several related input and output devices
     (such as a display, a keyboard, and a mouse). A GKS implementation can
     be layered above a lower-level interface like VDI; an application can
     then use either interface without sacrificing functionality or
     portability.

     Still another type of high-level interface integrates graphics output
     with the computer's operating environment, as does the Graphics Device
     Interface (GDI) in Microsoft Windows. In contrast to DGIS, which is
     designed to be a low-level interface to display hardware, GDI serves
     as a high-level interface to Windows' graphics-oriented operating
     environment. In a layered graphics interface, GDI would be closer to
     the topmost layer while an interface like DGIS would be near the
     bottom. In fact, you can install Windows to run on top of DGIS; a
     Windows application can then use GDI functions which in turn call DGIS
     functions to access the hardware (Figure 13-2).

     The C source code fragment in Listing 13-8 merely scratches the
     surface of GDI programming in Windows, but it should give you an idea
     of how the video interface is structured. Most of the code in the
     example establishes a device context for the Rectangle() function to
     use. In GDI, a device context is a global data structure that contains
     information on the colors with which text and graphics are drawn, as
     well as scaling factors for pixel (x,y) coordinates, clipping
     boundaries, and other information. Windows maintains a device context
     for each window on the screen. Each device context is identified by a
     16-bit handle. When an application calls a GDI output function like
     Rectangle() or Ellipse(), it passes the handle of a device context to
     the function; the function then refers to the information in the
     device context to produce output in a window.

     To produce graphics output in a window, a Windows application starts
     by calling the Windows function CreateWindow(), which returns a handle
     (hWnd) that identifies the window. The application then monitors
     Windows' applicaiton message queue to determine when to update the
     window.

     To generate output to the window, the application can use another
     Windows function, BeginPaint(), to associate a device context
     (identified with the handle hDC) with the window. The application then
     uses GDI functions to establish drawing attributes and pixel
     coordinate mapping in the device context. In the example in Listing
     13-8, the attributes of the rectangle's border (line style and color)
     are specified by creating a data structure that becomes part of the
     device context.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³    Application     ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               ³
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³        GDI         ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
               ³
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³        DGIS        ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               ³
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³      Hardware      ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 13-2.  Microsoft Windows GDI installed on DGIS.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 13-8.  Using Microsoft Windows GDI (version 1.03) to draw a
     filled rectangle.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The function CreatePen() creates the data structure and returns an
     identifying handle that is assigned to the variable hpen. The
     function SelectObject() then updates the device context with this
     information. Similarly, calls to CreateSolidBrush() and SelectObject()
     establish the color and pattern used to fill the rectangle.

     When Rectangle() executes, it uses the "pen" and "brush" attributes in
     the device context to draw the rectangle's border and interior. The
     (x,y) coordinates specified in the call to Rectangle() indicate the
     rectangle's upper left and lower right corners. The coordinates do not
     indicate absolute pixel locations in the video buffer; they specify
     points in the coordinate system that relates to the window in which
     the rectangle is displayed.

     GDI's general design is similar to that of other high-level graphics
     interfaces--the hardware-dependent, machine-language routines are
     isolated in the lowest layer of the interface, and portable, hardware-
     independent functions are implemented in the interface's upper layers.
     The differences among GDI, VDI, and other high-level graphics
     interfaces lie not so much in implementation details as in the types
     and complexity of the graphics functions they can perform.



                      Appendix A  Video BIOS Summary



     All computers in the IBM PC and PS/2 family have a BIOS (Basic
     Input/Output System) in ROM. The ROM BIOS contains a set of assembly-
     language routines that provide a low-level programming interface for
     accessing various hardware features, including disk drives, the system
     timer, serial I/O ports, a parallel printer, and, of course, the video
     hardware. By building a video BIOS in ROM into every machine, IBM has
     attempted to provide a common software interface for the various
     machines, despite substantial hardware differences among the IBM PC,
     the PC/XT, the PC/AT, and the PS/2s.

     To a large extent, this endeavor succeeded. Transporting programs
     between IBM PCs with different hardware tends to be easier when the
     programs access the hardware only by calling ROM BIOS routines. This
     is particularly true of programs that manipulate the video display.
     When you consider the many video display configurations available, you
     might regard the BIOS as a sort of "lowest common denominator" for the
     software developer.

     Still, you might not always choose to use ROM BIOS routines for video
     output for several reasons. For one, ROM BIOS video support routines
     are not very fast. When performance is critical, you probably will not
     use them. The speed of the routines is rarely important for tasks
     performed infrequently, such as loading a character set into RAM or
     changing a video display mode. On the other hand, in displaying
     graphics images or producing animation effects, using the BIOS can
     substantially decrease performance.

     Many other tasks are better performed by your operating system rather
     than the BIOS. For example, when you call the BIOS to write characters
     to the screen, you bypass any operating system processing of those
     characters. The BIOS routines know nothing about input/output
     redirection, windowing, or other functions the operating system
     provides.

     Clearly, the video ROM BIOS is essential to IBM PC video programming,
     but the extent to which your programs use it is a matter for your
     judgment.


Hardware Supported by ROM Video BIOS


MDA and CGA

     The ROM BIOS on the motherboard of every IBM/PC, PC/XT, and PC/AT
     supports both the MDA and the CGA. Also, the PS/2 Model 30's video
     BIOS supports an MDA, in addition to its integrated MCGA. When you
     power a PC on, the vector for interrupt 10H is initialized to point to
     the video service routine in ROM.

     IBM's technical documentation frequently refers to the motherboard ROM
     BIOS  in the PCs and PS/2s as the "planar" BIOS. The planar BIOS
     routines start at F000:E000 in the CPU's address space.


EGA

     IBM's EGA contains its own set of video drivers in ROM, located at
     C000:0000. The EGA's cold boot routines initialize interrupt 10H to
     point to its service routine in the EGA ROM BIOS. The EGA BIOS uses
     the interrupt 42H vector to point to the motherboard video service
     routine. Because the EGA's interrupt 10H routines access the
     motherboard BIOS routines whenever necessary through INT 42H, you
     rarely need to execute this interrupt explicitly.


MCGA

     The video ROM BIOS in the PS/2 Models 25 and 30 supports the
     integrated MCGA subsystem in these computers. The Model 30's ROM BIOS
     supports the concurrent use of an MDA, but a CGA cannot be used in the
     same machine because its I/O port assignments and video memory usage
     conflict with those of the MCGA.


VGA

     Video ROM routines in the PS/2 Models 50, 60, and 80, starting at
     E000:0000, support the VGA exclusively. The other video adapters
     described in this book cannot be installed in these computers because
     they are incompatible with the PS/2 MicroChannel bus.


VGA Adapter

     The VGA Adapter's video ROM BIOS routines start at C000:0000. The BIOS
     routines on the VGA Adapter are the same as those in the PS/2 Model
     50, 60, and 80 video BIOS, except for minor differences related to the
     different hardware implementations of the adapter and the integrated
     VGA subsystem.


Interrupt 10H


     The BIOS video routines are written in assembly language and accessed
     by performing 80x86 interrupt 10H. The INT 10H interface is designed
     for assembly-language programs, but you can call the BIOS routines
     directly from programs written in languages such as C or Pascal if
     your language compiler provides a way to execute the interrupt.

     You select a BIOS video support routine by loading a function number
     into register AH. To pass parameters to the BIOS routine, place their
     values in the 80x86 registers before executing INT 10H. Values that
     the BIOS routines return to your program are left in registers as
     well.

     The IBM PC motherboard BIOS routines explicitly preserve the contents
     of registers DS, ES, BX, CX, DX, SI, and DI (unless they are used for
     parameter passing). The EGA, MCGA, and VGA BIOS routines also preserve
     register BP.

       ÉÍÍÍ»     If you are using the IBM PC or PC/XT planar BIOS, preserve
       º T º     register BP across INT 10H calls to the BIOS. For example:
       º I º           push bp                ; preserve BP
       º P º           int  10h               ; call the BIOS
       ÈÍÍÍ¼           pop  bp                ; restore BP


     As a rule, BIOS video input/output routines do not validate data, nor
     do they return status codes or error flags. Thus, your programs should
     never attempt to access an invalid video buffer address, select a
     video page in a video mode that does not support them, or access
     hardware not installed in your system. The BIOS routines do not
     reliably detect any of these errors.


Video BIOS Data Areas


Video Display Data Area

     The BIOS routines maintain several dynamic variables in an area of
     memory called the Video Display Data Area. Figure A-1 contains a
     summary of these variables' addresses, their symbolic names, and their
     contents.


Address             Name           Type      Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0040:0049           CRT_MODE       Byte      Current BIOS video mode number
0040:004A           CRT_COLS       Word      Number of displayed character
                                               columns
0040:004C           CRT_LEN        Word      Size of video buffer in bytes
0040:004E           CRT_START      Word      Offset of start of video
                                               buffer
0040:0050           CURSOR_POSN    Word      Array of eight words
                                               containing the cursor
                                               position for each of eight
                                               possible video pages. The
                                               high-order byte of each word

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                                               contains the character row,
                                               the low-order byte the
                                               character column.
0040:0060           CURSOR_MODE    Word      Starting and ending lines for
                                               alphanumeric cursor. The
                                               high-order byte contains the
                                               starting (top) line; the
                                               low- order byte contains the
                                               ending (bottom) line.
0040:0062           ACTIVE_PAGE    Byte      Currently displayed video page
                                               number
0040:0063           ADDR_6845      Word      I/O port address of CRT
                                               Controller's Address
                                               register (3B4H for
                                               monochrome, 3D4H for color).
0040:0065           CRT_MODE_SE    T         Byte Current value for Mode
                                               Control register (3B8H on
                                               MDA, 3D8H on CGA). On the
                                               EGA and VGA, the value
                                               emulates those used on the
                                               MDA and CGA.
0040:0066           CRT_PALETTE    Byte      Current value for the CGA
                                               Color Select register
                                               (3D9H). On the EGA and VGA,
                                               the value emulates those
                                               used on the MDA and CGA.
0040:0084           ROWS           Byte      Number of displayed character
                                               rows - 1
0040:0085           POINTS         Word      Height of character matrix
0040:0087           INFO           Byte      (See Figure A-1a )
0040:0088           INFO_3         Byte      (See Figure A-1b )
0040:0089           Flags          Byte      Miscellaneous flags (see
                                               Figure A-1c )
0040:008A           DCC            Byte      Display Combination Code table
                                               index
0040:00A8           SAVE_PTR       Dword     Pointer to BIOS Save Area (see
                                               Figure A-3 )
     Figure A-1.  BIOS Video Display Data Area.


Bit       Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
7         Reflects bit 7 of video mode number passed to INT 10H
          function 0
6-5       Amount of video RAM:
                     00b - 64K
                     01b - 128K
                     10b - 192K
                     11b - 256K
4         (reserved)
3         1 - video subsystem is inactive
2         (reserved)
1         1 - video subsystem is attached to monochrome display
0         1 - alphanumeric cursor emulation is enabled
     Figure A-1a.  Mapping of INFO byte at 0040:0087 in the EGA and VGA
     Video Display Data Area.


Bit       Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
7         Input from feature connector on FEAT1 (bit 6 of Input Status
            register 0) in response to output on FC1 (bit 1 of Feature
            Control register)
6         Input from feature connector on FEAT0 (bit 5 of Input Status
            register 0) in response to output on FC1 (bit 1 of Feature
            Control register)
5         Input from feature connector on FEAT1 (bit 6 of Input Status
            register 0) in response to output on FC0 (bit 0 of Feature
            Control register)
4         Input from feature connector on FEAT0 (bit 5 of Input Status
            register 0) in response to output on FC0 (bit 0 of Feature
            Control register)
3         Configuration switch 4 (1 - off, 0 - on)
2         Configuration switch 3 (1 - off, 0 - on)
1         Configuration switch 2 (1 - off, 0 - on)
0         Configuration switch 1 (1 - off, 0 - on)
     Figure A-1b.  Mapping of INFO_3 byte at 0040:0088 in the EGA and VGA
     Video Display Data Area. Bits 4 through 7 reflect the power-on status
     of the feature connector. Bits 0 through 3 reflect the settings of the
     four EGA configuration switches. (The switch values are emulated by
     the VGA BIOS, depending on the type of display attached.)


Bit       Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
7         Alphanumeric scan lines (with bit 4):
          bit 7   bit 4
          0       0       350-line mode
          0       1       400-line mode
          1       0       200-line mode
          1       1       (reserved)
6         1 - display switching is enabled
          0 - display switching is disabled
5         (reserved)
4         (see bit 7)
3         1 - default palette loading is disabled
          0 - default palette loading is enabled
2         1 - using monochrome monitor
          0 - using color monitor
1         1 - gray scale summing is enabled
          0 - gray scale summing is disabled
0         1 - VGA active
          0 - VGA not active
     Figure A-1c.  Mapping of Flags byte at 0040:0089 in MCGA and VGA Video
     Display Data Area.


     Video BIOS routines update the values in the Video Display Data Area
     to reflect the status of the video subsystem. If you alter the video
     environment without invoking an INT 10H routine, be sure you update
     the relevant variables in the Video Display Data Area. Failing to do
     so can cause the BIOS video routines to malfunction.


Save Areas

     The ROM BIOS routines on the EGA, the MCGA, and the VGA support a set
     of save areas, which are dynamic tables of video hardware and BIOS
     information. The video BIOS can use these save areas to supplement the
     Video Display Data Area. You can also use them to override the usual
     video BIOS defaults for character sets, palette programming, and other
     configuration functions.

     The video BIOS save areas are linked by a set of doubleword
     (segment:offset) pointers (see Figure A-2). Use the variable SAVE_PTR
     (at 0040:00A8 in the Video Display Data Area) to locate the save
     areas. SAVE_PTR contains the address of the SAVE POINTER table (see
     Figure A-3). This table contains addresses of as many as seven data
     structures, each with a different format and a different set of data
     pertaining to operation of the video hardware or of the video BIOS
     routines.

     The fifth address in the SAVE POINTER table is that of the SECONDARY
     SAVE POINTER table (see Figure A-4), which only the VGA's BIOS uses.
     This table also contains the addresses of several data structures with
     contents relating to the functioning of the video hardware and the
     BIOS.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³        PTR         ³
     ÀÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
               
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³                    ÃÄÄÄÄÄVideo Parameter table
     ³ SAVE POINTER Table ÃÄÄÄÄÄParameter Save Area
     ³                    ÃÄÄÄÄÄAlphanumeric Character Set Override
     ³                    ÃÄÄÄÄÄGraphics Character Set Override
     ³                    ÃÄÄÄÄÄ¿
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     ³
               ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³   SECONDARY SAVE   ÃÄÄÄÄÄDisplay Combination Code
     ³   POINTER Table    ÃÄÄÄÄÄ2nd Alphanumeric Character Set Override
     ³     (VGA only)     ÃÄÄÄÄÄUser Palette Profile Table
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure A-2.  Video BIOS Save Areas.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Dword            Address of Video Parameter table
4         Dword            Address of Parameter Save Area (EGA, VGA only)
8         Dword            Address of Alphanumeric Character Set Override
0CH       Dword            Address of Graphics Character Set Override
10H       Dword            Address of SECONDARY SAVE POINTER table
                             (VGA only)
14H       Dword            (reserved)
18H       Dword            (reserved)
     Figure A-3.  SAVE POINTER table (EGA, MCGA, VGA).


Offset      Type           Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           Word           Length of SECONDARY SAVE POINTER table in
                             bytes
2           Dword          Address of Display Combination Code table
6           Dword          Address of second Alphanumeric Character
                             Set Override
0AH         Dword          Address of User Palette Profile table
0EH         Dword          (reserved)
12H         Dword          (reserved)
16H         Dword          (reserved)
     Figure A-4.  SECONDARY SAVE POINTER table (VGA only).


     Apart from the SAVE POINTER and SECONDARY SAVE POINTER tables, the

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     only data structures provided in the ROM BIOS are the Video Parameter
     table and, on the VGA, the Display Combination Code table. Thus, the
     only initialized addresses in the SAVE POINTER table are those of the
     Video Parameter table and of the SECONDARY SAVE POINTER table. The
     only initialized address in the SECONDARY SAVE POINTER table belongs
     to the Display Combination Code table. Remaining addresses are
     initialized to 0.


Video Parameter Table

     This data structure contains configuration parameters that the video
     BIOS video mode set routines use. The table contains entries for each
     available video mode. Its structure differs on the various models of
     the EGA, the MCGA, and the VGA. Figure A-5 is a typical entry in the
     VGA Video Parameter table. Formats for table entries in the EGA and
     MCGA BIOS are similar.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Byte             Value for CRT_COLS
1         Byte             Value for ROWS
2         Byte             Value for POINTS
3         Word             Value for CRT_LEN
5         4-byte array     Values for Sequencer registers 1-4
9         Byte             Value for Miscellaneous Output register
0AH       25-byte array    Values for CRTC registers 0-18H
23H       20-byte array    Values for Attribute Controller registers 0-13H
37H       9-byte array     Values for Graphics Controller registers 0-8
     Figure A-5.  Format of a VGA Video Parameter table entry. The VGA
     Video Parameter table comprises 29 such entries.


Parameter Save Area

     When present, this table contains the values of the EGA or the VGA
     Graphics Controller palette registers (00H through 0FH) and the
     Overscan register (11H), as shown in Figure A-6. The video BIOS
     updates the Parameter Save Area whenever it updates the corresponding
     Attribute Controller registers.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         16-byte array    Current contents of Graphics Controller
                             Palette registers
10H       Byte             Current contents of Graphics Controller
                             Overscan register
11H-0FFH  (reserved)
     Figure A-6.  Parameter Save Area. This area is 256 bytes in size.


       ÉÍÍÍ»     When a User Palette Profile (see Figure A-10 later in
       º T º     this discussion) overrides the default palette register
       º I º     values, the Parameter Save Area is updated with default
       º P º     values, not those in the User Palette Profile.
       ÈÍÍÍ¼


Alphanumeric Character Set Override

     This data structure (see Figure A-7) indicates an alphanumeric
     character set to be used instead of the BIOS default character set.
     The character set is loaded whenever the video BIOS is called to
     select one of the video modes that the data structure specifies.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Byte             Length in bytes of each character definition
1         Byte             Character generator RAM bank
2         Word             Number of characters defined
4         Word             First character code in table
6         Dword            Address of character definition table
0AH       Byte             Number of displayed character rows
0BH       Byte array       Applicable video modes
          Byte             0FFH (end of list of video modes)
     Figure A-7.  Alphanumeric Character Set Override.


     On the VGA, you can specify a second 256-character set by creating a
     second Alphanumeric Character Set Override data structure and storing
     its address in the SECONDARY SAVE POINTER table.


Graphics Character Set Override

     This data structure (see Figure A-8) overrides the default BIOS
     character set selection whenever the video BIOS sets up one of the
     specified video modes.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Byte             Number of displayed character rows
1         Word             Length in bytes of each character definition
3         Dword            Address of character definition table
7         Byte array       Applicable video modes
          Byte             0FFH (end of list of video modes)
     Figure A-8.  Graphics Character Set Override.


Display Combination Code Table

     Figure A-9 lists all combinations of video subsystems that the video
     BIOS supports. The description of INT 10H function 1AH in this
     appendix explains how this table is used.

       ÉÍÍÍ»     The MCGA video BIOS contains a Display Combination Code
       º T º     table in ROM to support INT 10H function 1AH. However, the
       º I º     MCGA BIOS does not support a SECONDARY SAVE POINTER table,
       º P º     so you can't modify its DCC table.
       ÈÍÍÍ¼


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Byte             Number of entries in table
1         Byte             DCC table version number
2         Byte             Maximum display type code
3         Byte             (reserved)
4         Word array       Each pair of bytes in the array describes a
                             valid display combination (see INT 10H
                             function 1AH )
     Figure A-9.  Display Combination Code table.


User Palette Profile Table

     This data structure contains user-specified overrides for the default
     Attribute Controller Palette and Overscan register values, for the
     default values in the 256 video DAC color registers, and for the
     default value in the CRTC Underline Location register (see Figure A-
     10). Only the VGA video BIOS supports this table.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         Byte             Underlining:  1 - Enable in all alphanumeric
                                               modes
                                         0 - Enable in monochrome
                                               alphanumeric mode
                                        -1 - Disable in all alphanumeric
                                               modes
1         Byte             (reserved)
2         Word             (reserved)
4         Word             Number of Attribute Controller registers in
                             table
6         Word             First Attribute Controller register number
8         Dword            Address of Attribute Controller register
                             table
0CH       Word             Number of video DAC Color registers in
                             table
0EH       Word             First video DAC Color register number
10H       Dword            Address of video DAC Color register table
14H       Byte array       Applicable video modes
          Byte             0FFH (end of list of video modes)
     Figure A-10.  User Palette Profile table.


Video BIOS Save Area Programming

     To use a data structure supported in the SAVE POINTER and SECONDARY
     SAVE POINTER tables, place the data structure in RAM and update the
     appropriate SAVE POINTER or SECONDARY SAVE POINTER addresses to point
     to it. Because the default SAVE POINTER and SECONDARY SAVE POINTER
     tables are located in ROM, you must copy these tables to RAM and
     update SAVE_PTR (0040:00A8) appropriately before you can modify them.

     Listings A-1 and A-2 demonstrate two uses of the video BIOS save
     areas. The routine in Listing A-1 provides a parameter save area for
     the EGA or VGA BIOS. Once the parameter save area is established, its
     first 17 bytes are updated with the contents of the Attribute
     Controller's 16 palette registers and its Overscan register each time
     the video BIOS writes to them.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing A-1.  Using a Parameter Save Area to keep track of EGA or VGA
     palette registers.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Listing A-2 shows how to specify the palette values to be used when
     the video BIOS routines are invoked to establish a new video mode.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     First, place the values in a table whose address is stored in a User
     Palette Profile data structure. Then place the address of this data
     structure in the SECONDARY SAVE POINTER table. (Since this example
     uses the SECONDARY SAVE POINTER table, you can run it only on the
     VGA.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing A-2.  Using a User Palette Profile to override the
     default VGA palette.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Generally, your application should restore SAVE_PTR to its
       º T º     original value when the SAVE POINTER tables and save areas
       º I º     are no longer needed. If you want to preserve these tables
       º P º     in RAM for use by subsequent applications, use the MS-DOS
       ÈÍÍÍ¼     "Terminate-but-Stay-Resident" function (INT 21H function
                 31H) so that the RAM containing the tables is not freed
                 when the program that creates them terminates.


Interrupt 1DH Vector

     This interrupt vector contains the address of a table of video
     initialization values (see Figure A-11). These values are useful only
     for the MDA and the CGA; however, the table is maintained for
     compatibility among all PCs and PS/2s.


Offset    Type             Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         16-byte array    CRTC registers for 40-by-25 alphanumeric
                             mode (CGA)
10H       16-byte array    CRTC registers for 80-by-25 alphanumeric
                             mode (CGA)
20H       16-byte array    CRTC registers for 320-by-200 4-color or
                             640-by-200 2-color graphics modes (CGA)
30H       16-byte array    CRTC registers for 80-by-25 monochrome
                             (MDA)
40H       Word             Video buffer length (40-by-25 alphanumeric
                             mode)
42H       Word             Video buffer length (80-by-25 alphanumeric
                             mode)
44H       Word             Video buffer length (CGA graphics modes)
46H       Word             Video buffer length (CGA graphics modes)
48H       8-byte array     Number of displayed character columns for
                             video BIOS modes 0 through 7
50H       8-byte array     Values for CRT Mode Control register 3x8H
                             for video BIOS modes 0 through 7
     Figure A-11.  MDA and CGA Video Initialization table. This table's
     address is stored in the vector for INT 1DH.


IBM PC and PS/2 Video BIOS Functions (INT 10H Interface)


     The following pages provide detailed descriptions of each BIOS
     function available through software interrupt 10H. The descriptions
     are intended to complement the function summaries and assembly-
     language source code listings in IBM's technical literature. The
     accompanying source code fragments represent typical programming
     examples that you can modify for your own purposes.

     This summary includes information on the ROM BIOS routines found on
     the motherboard, the EGA, the MCGA, and the VGA. However, not all the
     routines are available or function identically on all computers in the
     IBM PC and PS/2 family.

     All information in this chapter is based on IBM technical
     specifications and on the following dated versions of the video ROM:

     ş  IBM PC motherboard ROM: 10/27/82

     ş  IBM PC/AT motherboard ROM: 6/10/85

     ş  IBM EGA ROM: 9/13/84

     ş  IBM PS/2 Model 30 (MCGA) ROM: 9/2/86

     ş  IBM PS/2 Model 60 (VGA) ROM: 2/13/87

     ş  IBM PS/2 (VGA) Display Adapter ROM: 10/27/86



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0: Select Video Mode

Caller registers:

     AH   =    0
     AL   =    video mode number:
               0      40-by-25 16-color alphanumeric, color burst disabled
               1      40-by-25 16-color alphanumeric, color burst enabled
               2      80-by-25 16-color alphanumeric, color burst disabled
               3      80-by-25 16-color alphanumeric, color burst enabled
               4      320-by-200 4-color graphics, color burst enabled
               5      320-by-200 4-color graphics, color burst disabled
               6      640-by-200 2-color graphics, color burst enabled
               7      80-by-25 monochrome alphanumeric (MDA, Hercules, EGA,
                         and VGA only)
               8      160-by-200 16-color graphics (PCjr only)
               9      320-by-200 16-color graphics (PCjr only)
               0AH    640-by-200 4-color graphics (PCjr only)
               0BH    Reserved (used by EGA BIOS function 11H)
               0CH    Reserved (used by EGA BIOS function 11H)
               0DH    320-by-200 16-color graphics (EGA and VGA only)
               0EH    640-by-200 16-color graphics (EGA and VGA only)
               0FH    640-by-350 monochrome graphics (EGA and VGA only)
               10H    640-by-350 16-color graphics (VGA, EGA with at least
                         128 KB)
                      640-by-350 4-color graphics (64 KB EGA)
               11H    640-by-480 2-color graphics (MCGA, VGA only)
               12H    640-by-480 16-color graphics (VGA only)
               13H    320-by-200 256-color graphics (MCGA and VGA only)

Returned values:

     (none)

Video Display Data Area updates:

     0040:0049  CRT_MODE
     0040:004A  CRT_COLS
     0040:004C  CRT_LEN
     0040:004E  CRT_START
     0040:0050  CURSOR_POSN
     0040:0060  CURSOR_MODE
     0040:0062  ACTIVE_PAGE
     0040:0063  ADDR_6845
     0040:0065  CRT_MODE_SET
     0040:0066  CRT_PALETTE
     0040:0084  ROWS
     0040:0085  POINTS
     0040:0087  INFO
     0040:0088  INFO_3

     INT 10H function 0 puts the video subsystem in the video mode you
     specify with the value in register AL. Function 0 programs the CRT
     Controller, selects a default color palette, and optionally clears the
     video buffer. You can modify several default tasks that function 0
     performs by setting flags in the Video Display Data Area (see INT 10H
     function 12H) or by providing character set or palette attribute
     overrides in BIOS save areas.

     Video mode numbers 0BH and 0CH are reserved for the EGA BIOS support
     routine for RAM-loadable character sets, in which video memory map 2
     is selectively enabled so a table of character definitions can be
     loaded.

     On the EGA, the MCGA, and the VGA, composite video displays are not
     supported, and there is no color burst signal to control. Thus, mode 0
     is the same as mode 1, mode 2 = mode 3, and mode 4 = mode 5.

     If you use this BIOS routine to request a video mode your system
     hardware does not support, the results are unreliable. In particular,
     if you select mode 7 (monochrome alphanumeric) with a CGA, the
     motherboard BIOS programs the CGA's CRT Controller with parameters
     appropriate for an MDA, which results in incomprehensible noise on the
     CGA screen. The third example below shows how to solve this problem by
     setting bits 4 and 5 of EQUIP_FLAG (0040:0010) to indicate which
     subsystem the BIOS is to use.

     On the EGA, the MCGA, and the VGA, if bit 7 of the requested video
     mode number in AL is set to 1, the video buffer is not cleared when
     the new video mode is selected. Thus, a program can alternate between
     two video subsystems without losing the contents of their video
     buffers.

     The following example selects 320-by-200 4-color graphics mode.

        mov  ax,0004        ; AH := 0 (INT 10H function number)
                            ; AL := 4 (video mode number)
        int  10h

     This routine shows how to change modes on the EGA without clearing
     the video buffer.

        mov  ax,000EH       ; select a video mode (in this case,
                            ;  640x200 16-color mode)
        or   al,10000000b   ; set bit 7
        int  10h

     To select video modes in a system containing both a CGA and an MDA,
     use a routine such as the following.

        mov  ax,40h
        mov  es,ax
        and  byte ptr es:[10h],11001111b  ; zero bits 4 and 5 of EQUIP_FLAG
        or   byte ptr es:[10h],00110000b  ; set bits 4 and 5:
                                          ;  11b - monochrome
                                          ;  10b - color (80x25)
                                          ;  01b - color (40x25)
                                          ;  00b - (unused)
        mov  ax,0007

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
        int  10h                          ; select monochrome mode 7

        and  byte ptr es:[10],11001111b   ; zero those bits
        or   byte ptr es:[10],00100000b   ; bits for 80x25 16-color
        mov  ax,0003
        int  10h                          ; select 80x25 16-color mode 3



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 1: Set Alphanumeric Cursor Size

Caller registers:

     AH   =    1
     CH   =    top line of cursor
     CL   =    bottom line of cursor

Returned values:

     (none)

Video Display Data Area update:

     0040:0060  CURSOR_MODE

     INT 10H function 1 programs the CRT Controller to display the
     specified alphanumeric cursor. It programs the CRT Controller's Cursor
     Start and Cursor End registers so that the alphanumeric cursor appears
     between the specified lines in the character matrix. The contents of
     register CX are copied into CURSOR_MODE.

     If the value in CH is 20H the alphanumeric cursor is disabled.

     On the EGA and the VGA, if bit 0 of the INFO byte (0040:0087) is set
     to 0, the BIOS processes the top and bottom line values passed in CH
     and CL relative to an eight-line character matrix. Chapter 3
     discusses this "cursor emulation" in detail.

     Use INT 10H function 1 only in alphanumeric video modes.

     To select a full-height cursor in video mode 3 (80-by-25 16-color
     alphanumeric mode) on a CGA:

        mov  cx,0007h   ; CH := 0 (top line)
                        ; CL := 7 (bottom line of the 8x8 character matrix)
        mov  ah,1       ; AH := 1 (INT 10H function number)
        int  10h

     On an EGA with a 350-line monitor, video mode 3 is a 350-line
     alphanumeric mode with an 8-by-14 character matrix. Nevertheless, the
     above code normally runs unchanged in this situation, because the BIOS
     "emulates" the corresponding 200-line CGA mode and programs the Cursor
     Start and End registers accordingly.



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 2: Set Cursor Location

Caller registers:

     AH   =    2
     BH   =    video page
     DH   =    character row
     DL   =    character column

Returned values:

     (none)

Video Display Data Area update:

     0040:0050  CURSOR_POSN

     INT 10H function 2 updates the BIOS Video Display Data Area, giving a
     new cursor position. If the value in BH references the currently
     displayed video page, this routine also programs the CRT Controller to
     update the displayed cursor position.

     To set the cursor position to column 10, row 5, in 80-by-25 16-color
     mode:

        mov  ah,2           ; AH := 2 (INT 10H function number)
        mov  bh,1           ; BH := video page
        mov  dh,5           ; DH := row
        mov  dl,10          ; DL := column
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 3: Return Cursor Status

Caller registers:

     AH   =    3
     BH   =    video page number

Returned values:

     CH   =    top line of cursor
     CL   =    bottom line of cursor
     DH   =    character row
     DL   =    character column

Video Display Data Area updates:

     (none)

     INT 10H function 3 returns the character cursor location for the
     specified video page. The character row and column values are copied
     from CURSOR_POSN in the Video Display Data Area.

     The values returned in CH and CL are copied from CURSOR_MODE, also in
     the Video Display Data Area. They are meaningful only in alphanumeric
     modes.

     To determine the current cursor location (and size in an alphanumeric
     mode) in video page 0:

        mov  ah,3           ; AH := 3 (INT 10H function number)
        mov  bh,0           ; BH := 0 (video page)
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 4: Return Light Pen Position

Caller registers:

     AH   =    4

Returned values:

     AH   =    1 if valid light pen position returned
          =    0 if no light pen position returned
     BX   =    pixel x-coordinate
     CH   =    pixel y-coordinate (CGA and EGA video modes 4, 5, and 6)
     CX   =    pixel y-coordinate (EGA except modes 4, 5, and 6)
     DH   =    character row
     DL   =    character column

Video Display Data Area updates:

     (none)

     INT 10H function 4 gets the current position of the light pen from the
     CRT Controller's Light Pen High and Light Pen Low registers.

     If the light pen switch is not set, or if the light pen latch has not
     been triggered (that is, if the CRTC's Light Pen High and Light Pen
     Low registers do not contain a valid light pen address), function 4
     returns 0 in register AH. Otherwise, function 4 sets AH to 1, leaves
     the light pen position in registers BX, CX, and DX, and resets the
     light pen trigger.

     When function 4 returns, BX contains the calculated pixel x-coordinate
     at which the light pen was triggered. Since the CRTC returns the light
     pen position as a byte address, the value in BX is only as
     accurate as the number of pixels in each byte of the video buffer. (In
     640-by-200 2-color mode, each byte of the video buffer represents
     eight pixels; function 4 thus returns the pixel x-coordinates
     of every eighth pixel.) The light pen position is calculated relative
     to the start of the displayed portion of the video buffer (CRT_START).

     INT 10H function 4 returns the pixel y-coordinate in either CH (in the
     motherboard BIOS) or CX (in all video modes in the EGA BIOS except
     modes 4, 5, and 6). For example, in 320-by-200 4-color graphics mode,
     the pixel y-coordinate is always returned in CH, but in 80-by-25
     16-color alphanumeric mode, the value is returned in CH on a CGA but
     in CX on an EGA.

     The values that function 4 returns in DH and DL represent the
     character row and column at which the light pen was triggered.

     INT 10H function 4 always returns AH = 0 on the MCGA and the VGA,
     which do not support light pens.

     To determine the light pen status in any video mode, call INT 10H
     function 4:

        mov  ah,4           ; AH := 4 (INT 10H function number)
        int  10h

     For example, if you trigger the light pen near the center of the
     display in 640-by-350 16-color mode, the values returned by this
     function might be:

     AH   =    1     (valid light pen results were returned)
     BX   =  320     (x-coordinate of first pixel at the byte
                     address where the pen was triggered)
     CX   =  175     (pixel y-coordinate)
     DH   =   12     (character row)
     DL   =   40     (character column)



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
Function 5: Select Video Page

Caller registers:

     AH   =    5
     AL   =    video page number

Returned values:

     (none)

Video Display Data Area updates:

     0040:004E  CRT_START
     0040:0062  ACTIVE_PAGE

     INT 10H function 5 selects which portion of the video buffer is
     displayed on the CGA, the EGA, the MCGA, and the VGA. It works by
     programming the CRTC Start Address registers. You can use the function
     in 40-by-25 or 80-by-25 alphanumeric video modes (BIOS modes 0, 1, 2,
     and 3) in any of these subsystems.

     On the CGA, the entire 16 KB video buffer is used in both 320-by-200
     and 640-by-200 graphics modes, so no video paging is possible. Calls
     to function 5 are ignored in these modes.

     On the MCGA, the EGA, and the VGA, video pages are available in both
     alphanumeric and graphics modes up to the limits of video RAM.
     However, the BIOS routine does not check whether video RAM is
     sufficient to support a requested video page; if the requested video
     page lies outside the video buffer, the resulting display is unusable.

     The BIOS maintains a current cursor location for as many as eight
     video pages in CURSOR_POSN. When you invoke Function 5, the BIOS moves
     the cursor to where it was located the last time the requested video
     page was displayed.

     The following routine sets the displayed portion of the CGA's video
     buffer to start at B800:1000 (video page 1) in 80-by-25 alphanumeric
     mode:

        mov  ax,0501h       ; AH := 5 (INT 10H function number)
                            ; AL := 1 (video page number)
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 6: Scroll Up

Caller registers:
     AH   =    6
     AL   =    number of lines to scroll
     BH   =    attribute
     CH   =    upper left corner row
     CL   =    upper left corner column
     DH   =    lower right corner row
     DL   =    lower right corner column

Returned values:

     (none)

Video Display Data Area updates:

     (none)

     INT 10H function 6 performs a row-by-row upward scroll of characters
     in a designated area of the active video page. You specify the number
     of rows of characters to scroll in AL. The rectangular area
     in which the scroll is to be performed is defined by its upper left
     corner, specified in CH and CL, and its lower right corner, specified
     in DH and DL.

     The attribute you specify in BH is used for all blank lines inserted
     in the bottom of the scrolled area. In alphanumeric modes, this
     attribute is formatted in the usual manner, with the background
     attribute in the high nibble and the foreground attribute in the low
     nibble. In graphics modes, the format of the attribute in BH depends
     on the mode.

     In 640-by-200 2-color and 320-by-200 4-color modes, the value in BH
     represents a 1-byte pixel pattern. The byte represents eight 1-bit
     pixels in 640-by-200 2-color mode or four 2-bit pixels in 320-by-200
     4-color mode. The pixel pattern is replicated throughout all lines
     that function 6 blanks in the scroll area. In all other EGA, MCGA, and
     VGA graphics modes, the value in BH determines the value of all pixels
     in the blanked lines.

     In 320-by-200 4-color mode on the EGA, the MCGA, and the VGA, function
     6 always scrolls video page 0, regardless of which video page is
     currently displayed.

     Specifying 0 as the number of rows to scroll in AL causes the entire
     scroll area to be blanked.

     In 80-by-25 16-color alphanumeric mode, you can scroll the entire
     screen up one line with the following sequence:

        mov  ax,601h        ; AH := 6 (INT 10H function number)
                            ; AL := 1 (number of lines to scroll up)
        mov  bh,7           ; BH := 7 (attribute)
        mov  cx,0           ; CH := upper left corner:  row 0
                            ; CL := upper left corner:  column 0
        mov  dx,184Fh       ; DH := lower right corner:  row 24 (18H)
                            ; DL := lower right corner:  column 79 (4FH)
        int  10h

     In the same video mode, you could clear only the top three lines of
     the display with a background attribute of 1 (blue on a CGA) and a
     foreground attribute of 7 (white) using this routine:

        mov  ax,600h        ; AH := INT 10H function number
                            ; AL := 0 (clear the scroll area)
        mov  bh,17h         ; BH := attribute (background 1, foreground 7)
        mov  cx,0           ; CH,CL := upper left corner at (0,0)
        mov  dx,024Fh       ; DH,DL := lower right corner at (2,79)
        int  10h

     To get the same result in 640-by-350 16-color graphics mode on the
     EGA, you set the value in BH to indicate a pixel value instead of an
     alphanumeric attribute:

        mov  ax,600h
        mov  bh,1           ; BH := pixel value
        mov  cx,0
        mov  dx,024Fh
        int  10h

     In 640-by-200 2-color mode, the following call to INT 10H function 6
     fills the display with vertical stripes of alternating pixel values:

        mov  ax,600h
        mov  bh,10101010b   ; BH := pixel pattern
        mov  cx,0
        mov  dx,184Fh
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 7: Scroll Down

Caller registers:

     AH   =    7
     AL   =    number of lines to scroll
     BH   =    attribute
     CH   =    upper left corner row
     CL   =    upper left corner column
     DH   =    lower right corner row
     DL   =    lower right corner column

Returned values:

     (none)

Video Display Data Area updates:

     (none)

     INT 10H function 7 performs a row-by-row downward scroll of characters
     in a designated area of the active video page. Except for the direc-
     tion of the scroll, this BIOS function is identical to function 6.



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 8: Return Character Code and Attribute at Cursor

Caller registers:

     AH   =    8
     BH   =    video page

Returned values:

     AH   =    attribute (alphanumeric modes only)
     AL   =    ASCII code

Video Display Data Area updates:

     (none)

     INT 10H function 8 returns the ASCII code of the character at the
     current cursor position in the video page that BH specifies. In
     alphanumeric modes, this is done by reading a single word from the
     video buffer. In graphics modes, the routine compares the character
     matrix at the cursor position to the bit patterns in the current
     graphics character definition table.

     In graphics modes, the PC/XT and PC/AT BIOS uses the ROM character
     definitions at F000:FA6E; the EGA, MCGA, and VGA BIOS uses the
     definitions designated by the interrupt 43H vector. For ASCII codes
     80-0FFH in CGA-compatible graphics modes 4, 5, and 6, the BIOS uses
     the characters defined in the table indicated by the interrupt 1FH
     vector.

     To determine the character code for a character in a graphics mode,
     the BIOS routine regards nonzero pixels as foreground pixels. It is

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     the pattern of foreground (nonzero) and background (zero) pixels that
     is compared to the bit patterns in the table. If the pixel pattern in
     the video buffer matches a bit pattern in the character definition
     table, the BIOS determines the character's ASCII code from the bit
     pattern's location in the table. If the pixel pattern in the video
     buffer does not match any bit pattern in the table, the BIOS routine
     returns 0 in AL.

     In 320-by-200 4-color mode on the EGA, the MCGA, and the VGA, this
     function works properly only in video page 0.

     The following code fragment reads the character in the screen's upper
     left corner:

        mov  ah,0Fh         ; AH := 0FH (INT 10H function number)
        int  10h            ; leaves BH = active video page
        mov  ah,2           ; AH := 2 (INT 10H function number)
        mov  dx,0           ; DH,DL := row 0, column 0
        int  10h            ; sets cursor position to (0,0)
        mov  ah,8           ; AH := 8 (INT 10H function number)
        int  10h            ; leaves AL = ASCII code



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 9: Write Character and Attribute at Cursor

Caller registers:

     AH   =    9
     AL   =    ASCII code
     BH   =    background pixel value (320-by-200 256-color mode) or video
               page (all other modes)
     BL   =    foreground pixel value (graphics modes) or attribute value
               (alphanumeric modes)
     CX   =    repetition factor

Returned values:

     (none)

Video Display Data Area updates:

     (none)

     INT 10H function 9 writes a character one or more times into the video
     buffer without moving the cursor. You must specify a repetition factor
     of 1 or greater in CX. The BIOS writes a string composed of the
     character in AL into the buffer. The length of the string is
     determined by the repetition factor in CX.

     In alphanumeric modes, both the ASCII code and the corresponding
     attribute byte are updated for each character written into the video
     buffer. In graphics modes, each character is written into the buffer
     in a rectangular area the size of the character matrix. The value in
     BL is used for the character's foreground pixels. In 320-by-200 256-
     color graphics mode, the value in BH specifies the character's
     background pixel value; in all other graphics modes, BH designates a
     video page, so the character's background pixels are 0. In all
     graphics modes except 320-by-200 256-color mode, the character is
     XORed into the buffer if bit 7 of BL is set to 1.

     INT 10H function 9 does not compare the repetition factor with the
     number of displayed character columns. In alphanumeric modes, this may
     not matter; the video buffer map is such that a string too long to be
     displayed in one row of characters wraps to the next row. In graphics
     modes, however, a string should be no longer than the remainder of the
     current character row.

     You must specify a video page in register BH in alphanumeric modes as
     well as in native EGA graphics modes, but the value in BH is ignored
     by the EGA, the MCGA, and the VGA BIOS in 320-by-200 4-color graphics
     mode.

     The following routine writes a string of 20 asterisks to the upper
     left corner of the display in 80-by-25 16-color mode. The foreground
     value in each character's attribute byte is set to 7, and the
     background value is set to 1. The cursor is positioned with a call to
     INT 10H function 2 before the string is written with function 9.

        mov  ah,2           ; AH := 2 (INT 10H function number)
        mov  bh,0           ; BH := video page
        mov  dx,0           ; DH := cursor row
                            ; DL := cursor column
        int  10h            ; set cursor position to (0,0)
        mov  ah,9           ; AH := 9 (INT 10H function number)
        mov  al,'*'         ; AL := ASCII code
        mov  bl,17h         ; BL := attribute byte
        mov  cx,20          ; CX := repetition factor
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0AH: Write Character(s) at Cursor Position

Caller registers:

     AH   =    0AH
     AL   =    ASCII code
     BH   =    background pixel value (320-by-200 256-color mode) or video
               page (all other modes)
     BL   =    foreground pixel value (graphics modes only)
     CX   =    repetition factor

Returned values:

     (none)

Video Display Data Area updates:

     (none)

     INT 10H function 0AH is the same as INT 10H function 9, with this
     exception: In alphanumeric video modes, only the character code is
     written into the video buffer. The character's attribute remains
     unchanged in the buffer.

     This example clears one character row from the cursor position to its
     end. Before calling function 0AH, the example determines the active
     video page and the number of displayed character columns with a call
     to INT 10H function 0FH, and the cursor position using INT 10H
     function 3.

        mov  ah,0Fh         ; AH := 0FH (INT 10H function number)
        int  10h            ; leaves AH = number of columns,
                            ;        BH = active video page
        mov  al,ah
        xor  ah,ah          ; AX := number of columns
        push ax
        mov  ah,3           ; AH := 3 (INT 10H function number)
        int  10h            ; leaves DH,DL = cursor position
        pop  cx             ; CX := displayed character columns
        sub  cl,dl          ; CX := number of remaining chars in line
        xor  bl,bl          ; BL := foreground pixel value
        mov  ax,0A20h       ; AH := 0AH (INT 10H function number)
                            ; AL := 20H (ASCII blank character)
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0BH: Set Overscan Color, Select 4-Color Palette

Caller registers:

     AH   =    0BH
     BH   =    0 to set border or background color
          =    1 to select 4-color palette
     BL   =    color value (if BH = 0)
               palette value (if BH = 1)

Returned values:

     (none)

Video Display Data Area update:

     0040:0066  CRT_PALETTE

     INT 10H function 0BH comprises two subfunctions selected according to
     the value in BH. Function 0BH is intended for use only in 320-by-200
     4-color mode and in CGA alphanumeric modes, but you can use it with
     caution in other video modes.


     BH = 0
     When BH = 0 on the CGA and the MCGA, the BIOS loads the low-order five
     bits of the value in BL into the Color Select register (3D9H). In 320-
     by-200 4-color graphics mode, bits 0-3 determine the background color
     (the color displayed for pixels of value 0) as well as the border
     color. In 640-by-200 and 640-by-480 2-color modes, bits 0-3 specify
     the color of foreground (nonzero) pixels. On the CGA, these same four
     bits also determine the border color in alphanumeric modes.

     Bit 4 of the Color Select register selects between normal and high-
     intensity colors in CGA and MCGA graphics modes (see Chapter 4). For
     compatibility, the BIOS for the EGA and the VGA emulates this effect
     by using a palette of high-intensity colors when bit 4 of BL is set.

     In 200-line modes on the EGA and VGA, the value in BL is placed in
     the Attribute Controller's Overscan Color register (11H). This sets
     the border color. If either subsystem is in a graphics mode, the same
     value is also stored in palette register 0. This establishes the same
     color for all pixels of value 0.

     Don't use function 0BH with BL = 0 in other EGA and VGA video modes.
     In some modes, the BIOS routine stores incorrect color values in the
     Palette and Overscan registers, while in others it does nothing at
     all. You should use INT 10H function 10H to program the Attribute
     Controller on the EGA and VGA.

     Once the color register or Attribute Controller has been programmed,
     the BIOS routine copies bit 5 of CRT_PALETTE in the Video Display Area
     to bit 0 of register BL, and transfers control to the routine for
     BH = 1.


     BH = 1
     When BH = 1, the low-order bit of the value in BL determines which of

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     two 4-color palettes is used for 320-by-200 4-color mode (see Figure
     A-12). On the CGA and the MCGA, this bit is copied into bit 5 of the
     Color Select register (3D9H). On the EGA and the VGA, the bit
     determines which set of color values is loaded into the Attribute
     Controller's Palette registers. The colors correspond to the CGA's
     320-by-200 4-color palettes. (See Chapter 4 for more details.)


Pixel Value            Color Displayed
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
(bit 0 of BL = 0)
1                      Green
2                      Red
3                      Yellow


(bit 0 of BL = 1)
1                      Cyan
2                      Violet
3                      White
     Figure A-12.  Function 0BH 4-color palettes.


     Function 0BH with BH = 1 has no effect in alphanumeric modes. In
     graphics modes other than 320-by-200 4-color mode, however, the Color
     Select register (on the CGA and the MCGA) is loaded or the palette
     registers (on the EGA and the VGA) are updated as if 320-by-200 4-
     color mode were in effect. For this reason, you should use this
     subfunction cautiously in graphics modes other than 320-by-200 4-color
     mode.

     The following example has three different effects, depending on the
     current video mode. In 200-line alphanumeric modes, it sets the border
     color; in 320-by-200 4-color mode it sets both border and background
     colors; and in CGA or MCGA 2-color graphics modes, it sets the
     foreground color.

        mov  ah,0BH         ; AH := 0BH (INT 10H function number)
        mov  bh,0           ; BH := subfunction number
        mov  bl,BorderColor ; BL := color value
        int  10h

     To select a 4-color palette in 320-by-200 4-color mode, call function
     0BH with  BH = 1:

        mov  ah,0Bh
        mov  bh,1           ; BH := subfunction number
        mov  bl,0           ; bit 0 of BL := 0 (red-green-yellow palette)
        int  10h

     In 320-by-200 4-color mode, select a high-intensity set of colors by
     calling function 0BH with BH = 0 and with bit 4 of BL set to 1:

        mov  ah,0Bh
        mov  bh,0
        mov  bl,10h         ; bit 4 selects high-intensity palette
                            ; bits 3-0 select border/background color
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0CH: Store Pixel Value

Caller registers:

     AH   =    0CH
     AL   =    pixel value
     BH   =    video page
     CX   =    x-coordinate
     DX   =    y-coordinate

Returned values:

     (none)

Video Display Data Area updates:

     (none)

     INT 10H function 0CH updates the value of a pixel at a specified
     location in the video buffer. In all graphics modes except 320-by-200
     256-color mode, if the high-order bit of the value in AL is set to 1,
     the value in AL is XORed into the video buffer. Otherwise, the value
     in AL becomes the pixel's new value.

     On the EGA, the MCGA, and the VGA, the value in BH is used to select
     among available video pages in the current video mode. However, the
     value in BH is ignored in 320-by-200 4-color mode.

     To set the value of a pixel in a 350-line graphics mode on an EGA with
     only 64 KB of video RAM, you must account for the chaining of memory
     maps to bit planes (as discussed in Chapter 4). In this situation,
     the BIOS routine expects you to specify the pixel value in AL using
     only its odd-numbered bits. Thus, the four possible pixel values
     should be specified as 0 (0000B), 1 (0001B), 4 (0100B), and 5 (0101B)
     instead of 0, 1, 2, and 3.

     The following routine shows how you would set the value of the pixel
     at (200,100) to 1 in any graphics mode:

        mov  ah,0Ch         ; AH := 0CH (INT 10H function number)
        mov  al,1           ; AL := pixel value
        mov  cx,200         ; CX := x-coordinate
        mov  dx,100         ; DX := y-coordinate
        int  10h

     To XOR a pixel value into the video buffer, set bit 7 of AL to 1
     before executing interrupt 10H, as in the following procedure:

        mov  ah,0Ch
        mov  al,1
        mov  cx,200
        mov  dx,100
        or   al,10000000b   ; set bit 7 to indicate XOR
        int  10h

     This code fragment illustrates the special situation that arises in a
     350-line video mode on an IBM EGA with only 64 KB of video RAM. The
     code sets the value of the pixel at (75,50) to 3.

        mov  ah,0Ch
        mov  al,0101b       ; AL := pixel value of 3 (11B)
                            ; represented in odd bits only
        mov  cx,75
        mov  dx,50
        int  10h



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0DH: Return Pixel Value

Caller registers:

     AH   =    0DH
     BH   =    video page
     CX   =    x-coordinate
     DX   =    y-coordinate

Returned values:

     AL   =    pixel value

Video Display Data Area updates:

     (none)

     INT 10H function 0DH returns the value of a pixel at a specified
     location in the video buffer.

     On an EGA in 320-by-200 4-color mode, the function ignores the video
     page value specified in BH.

     IBM's EGA BIOS (9/13/84 version) contains a bug in INT 10H function
     0DH. In 350-line graphics modes on an IBM EGA with only 64 KB of video
     RAM, the value returned in AL is incorrect. Apparently, the BIOS
     routine calculates the pixel's byte offset in the video buffer without
     properly accounting for the mapping of even addresses to even bit
     planes and odd addresses to odd bit planes.

     To determine the value of the pixel at (100,100), you could execute
     the following sequence of instructions:

        mov  ah,0Dh         ; AH := 0DH (INT 10H function number)
        mov  bh,0           ; BH := video page (0 in this example)
        mov  cx,100         ; CX := x-coordinate
        mov  dx,100         ; DX := y-coordinate
        int  10h            ; leaves AL = pixel value



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0EH: Display Character in Teletype Mode

Caller registers:

     AH   =    0EH
     AL   =    ASCII code
     BH   =    video page (PC BIOS versions dated 10/19/81 and earlier)
     BL   =    foreground pixel value (graphics modes only)

Returned values:

     (none)

Video Display Data Area update:

     0040:0050  CURSOR_POSN

     INT 10H function 0EH calls INT 10H function 0AH to display the
     character you pass in register AL. Unlike function 0AH, however,
     function 0EH moves the cursor, and ASCII codes 7 (bell), 8
     (backspace), 0DH (carriage return), and 0AH (linefeed) are treated as
     cursor control commands instead of displayable characters. Function
     0EH always updates the active (currently displayed) video page except
     as noted above.

     If the character is displayed in the rightmost character column,

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     function 0EH advances the cursor to the start of the next character
     row. If necessary, function 0EH calls INT 10H function 06H to scroll
     the screen. In alphanumeric modes, the attribute of the displayed
     character is used for the scroll. In graphics modes, the scroll
     attribute is always 0.

     In alphanumeric modes, the attribute byte at the position where the
     character is written determines the character's foreground and
     background attributes. For this reason, you should probably fill the
     video buffer with the desired alphanumeric attributes before using
     function 0EH.

     In graphics modes, the character is written into the video buffer in a
     rectangular area the size of the character matrix. The character's
     pixels have the value BL specifies, and the remaining background
     pixels have a value of 0. Because the value in BL is passed through to
     INT 10H function 0AH, you can set bit 7 so that the character is XORed
     into the video buffer.

     NOTE: Unfortunately, function 0EH does not expand tab characters
     (ASCII code 9) into blanks.

     The following routine shows how you might use function 0EH to display
     a string of characters.

        mov  cx,StringLength        ; CX := number of bytes in string
        jcxz L02                    ; do nothing if null string
        mov  si,StringAddr          ; DS:SI := address of string
        mov  bl,GraphicsAttribute   ; BL := attribute (graphics modes only)
L01:    lodsb                       ; AL := next character in string
        mov  ah,0Eh                 ; AH := 0EH (INT 10H function number)
        int  10h
        loop L01
L02:    .
        .
        .



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 0FH: Return Current Video Status

Caller register:

     AH   =    0FH

Returned values:

     AH   =    number of displayed character columns
     AL   =    video mode number
     BH   =    active video page

Video Display Data Area updates:

     (none)

     INT 10H function 0FH returns information about the current video mode
     and the width of the displayed portion of the video buffer. The number
     of character columns (returned in AH) and the number of the current
     video page (returned in BH) are copied from CRT_COLS and ACTIVE_PAGE
     in the Video Display Data Area.

     The value returned in AL is copied from CRT_MODE in the Video Display
     Data Area. It corresponds to the video display modes tabulated for
     function 0. On the EGA and the VGA, bit 7 of the value in AL is
     derived from bit 7 of the INFO byte. (INT 10H function 0 sets bit 7 of
     the INFO byte whenever you use function 0 to select a video mode
     without clearing the video buffer.)

     This example shows how to determine the current position of the
     displayed cursor. Before calling INT 10H function 3 to find out the
     cursor position, the example uses function 0FH to determine the
     currently displayed video page.

        mov  ah,0Fh         ; AH := 0FH (INT 10H function number)
        int  10h            ; leaves BH = active video page
        mov  ah,3           ; AH := 3 (INT 10H function number)
        int  10h            ; leaves DH,DL = cursor position



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Function 10H: Set Palette Registers, Set Intensity/Blink Attribute

Caller registers:

     AH   =    10H

Update a specified palette register:

     AL   =    0
     BH   =    color value
     BL   =    palette register number

Specify the overscan (border) color:

     AL   =    1
     BH   =    color value

Update all 16 palette registers plus the Overscan register:

     AL    =    2
     ES:DX =    address of 17-byte table

Select Background Intensity or Blink attribute:

     AL   =    3
     BL   =    0 for background intensity (blink disabled)
          =    1 for blink

Read a specified palette register:

     AL   =    7
     BL   =    palette register number

     Returned value:
     BH   =    contents of specified palette register

Read the contents of the Overscan register:

     AL   =    8

     Returned value:
     BH   =    contents of Overscan register

Read all 16 palette registers plus the Overscan register:

     AL    =    9
     ES:DX =    address of 17-byte table

     Returned values:
     Bytes 00H through 0FH of table contain palette register values.
     Byte 10H of table contains Overscan register value.

Update the specified video DAC Color register:

     AL   =    10H
     BX   =    color register number
     CH   =    green value
     CL   =    blue value
     DH   =    red value

Update a block of video DAC color registers:

     AL    =    12H
     BX    =    first register to update
     CX    =    number of registers to update
     ES:DX =    address of table of red-green-blue values

Set Attribute Controller Color Select State:

     AL   =    13H
     BL   =    0 to set Mode Control register bit 7, 1 to set Color Select
                 register
     BH   =    value for bit 7 (if BL = 0) or value for Color Select
                 register (if BL = 1)

Read specified video DAC Color register:

     AL   =    15H
     BX   =    color register number

     Returned values:
     CH   =    green
     CL   =    blue
     DH   =    red

Read a block of video DAC color registers:

     AL    =    17H
     BX    =    first register to read
     CX    =    number of registers to read
     ES:DX =    address of table of red-green-blue values

     Returned values:
     Bytes 0 through 3n - 1 (where n is the number of registers passed in
     CX) contain the red-green-blue values read from the specified block of
     color registers.

Update video DAC Mask register:

     AL   =    18H
     BL   =    new mask value

Read video DAC Mask register:

     AL   =    19H

     Returned value:
     BL   =    value read from video DAC Mask register

Read Attribute Controller Color Select register:

     AL   =    1AH

     Returned values:
     BL   =    bit 7 of Mode Control register
     BH   =    bits 2 through 3 of Color Select register (if BL = 0)
               bits 0 through 3 of Color Select register (if BL = 1)


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
Perform gray-scaling on a block of video DAC color registers:

     AL   =    1BH
     BX   =    first color register in block
     CX   =    number of color registers

Video Display Data Area updates:

     0040:0065  CRT_MODE_SET
     0040:0066  CRT_PALETTE

     INT 10H function 10H exists only in the EGA, MCGA, and VGA BIOS. The
     function comprises 16 subfunctions that are selected according to the
     value in AL. Figure A-13 shows the support that the various
     subsystems provide for these subfunctions. All subfunctions work in
     both alphanumeric and graphics modes.

     Subfunctions 0 through 9 support attribute and palette programming.
     Subfunctions 10H through 1BH support the video DAC on the MCGA and the
     VGA.


     AL = 0
     When AL = 0 on the EGA and the VGA, function 10H updates the value in
     one of the palette registers in the Attribute Controller. The routine
     loads the value in BH into the register that BL specifies.

     Although this subfunction's intended purpose is to load a color value
     into a palette register, the BIOS routine does not validate the
     register number in BL. Thus, you can also use it to update the
     Attribute Controller's Mode Control, Overscan, Color Plane Enable, and
     Horizontal Pel Panning registers.

     On the MCGA, when BH = 7 and BL = 12H, the BIOS routine sets bit 3 of
     the Video DAC Mask register (3C6H) to 0. This causes the BIOS to
     regard bit 3 of all 4-bit pixel values or alphanumeric attributes as a
     "don't care" bit in reference to the Video DAC color registers, so
     only the first eight registers can be referenced. This is useful in
     displaying two 256-character sets in an alphanumeric mode (see Chapter
     10). The MCGA BIOS ignores all other values in BH or BL.


Subfunction           EGA           MCGA         VGA
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0                     x             x            x
1                     x                          x
2                     x                          x
3                     x             x            x
4 (reserved)
5 (reserved)
6 (reserved)
7                                                x
8                                                x
9                                                x
10H                                 x            x
11H (reserved)
12H                                 x            x
13H                                              x
14H (reserved)
15H                                 x            x
16H (reserved)
17H                                 x            x
18H                                 x            x
19H                                 x            x
1AH                                              x
1BH                                 x            x
     Figure A-13.  INT 10H Function 10H support in EGA, MCGA, and VGA BIOS.


     AL = 1
     When AL = 1 on the EGA and the VGA, the BIOS copies the value in BH
     into the Attribute Controller's Overscan register (11H).


     AL = 2
     When AL = 2 on the EGA and the VGA, the BIOS expects ES:DX to contain
     the address of a 17-byte table of values for the 16 Palette registers
     (bytes 0 through 15) and for the Overscan register (byte 16). The
     routine copies these values into the corresponding registers in the
     Attribute Controller.


     AL = 3
     When AL = 3 on the EGA and the VGA, the value in BL determines the
     value of bit 3 of the Attribute Controller's Mode Control register
     (10H). If BL = 0, bit 3 of the Mode Control register value is set to
     0, disabling the blinking attribute. If BL is 1, bit 3 is set to 1 to
     enable blinking.

     When AL = 3 on the MCGA, bit 5 of the Color Control register (3D8H) is
     set to reflect the value in BL. If BL = 0, bit 5 is set to 0 to
     disable blinking. If BL is 1,  bit 5 is set to 1.


     AL = 7
     When AL = 7 on the VGA, the value in the Attribute Controller Palette
     register that BL specified is returned in BH. Because the BIOS does
     not check the specified register number, this subfunction may be used
     to return the contents of any VGA Attribute Controller register.


     AL = 8
     When AL = 8 on the VGA, the contents of the Attribute Controller's
     Overscan register are returned in BH.


     AL = 9
     When AL = 9 on the VGA, the contents of all 16 palette registers and
     the Overscan register are returned to a 17-byte table whose address
     was passed to the BIOS in the register pair ES:DX.


     AL = 10H
     When AL = 10H on the MCGA and the VGA, the video DAC color register
     that BX specifies is updated with the red, green, and blue values
     specified in DH, CH, and CL. Only the low-order six bits of each of
     the three color values are significant.

     If gray-scale summing is enabled, the value stored in the color
     register is the gray-scale value that corresponds to the specified
     color values (see INT 10H function 12H with BL = 33H).


     AL = 12H
     When AL = 12H on the MCGA and the VGA, a block of consecutive video
     DAC color registers is updated from the table whose address is passed
     in ES:DX. The value in BX (00H through 0FFH) indicates the first color
     register to update, and CX contains the number of registers affected.
     The BIOS routine performs no error checking; if the sum of the values
     in BX and CX is greater than 256 (100H), the routine wraps around and
     updates the first color register(s) in the video DAC.

     If gray-scale summing is enabled, the values stored in the color
     registers are the gray-scale values that correspond to the color
     values in the table (see INT 10H function 12H with BL = 33H).

     You must format the table in three-byte groups. Each group must
     contain a red color value in the first byte, a green value in the
     second byte, and a blue value in the third byte. Only the low-order
     six bits of each color value are significant.


     AL = 13H
     On the VGA, when AL = 13H, the ROM BIOS updates the Attribute
     Controller's Mode Control register (10H) and the Color Select register
     (14H) to enable grouping of the 256 video DAC color registers into
     blocks of 16 or 64 registers each, as discussed in Chapter 3.

     When BL = 0, the BIOS uses the value passed in BH to update bit 7 of
     the Mode Control register. When BH = 1, bit 7 is set to 1. This causes
     the BIOS to use bits 0 and 1 of the Color Select register in
     place of bits 4 and 5 of the palette register values. When BH = 0,
     bit 7 is set to 0, and all six low-order bits of the values in the
     palette registers are significant.

     When BL = 1, the value in BH is stored in the appropriate bit fields
     in the Color Select register. If bit 7 of the Mode Control register is
     1, bits 0 through 3 of the value in BH are copied into bits 0 through
     3 of the Color Select register. If bit 7 of the Mode Control register
     is 0, bits 0 through 1 of BH are copied into bits 2 through 3 of the
     Color Select register.


     AL = 15H
     When AL = 15H on the MCGA and the VGA, the contents of the video DAC
     color register specified in BX are returned in registers DH (red), CH
     (green), and CL (blue). Only the low-order six bits of each of the
     color values are significant.


     AL = 17H
     When AL = 17H on the MCGA and the VGA, the values from a block of
     adjacent video DAC color registers are copied to the table whose
     address is passed in ES:DX. The value in BX (00H through 0FFH)
     indicates the first color register to be read, and CX contains the
     number of registers affected. The BIOS routine performs no error
     checking; the sum of the values in BX and CX should not exceed 256
     (100H).

     The table must contain three bytes for every color register read.
     Color values for each register are stored sequentially in the table in
     three-byte groups. The first byte of each group contains the color
     register's red value, the second its green value, and the third its
     blue value.


     AL = 18H
     On the MCGA and the VGA, when AL = 18H, the value in BL is copied into
     the video DAC Mask register (3C6H).


     AL = 19H
     On the MCGA and the VGA, when AL = 19H, the value in the video DAC
     Mask register (3C6H) is returned in BL.

     NOTE: The BIOS on the VGA Adapter does not support subfunctions 18H
     and 19H. Also, IBM's BIOS Interface Technical Reference does not
     document these subfunctions, so they might not be supported in future

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     BIOS releases.


     AL = 1AH
     On the VGA, when AL = 1AH, the current values of bit 7 of the
     Attribute Controller's Mode Control register (10H) and bits 0 through
     3 of the Color Select register (14H) are returned in BL and BH
     respectively. If bit 7 of the Mode Control register is 1, the value in
     BH represents bits 0 through 3 of the Color Select register. If bit 7
     of the Mode Control register is 0, only bits 2 through 3 are returned
     as bits 0 through 1 of BH.


     AL = 1BH
     On the MCGA and the VGA, when AL = 1BH, gray-scale summing is
     performed on a block of consecutive video DAC color registers. BX
     indicates the first color register affected. CX specifies the number
     of registers to update.

     The following example uses INT 10H function 10H to update the color
     value in a single palette register:

        mov  ax,1000h       ; AH := 10H (INT 10H function number)
                            ; AL := 0
        mov  bh,6           ; BH := new color value (yellow)
        mov  bl,7           ; BL := palette register number
        int  10h

     To update the Overscan register and change the displayed border color,
     call function 10H with AL = 1:

        mov  ax,1001h       ; AH := 10H
                            ; AL := 1
        mov  bh,1           ; BH := color value for overscan
        int  10h

     To load all 16 palette registers and the Overscan register from a
     table, call function 10H with AL = 2:

        mov  ax,1002h               ; AH := 10H
                                    ; AL := 2
        mov  dx,seg PaletteTable
        mov  es,dx
        mov  dx,offset PaletteTable ; ES:DX -> table of palette register
                                    ;           values
        int  10h
        .
        .
        .
PaletteTable db    00h,01h,02h,03h,04h,05h,06h,07h ; palette registers 0-7
             db    38h,39h,3Ah,3Bh,3Ch,3Dh,3Eh,3Fh ; palette regs 8-0FH
             db    00h                             ; Overscan reg

     To disable the blinking attribute, call function 10H with AL = 3 and
     BL = 0:

        mov  ax,1003h       ; AH := 10H
                            ; AL := 3
        mov  bl,0           ; BL := 0 (disable blinking)
        int  10h

     The following fragment performs gray-scale summing on the first 16
     video DAC color registers. The remaining 240 registers are unaffected.

        mov  ax,101Bh       ; AH := 10H
                            ; AL := 1BH
        mov  bx,0           ; BX := first color register affected
        mov  cx,16          ; CX := number of color registers
        int  10h

