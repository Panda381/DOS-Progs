
Hercules InColor Card

     On the InColor Card, the value of bit 4 of the Exception register
     (17H) determines whether the palette registers are used to decode
     pixel values, just as it does in alphanumeric modes. When this bit is
     set to 1, each 4-bit pixel value specifies a palette register, and the
     6-bit color value in the palette register determines the displayed
     color of the pixel.

     Setting Exception register bit 4 to 0 bypasses the palette registers.
     Each 4-bit pixel value is extended to 6 bits by replicating the high-
     order bit, and the new value determines the color. This procedure,
     called sign extension, in effect causes the high-order bit of a pixel
     value to act as an "intensity" bit, similar to the way alphanumeric
     attributes are decoded.


MCGA

     The MCGA emulates both of the CGA's graphics modes and adds two of its
     own, a 640-by-480 2-color mode and a 320-by-200 256-color mode. The
     256-color mode is the only MCGA video mode that uses the video Digital
     to Analog Converter (DAC) to full advantage.


     2-Color Graphics Modes
     Pixel attributes in 640-by-200 and 640-by-480 2-color modes are
     directed through the video DAC registers. Pixels with the value 0 are

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     always mapped through video DAC color register 0. Nonzero pixels also
     select a predesignated video DAC color register, but this is done in
     one of two ways, depending on the value of bit 2 of the Mode Control
     register at 3D8H. If bit 2 is 1, video DAC color register 7 is
     selected. If bit 2 is 0, bits 0 through 3 of the Color Select register
     (port 3D9H) designate a video DAC register.

     On the MCGA, the background color in 2-color graphics modes is not
     necessarily black as it is on the CGA. Instead, both background and
     foreground can be any of the 256 K colors or the 64 gray-scale values
     that the MCGA can display. Use INT 10H function 10H to set the
     appropriate video DAC color registers.

       ÉÍÍÍ»     When the video BIOS sets up 2-color graphics modes, it
       º T º     sets bit 2 of the Mode Control register to 0 and bits 0
       º I º     through 3 of the Color Select register to 1111B (0FH).
       º P º     Since the first 16 video DAC color registers contain the
       ÈÍÍÍ¼     16 colors available on a CGA, this configuration emulates
                 the default color configuration on a CGA in 640-by-200 2-
                 color mode: Background pixels are displayed as black (the
                 value in video DAC color register 0) and foreground pixels
                 appear intense white (the value in video DAC color
                 register 0FH).


     4-Color Graphics Mode
     The MCGA faithfully emulates this CGA graphics mode. The major
     difference is that the MCGA maps the four available colors through the
     video DAC color registers just as it does in 2-color graphics modes.
     Thus, all four colors can be selected from the 256 K possibilities
     that the video DAC offers.

     The MCGA combines bits 4 and 5 of the Color Select register (port
     3D9H) with each pixel's 2-bit value to create a 4-bit value that
     designates one of the first 16 video DAC color registers (see Figure
     4-13). The video BIOS initializes the video DAC color registers with
     CGA-compatible palettes. The colors are chosen so that bit 5 of the
     Color Select register selects the green-red-yellow and cyan-violet-
     white palettes, and bit 4 toggles between normal- and high-intensity
     palettes, as they do on the CGA. Of course, you can establish
     completely arbitrary 4-color palettes by loading different color
     values into the video DAC color registers.


3D9H         Pixel Value    3D9H       Video DAC
Bit 4                       Bit 5      Color Register
(intensity)  Bit 1 Bit 0    (palette)  Number          Default Color
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 1           0     0         1         00H             Black

0            0     1        0          02H             Green
0            1     0        0          04H             Red
0            1     1        0          06H             Brown

1            0     1        0          0AH             High-intensity green
1            1     0        0          0CH             High-intensity red
1            1     1        0          0EH             High-intensity
                                                       yellow

0            0     1        1          03H             Cyan
0            1     0        1          05H             Violet
0            1     1        1          07H             White

1            0     1        1          0BH             High-intensity cyan
1            1     0        1          0DH             High-intensity
                                                       violet
1            1     1        1          0FH             High-intensity white
     Figure 4-13.  Pixel values and palettes in MCGA 320-by-200 4-color
     mode.


     256-Color Graphics Mode
     In 256-color mode, each pixel's value designates one of the 256 video
     DAC color registers. To select a video DAC color register, a pixel's
     value is combined (using a logical AND) with the value in the video
     DAC Mask register (3C6H). The resulting value selects a DAC color
     register (see Figure 4-6). Since you can store any of 256 K color
     values in each video DAC color register, you can display a wide range
     of tones and intensities and create quite realistic video images.


            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
      0-0FH ³ CGA-compatible  ³
            ³ default colors  ³
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     10-1FH ³                 ³
            ³   gray scale    ³
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ³   blue, red,    ³ High        ±
            ³     green       ³ saturation  ±
            ³-----------------³             ±
     20-67H ³   blue, red,    ³ Moderate    ± High intensity
            ³     green       ³ saturation  ±
            ³-----------------³             ±
            ³   blue, red,    ³ Low         ±
            ³     green       ³ saturation  ±
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
            ³   blue, red,    ³ High        ±
            ³     green       ³ saturation  ±
            ³-----------------³             ±
     68-AFH ³   blue, red,    ³ Moderate    ± Moderate intensity
            ³     green       ³ saturation  ±
            ³-----------------³             ±
            ³   blue, red,    ³ Low         ±
            ³     green       ³ saturation  ±
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³
            ³   blue, red,    ³ High        ±
            ³     green       ³ saturation  ±
            ³-----------------³             ±
     B0-F7H ³   blue, red,    ³ Moderate    ± Low intensity
            ³     green       ³ saturation  ±
            ³-----------------³             ±
            ³   blue, red,    ³ Low         ±
            ³     green       ³ saturation  ±
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     F8-FFH ³                 ³
            ³     black       ³
            ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 4-14.  Default video DAC colors in 320-by-200 256-color mode
     (MCGA and VGA).


     Normally, the video BIOS programs the video DAC registers with a
     default spectrum of color values (see Figure 4-14) when 320-by-200
     256-color mode is selected. Registers 0 through 0FH contain the
     default gamut of CGA-compatible colors. Registers 10H through 1FH
     contain a gray scale of gradually increasing intensity. The next 216
     registers (20H through F7H) contain three groups of 72 colors, with
     the first group (registers 20H through 67H) at high intensity, the
     second (registers 68H through AFH) at an intermediate intensity, and
     the third (registers B0H through F7H) at low intensity. Each 72-color
     group is made up of three ranges of colors of decreasing saturation
     (increasing whiteness); each range varies smoothly in hue from blue to
     red to green.

       ÉÍÍÍ»     To disable or enable default video BIOS programming of the
       º T º     video DAC color registers, use INT 10H function 12H (see
       º I º     Appendix A).
       º P º
       ÈÍÍÍ¼


VGA

     As on the EGA, VGA pixel values are decoded by the Attribute
     Controller, using the palette registers, and then passed to the video
     DAC, following the same logic as in alphanumeric modes (see Chapter
     3). Thus, a pixel value selects the corresponding palette register;
     the value in the palette register, along with the bit fields in the
     Attribute Controller's Color Select register, selects one of the 256
     video DAC color registers. The video DAC converts the 18-bit RGB value
     in its color registers to the corresponding analog RGB signals, which
     drive the monitor.

     The only exception to this scheme of attribute decoding occurs in 320-
     by-200 256-color mode. In this mode, as on the MCGA, each 8-bit pixel
     value specifies one of the video DAC's 256 color registers directly,
     without the Attribute Controller's mediation.



                        5  Pixel Programming


                        Bit-Plane Programming
                     EGA and VGA ş InColor Card

                       Reading a Pixel's Value
                      CGA ş HGC and HGC+ ş EGA
                      InColor Card ş MCGA ş VGA

                       Setting a Pixel's Value
                      CGA ş HGC and HGC+ ş EGA
                      InColor Card ş MCGA ş VGA

                      Filling the Video Buffer
                  CGA ş HGC and HGC+ ş EGA and VGA
                         InColor Card ş MCGA



     Many graphics programming techniques are based on routines that
     manipulate individual pixels in the video buffer. This chapter
     presents the fundamentals of pixel programming: reading a pixel's
     value, setting the value of a pixel in the video buffer, and
     initializing an area of the video buffer with a pattern of pixels.


Bit-Plane Programming


     There is a fundamental difference between graphics-mode programming
     using video subsystems whose video RAM is organized as parallel bit
     planes (the EGA, the VGA, and the InColor Card) and graphics-mode
     programming for the other IBM video subsystems. On the CGA, the MCGA,
     or the Hercules monochrome adapter, your program accesses pixels by
     directly reading and writing bytes in video RAM. In contrast, in

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     native graphics modes on the EGA, VGA, or InColor Card, your program
     cannot access video RAM directly. Instead, special hardware logic in
     the video subsystem mediates accesses to pixels in the bit planes.

     The graphics-mode bit planes on the EGA, VGA, and InColor Cards are
     addressed in parallel; that is, when you execute a CPU read or write
     at a particular address in the video buffer, the address refers not to
     one byte, but to four bytes, one in each of the bit planes.

     When you execute an 80x86 instruction that attempts to read data from
     an address in the video buffer, four bytes of data are actually moved
     out of the buffer. The data does not go directly to the CPU, however.
     Instead, it is copied into a set of four 8-bit latches. Each latch is
     assigned to one of the four bit planes. Executing an 8-bit CPU read
     from an address in the video buffer thus has the effect of
     transferring four bytes (32 bits) of data from the video buffer into
     the latches (see Figure 5-1a). Instructions such as MOV reg,mem,
     LODS, and CMP reg,mem require a CPU read, and thus cause the latches
     to be updated.

     Similarly, instructions such as MOV mem,reg, STOS, and XOR mem,reg
     cause a CPU write; in this case, all four bit planes can be updated in
     parallel using a combination of the data in the latches, the data byte
     that the CPU writes, and a predefined pixel value stored in a graphics
     control register (see Figure 5-1b).

     Some CPU instructions require both a CPU read and a CPU write. (The
     CPU reads a value from memory, performs an operation on it, and then
     writes the result back to memory.) MOVS is an obvious example, but
     OR mem,reg, AND mem,reg, and XOR mem,reg also generate a CPU read and
     write. When such an instruction refers to an address in video RAM, the
     latches are updated during the CPU read, and then the bit planes are
     updated during the CPU write.

     The use of latches to process bit-plane data in parallel lets you
     write deceptively simple code. For example, consider the following
     fragment, which copies the second byte of pixels in the video buffer
     to the first byte.


       ÚÄÄ¿
       ³  ³
       ³  ÃÄÄ¿
       ÀÄÄÙ  ³
             ³
       ÚÄÄ¿  ³    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÄÄ¿
       ³  ³  ÀÄÄ ³1  1  0  0  0  0  1  1 ³   ³
       ³  ÃÄÄ¿    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ³
       ÀÄÄÙ  ÀÄÄ ³0  1  0  1  0  0  1  0 ³   ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
bit               ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   Ã³x  x  x  x  x  x  x  x ³
planes ÚÄÄ¿  ÚÄÄ ³1  0  1  0  1  1  0  1 ³   ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       ³  ÃÄÄÙ    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ³    8-bit CPU register    
       ³  ³  ÚÄÄ ³1  0  1  1  0  1  1  0 ³   ³
       ÀÄÄÙ  ³    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÄÄÙ
             ³       four 8-bit latches
       ÚÄÄ¿  ³
       ³  ÃÄÄÙ
       ³  ³
       ÀÄÄÙ
     a.

    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                                  ÚÄÄ¿
    ³x  x  x  x  x  x  x  x ÃÄÄÄÄ¿                             ³  ³
    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    ³        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³  ³
       8-bit CPU register        ³        ³                    ÀÄÄÙ
                                 ³        ³
                                 ³        ³                    ÚÄÄ¿
                                 ³        ³                    ³  ³
                                 ³        ³   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³  ³
    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ³        ³   ³                ÀÄÄÙ
    ³1  1  0  0  0  0  1  1 ÃÄÄÄÄÄÄÄÄÄÄÄÙ   ³                      bit
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´    ³  ³         ³                ÚÄÄ¿  planes
    ³0  1  0  1  0  0  1  0 ÃÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÙ   ÚÄÄÄÄÄÄÄÄÄÄÄ³  ³
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´    ³  ³  ³          ³            ³  ³
    ³1  0  1  0  1  1  0  1 ÃÄÄÄÄÄÄÅÄÄÅÄÄÄÄÄÄÄÄÄÙ            ÀÄÄÙ
    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´    ³  ³  ³  ³
    ³1  0  1  1  0  1  1  0 ÃÄÄÄÄÄÄÅÄÄÅÄÄÅÄÄÄÄÄÄ¿            ÚÄÄ¿
    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ³  ³  ³  ³    ³            ³  ³
       four 8-bit latches           ³  ³  ³  ³    ÀÄÄÄÄÄÄÄÄÄÄÄ³  ³
                       ÚÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄ¿               ÀÄÄÙ
                       ³            x  x  x  x ³
                       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                            4-bit pixel data
                     (EGA, VGA: Set/Reset register)
     b.           (InColor: Read/Write Color register)

     Figure 5-1.  Graphics mode data flow on the EGA, the VGA, and the
     InColor Card during CPU (a.) read and (b.) write.


        mov     ax,VideoBufferSegment
        mov     ds,ax
        mov     es,ax
        mov     si,1     ; DS:SI -> second byte
        mov     di,0     ; ES:DI -> first byte
        movsb


     This code looks straightforward. The MOVSB instruction apparently
     copies one byte from the memory location at DS:SI to the location at
     ES:DI--but this is not really what takes place in graphics modes that
     use bit planes in the EGA, VGA, or InColor video buffer.

     What actually happens is this: The MOVSB instruction causes a CPU
     read, followed by a CPU write. Because the CPU read references an
     address in the video buffer, a byte from each bit plane at that
     address is loaded into the latches. Then, because the CPU write
     references an address in the video buffer, the contents of the latches
     are copied into the bit planes at the specified address. Thus, the
     MOVSB actually causes four bytes of data to be moved instead of one.

       ÉÍÍÍ»     There is more to this example than meets the eye. Consider
       º T º     what would happen if you substituted a MOVSW instruction
       º I º     for the MOVSB. Without bit planes and latches, this would
       º P º     result in two bytes of data being copied instead of one
       ÈÍÍÍ¼     byte. However, half of the pixel data would be lost on the
                 EGA, the VGA, or the InColor Card. The reason is that the
                 MOVSW executes as a sequence of two 8-bit CPU reads,
                 followed by two 8-bit CPU writes, so the second CPU read
                 updates the latches before the bytes latched by the first
                 CPU read can be written.

                 For this reason, you should use 16-bit 80x86 instructions
                 cautiously when accessing the video buffer on the EGA, the
                 VGA, and the InColor Card. Instructions such as
                 OR mem,reg, AND mem,reg, and XOR mem,reg do not work
                 properly with 16-bit data.

     The latches clearly improve efficiency in moving data to and from the
     video buffer, but the real fun begins in transferring data between the
     latches and the CPU. Since the latches contain 32 bits of data and a
     CPU byte register contains only eight bits, some sort of data
     compression must take place during CPU reads. Conversely, in
     transferring data from the CPU to the bit planes, you can combine the
     8-bit CPU data byte with the contents of all four latches in a number
     of ways. The key to graphics-mode programming on the EGA, the VGA, and
     the InColor Card is to exploit the data transformations involving the
     CPU and the latches.


EGA and VGA

     On the EGA and VGA, the Graphics Controller manages all transfers of
     data among the CPU, the latches, and the video buffer. The EGA's
     Graphics Controller consists of two LSI chips; the VGA's is part of
     the Video Graphics Array chip. The Graphics Controller has nine
     registers addressable at port 3CFH via an address register at port
     3CEH. The values you store in the registers control the way the
     Graphics Controller processes latched data during CPU reads and
     writes.

     In a sense, the Graphics Controller lets you manipulate the latched
     pixel data two-dimensionally. Some of the operations you can perform
     on the latched data are byte-oriented; they affect each latch
     separately. Other operations are pixel-oriented in that they regard
     the latched data as a set of eight pixel values; these operations
     affect each pixel value separately.

     The Graphics Controller can perform three different byte-oriented
     operations on latched data. It can copy the contents of the latches to
     and from the video buffer; this action occurs implicitly when a CPU
     write or read is executed. It can return the contents of one of the
     latches to a CPU register during a CPU read. It can also combine a
     data byte from a CPU register with the bytes in any or all of the
     latches during a single CPU write.

     The Graphics Controller also processes latched data pixel by pixel.
     During a CPU read, the Graphics Controller can compare each latched
     pixel value with a predefined value and return the result of the
     comparison to the CPU. During CPU writes, it can combine a 4-bit CPU
     value with any or all pixel values in the latches; it can use an 8-bit
     CPU value as a mask that indicates which of the eight latched pixels
     are copied back to the bit planes; and it can combine the latched
     pixel values with a predefined 4-bit value.

     Both byte-oriented and pixel-oriented operations are programmed by
     selecting a write mode and a read mode. Each write mode sets up a
     predefined sequence of byte-oriented and pixel-oriented operations
     which occur when a CPU write is executed. Similarly, each read mode
     defines a set of actions performed during CPU reads. The EGA has three
     write modes and two read modes; the VGA has these five modes and one
     additional write mode.

     Until you become familiar with each of the Graphics Controller's read
     and write modes, their raison d'etre may seem a bit obscure. However,
     each mode has practical advantages in certain programming situations,
     as the examples in this and subsequent chapters demonstrate.

     The Graphics Controller's Mode register (05H) contains two bit fields
     whose values specify the graphics read and write mode. For example, to
     establish read mode 1 you would set bit 3 of the Mode register to 1;
     to set up write mode 2, you would store the value 2 (10B) in bits 0
     and 1 of the Mode register (Listing 5-1).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-1.  How to set Graphics Controller read and write modes.
     This example sets read mode 0 and write mode 1 in in 640-by-350 16-
     color mode.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     The video BIOS default values for the Graphics
       º T º     Controller's Mode register and its other registers are
       º I º     listed in Figure 5-2. It is good practice to restore the
       º P º     Graphics Controller registers to their default values
       ÈÍÍÍ¼     after you modify them in your program.


Register    Function             Value
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           Set/Reset            0
1           Enable Set/Reset     0
2           Color Compare        0
3           Data Rotate          0
4           Read Map Select      0
5           Mode                 Bits 0-3 always 0
6           Miscellaneous        (depends on video mode)
7           Color Don't Care     0FH (16-color modes)
                                 01H (640-by-480 2-color mode)
8           Bit Mask             FFH
     Figure 5-2.  Default ROM BIOS values for EGA and VGA Graphics
     Controller registers.


     Read mode 0
     In graphics read mode 0, the Graphics Controller returns the contents
     of one of the four latches to the CPU each time a CPU read loads the
     latches (see Figure 5-3). The value in the Read Map Select register
     (04H) indicates which latch to read. Read mode 0 thus lets you read
     bytes from each individual bit plane; this is useful in transferring
     data between the bit planes and system RAM or a disk file.


                                               Read Map Select register
                                              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                              ³x  x  x  x  x  x  0  0 ³
                                              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                                                 ±±±±      
                                           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ³
       ÄÄÄÄÄÄ³1  1  0  0  0  0  1  1 ³3ÄÄÙ
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
       ÄÄÄÄÄÄ³0  1  0  1  0  0  1  0 ³2
bit           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
planes ÄÄÄÄÄÄ³1  0  1  0  1  1  0  1 ³1               CPU data
              ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       ÄÄÄÄÄÄ³1  0  1  1  0  1  1  0 ³0ÄÄÄÄÄ³1  0  1  1  0  1  1  0 ³
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 5-3.  EGA and VGA graphics read mode 0.


     Read Mode 1
     In graphics read mode 1, each of the eight pixel values latched during
     a CPU read is compared with the value in the Color Compare register
     (02H). The result of the comparison is returned to the CPU as a single
     byte (see Figure 5-4). Where a pixel value matches the Color Compare
     value, a bit in the CPU data byte is set to 1; where the values are
     different, the corresponding bit in the data byte is 0.

     Note how the value in the Color Don't Care register (07H) interacts
     with the pixel value and Color Compare value. In effect, setting a bit
     to 0 in the Color Don't  Care value excludes a latch from the
     comparison. For example, a Color Don't Care value of 0111B causes only
     the three low-order bits of each pixel value to participate in the
     comparison. Another example: If you store a 0 in the Color Don't Care
     register, all four bits in the comparison become "don't care" bits, so
     all pixel values match the Color Compare value, and the CPU always
     reads the value 11111111B in read mode 1.


                                                 Color Don't Care register
                                                 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
ÚÄbit planes                                     ³x  x  x  x  1  1  1  1 ³
³                            latches             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
³        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ±±±±±±±±±±
ÃÄÄÄÄÄ  ³  1     1    ±0±±   0     0    ±0±±   1     1  ³         ³
³        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ³
ÃÄÄÄÄÄ  ³  0     1    ±0±±   1     0    ±0±±   1     0  ³         ³
³        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ³
ÃÄÄÄÄÄ  ³  1     0    ±1±±   0     1    ±1±±   0     1  ³         ³
³        ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ³
ÀÄÄÄÄÄ  ³  1     0    ±1±±   1     0    ±1±±   1     0  ³         ³
         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ³
                                                           ³
pixel      1011  1100  0011  0101  0010  0011  1101  1010          ³
values      ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄÄÄÄÄÄÄÄ³
                                                           ³
AND with   1011  1100  0011  0101  0010  0011  1101  1010          
Color       ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
Don't                                                         ³
Care    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿            ³
        ³   0     0    ±1±±   0     0    ±1±±   0     0  ³            ³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ            ³
                           CPU data byte                       ±±±±±±±±±±
                                                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                                  ³x  x  x  x ±0±±0±±1±±1±³
                                                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                                   Color Compare register

     Figure 5-4.  EGA and VGA graphics read mode 1.


     Write mode 0
     Graphics write mode 0 sets up a combination of byte-oriented and
     pixel-oriented operations that occur when a CPU write is executed. The
     data byte written by the CPU can be used to update any or all of the
     bit planes; at the same time, a predefined pixel value can be used to
     update any or all of the eight pixels involved. This two-dimensional
     update of the latches is controlled in several different ways using
     the values in the Enable Set/Reset, Data Rotate/Function Select, and
     Bit Mask registers (see Figure 5-5).

     The Bit Mask register (08H) specifies how the new value of each of the
     eight pixels in the video buffer is derived. Where a bit in the Bit
     Mask register equals 0, the corresponding pixel value is copied
     directly from the latches into the video buffer. For each 1 bit in the
     Bit Mask value, the corresponding pixel is updated with the latched
     pixel value combined with either the CPU data or the pixel value in
     the Set/Reset register. Thus, if a CPU write immediately follows a CPU
     read at the same address, the only pixels updated are those for which
     the corresponding bit in the Bit Mask register is set to 1.


             Data Rotate/Function Select register
                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                  ³x  x  x  0  0  x  x  x ³
                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
      replace, AND. OR, XOR ±±±±           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿     
                             ³          ÚÄ³1  1  0  0 ±0±±0±±0±±0±³±
        latches              ³       ÚÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±±±±±±±±±±±³  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ±
³1  1  0  0  0  0  1  1 ÃÄÄÄÄÄÄÄÄÄÄÄÄÙÚ³0  1  0  1 ±1±±1±±1±±1±³   ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ÚÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ±bit
³0  1  0  1  0  0  1  0 ÃÅÄÄÄÄÄÄÄÄÄÙ  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿     ±planes
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³        ÚÄ³1  0  1  0 ±1±±1±±1±±1±³     ±
³1  0  1  0  1  1  0  1 ÃÅÄÄÅÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´³  ³      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿       ±
³1  0  1  1  0  1  1  0 ÃÅÄÄÅÄÄÅÄÄÄ³1  0  1  1 ±1±±1±±1±±1±³       ±
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ³  ³  ³   ÀÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
                       ÚÄÙÚÄÙÚÄÙÚÄÙ  |  |  |  |  |  |  |  |
Set/Reset ÚÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄ¿ ÚÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄ¿
register  ³x  x  x  x ±0±±1±±1±±1±³ ³0  0  0  0  1  1  1  1 ³
          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           |  |  |  |  |  |  |  |      Bit Mask register
Enable     |  |  |  |  |  |  |  |      (Pixels 0-3 are derived from
Set/Reset ÚÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄ¿    Set/Reset; pixels 4-7 are
register  ³x  x  x  x  1  1  1  1 ³    copied from latches.)
          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
a.

                                           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                        ÚÄ³1  1  0  0 ±0±±1±±1±±1±³±
        latches                      ÚÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿            ³  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ±
³1  1  0  0  0  0  1  1 ÃÄÄÄÄÄÂÄÄÄÄÄÄÙÚ³0  1  0  1 ±0±±1±±1±±1±³   ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ÚÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ±bit
³0  1  0  1  0  0  1  0 ÃÄÄÄÄÄÅÄÄÄÄÙÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿       ±planes
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ÚÄ³1  0  1  0 ±0±±1±±1±±1±³       ±
³1  0  1  0  1  1  0  1 ÃÄÄÄÄÄÅÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´         ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿        ±
³1  0  1  1  0  1  1  0 ÃÄÄÄÄÄÅÄÄÄ³1  0  1  1 ±0±±1±±1±±1±³        ±
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ÀÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
        replace, AND, OR, XOR ³     |  |  |  |  |  |  |  |
           Ú Ä Ä Ä Ä Ä Ä Ä Ä Ä³    ÚÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄ¿
           |                  ³    ³0  0  0  0  1  1  1  1 ³
           ³              00010111 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
           |         Rotate        Bit Mask register (Pixels 0-3
           ³       Ú Ä Ä Ä Ä Ä³     are derived from CPU data; pixels
           |       |          ³     4-7 are copied from latches.)
          ±±±±  ±±±±±±±       ³
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³x  x  x  0  0  0  0  0 ³ ³0  0  0  1 ±0±±1±±1±±1±³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  Data Rotate/Function          CPU data byte
     Select register 
b.

     Figure 5-5.  EGA and VGA graphics write mode 0: (a.) Enable Set/Reset
     Value = 1111B, (b.) Enable Set/Reset value = 0000B.


     The Data Rotate/Function Select register (03H) contains two bit fields
     whose contents affect the way the latched pixels are updated. Bits 3
     through 4 are important because their value specifies which bitwise
     logical operation (AND, OR, XOR, or replace) is used to update the
     pixels (see Figure 5-6). Bits 0 through 2 specify the number of bits
     by which to right-rotate the CPU data byte before combining it with
     latched data.


    Bit Value            Function
Bit 4       Bit 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
0           0            Replace
0           1            AND
1           0            OR
1           1            XOR
     Figure 5-6.  Functions available for updating pixels in EGA and VGA
     write modes 0, 2, and 3. Bits 3 and 4 of the Data Rotate/Function
     Select register specify which is used.


       ÉÍÍÍ»     This data-rotate capability is not particularly useful. In
       º T º     practice, it is generally easier to let the CPU rotate and
       º I º     shift data before writing it to the bit planes than it is
       º P º     to program the Graphics Controller to do this.
       ÈÍÍÍ¼

     The value in the Enable Set/Reset register (register 01H) determines
     whether the bit planes are updated byte by byte or pixel by pixel.
     When the Enable Set/Reset value is 0FH (1111B), each pixel is updated
     by combining the latched pixel value with the value in the Set/Reset
     register (register 00H) using the logical operation that the Data
     Rotate/Function Select register specifies (refer to Figure 5-5a).
     When the Enable Set/Reset value is 0, the rotated CPU data byte is
     combined with the bytes in each of the latches, again using the
     function that the Data Rotate/Function Select register specifies (see
     Figure 5-5b). In either case, only the pixels masked by the Bit
     Mask register are updated.

       ÉÍÍÍ»     Of course, you can set the Enable Set/Reset register to
       º T º     any value from 0 through 0FH. Each bit in each pixel is
       º I º     then updated by combining it either with the corresponding
       º P º     bit in the Set/Reset register or with the corresponding
       ÈÍÍÍ¼     bit in the CPU data byte--depending on the value of the
                 corresponding bit in the Enable Set/Reset register.
                 Needless to say, this kind of programming is tricky and
                 infrequently used.


     Write mode 1
     In write mode 1, the latches are copied directly to the bit planes
     when a CPU write occurs (see Figure 5-7). Neither the value of the
     CPU data byte nor those of the Data Rotate/Function Select, the Bit
     Mask, the Set/Reset, and the Enable Set/Reset registers affect this
     process. Clearly, for a write mode 1 operation to make sense, you must
     first perform a CPU read to initialize the latches.


             latches
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³x  x  x  x  x  x  x  x ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ
     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³x  x  x  x  x  x  x  x ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ
     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´               bit planes
     ³x  x  x  x  x  x  x  x ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ
     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
     ³x  x  x  x  x  x  x  x ÃÄÄÄÄÄÄÄÄÄÄÄÄÄ
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 5-7.  EGA and VGA graphics write mode 1.


     Write mode 2
     In write mode 2, the low-order bits of the byte written by the CPU
     play the same role as the Set/Reset register value in write mode 0.
     That is, the bit planes are updated by combining the pixel values in
     the latches with the CPU data, using the logical operation specified
     in the Data Rotate/Function Select register (see Figure 5-8). As in
     write mode 0, the Bit Mask register specifies which pixels are updated
     using the combined pixel values and which pixels are updated directly
     from the latches.


             Data Rotate/Function Select register
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³x  x  x  0  0  x  x  x ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                             ±±±±
        replace, AND, OR, XOR ³            ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              ³   ÚÄÄÄÄÄÄÄ³1  1  0  0 ±0±±0±±0±±0±³±
         latches                 ³        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿±±±±±±±±±³      ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ±
³1  1  0  0  0  0  1  1 ÃÄÄÄÄÄÄÄÄÄÙ ÚÄÄÄ³0  1  0  1 ±1±±1±±1±±1±³  ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´          ³    ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ±
³0  1  0  1  0  0  1  0 ÃÄÅÄÄÄÄÄÄÄÄÄÙ  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ±bit
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³        ÚÄ³1  0  1  0 ±1±±1±±1±±1±³    ±planes
³1  0  1  0  1  1  0  1 ÃÄÅÄÄÅÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³  ³        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ±
³1  0  1  1  0  1  1  0 ÃÄÅÄÄÅÄÄÅÄÄÄÄÄ³1  0  1  1 ±1±±1±±1±±1±³    ±
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³  ³  ³     ÀÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
                          ³  ³  ³  ³    |  |  |  |  |  |  |  |
             ÚÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄ¿ ÚÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄ¿
             ³x  x  x  x ±0±±1±±1±±1±³ ³0  0  0  0  1  1  1  1 ³
             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                     CPU data              Bit Mask register

     Figure 5-8.  EGA and VGA graphics write mode 2.


     Write mode 3
     In write mode 3 (supported on the VGA only), the pixels are updated by
     combining the pixel values in the latches with the value in the
     Set/Reset register. Again, the Data Rotate/Function Select register
     specifies the logical operation used to combine the values. The CPU
     data byte is rotated by the number of bits indicated in the Data
     Rotate/Function Select register and combined with the value in the Bit
     Mask register using a logical AND. The resulting bit mask then plays
     the same role as the Bit Mask register value in write modes 0 and 2;
     that is, it determines which pixels in the bit planes are updated by
     combining the latched pixel values with the Set/Reset value, and which
     are updated directly from the latches (see Figure 5-9).


       Enable ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
    Set/Reset ³x  x  x  x  1  1  1  1 ³
     register ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
                           |  |  |  |
              ÚÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄ¿
    Set/Reset ³x  x  x  x ±0±±1±±1±±1±³
     register ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÂÄÄÂÄÄÂÄÙ       ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  
                           ³  ³  ³  ³ ÚÄÄÄÄÄÄ³1  1  0  0 ±0±±0±±0±±0±³  ±
         latches           ³  ³  ³  ³ ³       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ±
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ³  ³  ³ ³    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿     ±
³1  1  0  0  0  0  1  1 ÃÄÄÄÄÄÅÄÄÅÄÄÅÄÙÚÄÄ³0  1  0  1 ±1±±1±±1±±1±³     ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´       ³  ³  ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ     ±
³0  1  0  1  0  0  1  0 ÃÄÄÄÄÄÄÄÄÅÄÄÅÄÄÙ  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   bit±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´          ³  ÚÄ³1  0  1  0 ±1±±1±±1±±1±³planes±
³1  0  1  0  1  1  0  1 ÃÄÄÄÄÄÄÄÄÄÄÄÅÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ      ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´               ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿       ±
³1  0  1  1  0  1  1  0 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³1  0  1  1 ±1±±1±±1±±1±³       ±
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ±±±±±±±±±±±±±±± ÀÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
                               ³          |  |  |  |  |  |  |  |
                               ³          0  0  0  0  1  1  1  1
                               ³                               
                               ³             ÚÄÄÄÄÄÄÄÁÄÄÄÄÄ¿    
                    ÚÄÄÄÄÄÄÄÄÄÄÙ             ³ Logical AND ³    
                    ³                        ³   ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
       replace, AND,³                   00001111 ³1  1  1  1  1  1  1  1 ³
       OR, XOR      ³           Rotate       ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                    ³       Ú Ä Ä Ä Ä Ä Ä Ä Ä|       Bit Mask register
                    ³       |                ³              
                  ±±±±  ±±±±±±±              |              
        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ÚÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
        ³x  x  x  0  0  0  1  0 ³  ³0  0  1  1  1  1  0  0 ³
        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
       Data Rotate/Function Select        CPU data
                 register

     Figure 5-9.  VGA graphics write mode 3.


     Sequencer Map Mask
     One additional level of control is available in all of the EGA's and
     the VGA's Graphics Controller write modes. You can use the Sequencer
     Map Mask register (Sequencer register 02H) to selectively enable or
     disable data transfers to the bit planes. In 16-color graphics modes,
     bits 0 through 3 of this register are normally set to 1 to allow
     graphics writes to access all four maps. However, by zeroing one or
     more of these bits, you can write-protect the corresponding memory
     maps.

     The Sequencer Map Mask register is not often used, because the
     Graphics Controller provides better control for pixel-oriented
     operations. Use of this register is better suited to techniques such
     as bit-plane layering (see Chapter 12).


InColor Card

     The InColor Card has two gate arrays, the Encoder and the Decoder,
     which mediate CPU accesses to video RAM. The Encoder gate array
     participates in CPU writes to video RAM. The Decoder gate array
     manages the transfer of data from video RAM to the CPU, as well as to
     the card's attribute-decoding circuitry.

     The programming interface to the InColor Card's graphics-mode
     hardware, including the Encoder and Decoder chips, is unified through
     the card's control register set at I/O ports 3B4H and 3B5H (see Figure
     5-10). There is no distinction between the Encoder, the Decoder, and
     their associated circuitry from a software point of view. The InColor
     Card's graphics-mode control registers are similar to control
     registers on the EGA and the VGA (see Figure 5-11).


Register Number    Register Function                  Read/Write Status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
18H                Plane Mask register                Write only
19H                Read/Write Control register        Write only
1AH                Read/Write Color register          Write only
1BH                Latch Protect register             Write only
     Figure 5-10.  Graphics control registers on the Hercules InColor Card.


InColor                       EGA and VGA
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Plane Mask register           Sequencer Map Mask register
                              Attribute Controller Color Plane
                              Enable register

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
Read/Write Control register   Graphics Controller Mode register
                              Graphics Controller Color Don't Care
                              register
Read/Write Color register     Graphics Controller Set/Reset register
Palette register              Attribute Controller Palette registers
     Figure 5-11.  Functionally similar control registers on the EGA, VGA,
     and InColor Card.


     As on the EGA and VGA, video RAM accesses in graphics mode are
     performed using a set of four 8-bit latches. CPU reads and writes
     cause bytes to be transferred in parallel between the latches and the
     corresponding bit planes. When a CPU read is executed, the Decoder
     latches a byte from each bit plane and returns a single byte of data
     to the CPU. When a CPU write is executed, the Encoder combines the
     latched data with the pixel values stored in the Read/Write Color
     register and updates the bit planes with the result.

     Like the EGA and VGA, the InColor Card can process CPU data and
     latched data in several ways. The card supports four graphics write
     modes (see Figure 5-12), selected by bits 4 and 5 of the Read/Write
     Control register (19H). There is only one graphics read mode, which
     is similar to read mode 1 on the EGA and VGA.


Write Mode   CPU Data Bit = 0    CPU Data Bit = 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0            Background value    Foreground value
1            Latch               Foreground value
2            Background value    Latch
3            NOT latch           Latch
     Figure 5-12.  Source of pixel data in InColor graphics write modes.


     Write modes 0-3
     In all four InColor graphics write modes, the CPU data functions as an
     8-bit mask. The Encoder uses the value of each bit in the mask to
     determine how to update the corresponding pixel value in the latches.
     That is, the source of the pixel value at a particular bit position is
     determined by the value of the corresponding bit in the CPU data byte.

     For example, in graphics write mode 1, when a bit in the CPU data byte
     is 1, the corresponding pixel in the video buffer is replaced with the
     foreground value in the Read/Write Control register; when a bit in the
     CPU data byte is 0, the corresponding pixel value is copied from the
     latches. For example, in Figure 5-13, the pixels corresponding to
     bits 0 through 3 are replaced with the Read/Write Control register
     foreground value, while the remaining pixels are updated from the
     pixel values in the latches.

     Similarly, in the other three graphics write modes, the value of each
     bit in the CPU data byte controls how the corresponding pixel is
     updated. The write modes differ only in how the pixel values are
     derived (see Figure 5-12). In write mode 0, either the foreground or
     the background value in the Read/Write Control register replaces the
     pixels in the bit planes. In write mode 2, for each 0 bit in the CPU
     data byte, the Read/Write Control register background value is used to
     update the corresponding pixel in the bit planes. In write mode 3,
     each 0 bit in the CPU data byte causes the corresponding pixel in the
     video buffer to be replaced with the bitwise NOT of the pixel value in
     the latches.


                             Plane Mask register
                          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                          ³0  0  0  0  x  x  x  x ³
                          ÀÂÄÄÂÄÄÂÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                           |  |  |  |        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                           |  |  |  | ÉÍÍÍÍÍ³1  1  0  0 ±0±±0±±0±±0±³  ±
         latches           |  |  |  | º      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ±
ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  |  |  |  | º    ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿    ±
³1  1  0  0  0  0  1  1 ÃÄÕÏÍÍ|ÍÍ|ÍÍ|Í¼ÉÍÍ³0  1  0  1 ±1±±1±±1±±1±³    ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³   |  |  |  º   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ    ±
³0  1  0  1  0  0  1  0 ÃÄÅÄÄÕÏÍÍ|ÍÍ|ÍÍ¼ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   bit±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³  ³   |  | ÉÍ³1  0  1  0 ±1±±1±±1±±1±³planes±
³1  0  1  0  1  1  0  1 ÃÄÅÄÄÅÄÄÕÏÍÍ|Í¼  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ      ±
ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ ³  ³  ³   |  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿        ±
³1  0  1  1  0  1  1  0 ÃÄÅÄÄÅÄÄÅÄÄÕÏÍ³1  0  1  1 ±1±±1±±1±±1±³        ±
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³  ³  ³  ³   ÀÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÙ
                          ³  ³  ³  ³    |  |  |  |  |  |  |  |
             ÚÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÁÄÄÁÄÄÁÄ¿ ÚÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄ¿
             ³x  x  x  x ±0±±1±±1±±1±³ ³0  0  0  0  1  1  1  1 ³
             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                 Read/Write Color              CPU data 
                     register       (Pixels 0-3 copied from foreground
                                    value in R/W Color register; pixels
                                        4-7 copied from latches.)

     Figure 5-13.  InColor graphics write mode 1.


     CPU writes affect only those bit planes specified in the Plane Mask
     register (18H). This register's function is thus analogous to that of
     the EGA's Sequencer Map Mask register. Bits 4 through 7 of this
     register control which of the four bit planes are writable; setting
     any of these bits to 1 prevents updating of the corresponding bit
     planes during CPU writes.


     Read mode
     The InColor Card has only one graphics read mode (see Figure 5-14). It
     resembles read mode 1 on the EGA and the VGA. When a CPU read is
     executed, the latches are loaded with data from the bit planes. Unlike
     the EGA and the VGA, however, the InColor Card lets you control which
     individual pixel values are latched during a CPU read. The bit mask
     value in the Latch Protect register (1BH) indicates which pixel values
     are latched. Where a bit in the Latch Protect register is 0, the
     corresponding pixel value is latched; where a bit is 1, the
     corresponding pixel value in the latch remains unchanged.


           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ Latch

           ³  0     0     0     0     0     0     0     0   ³ Protect

           ÀÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÙ register

              |     |     |     |     |     |     |     |   

           ÚÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄ¿

      ÄÄÄÄ³  1     1    ±0±±   0     0    ±0±±   1     1  ³

           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

bit   ÄÄÄÄ³  0     1    ±0±±   1     0    ±0±±   1     0  ³

planes     ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

      ÄÄÄÄ³  1     0    ±1±±   0     1    ±1±±   0     1  ³

           ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´

      ÄÄÄÄ³  1     0    ±1±±   1     0    ±1±±   1     0  ³ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿Read/Write Control

           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ³ x  0  x  x  0  0  0  0³register

pixel                                                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ 

values       1011  1100  0011  0101  0010  0011  1101  1010    ±±±±        ±±±±±±±±±± 

              ³     ³     ³     ³     ³     ³     ³     ³       ³  ÚÄÄÄÄÄÄÄÄÄÄÄÄÙ      Read/Write Color

OR with Don't ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄÄÄÄÄÄ´ ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿register

Care value                                              ³  ³ ³±0±±0±±1±±1± x  x  x  x³

             1011  1100  0011  0101  0010  0011  1101  1010     ³  ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

COMPARE with  ³     ³     ³     ³     ³     ³     ³     ³       ³     ±±±±±±±±±±

(background   ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³ÄÄÄÄ³Ä Ä Ä Ä Ä Ä Ä Ä Ä Ù

value OR      ³     ³     ³     ³     ³     ³     ³     ³       ³ 

Don't Care                                              ³ 

value.)       0     0     1     0     0     1     0     0       ³

              ³     ³     ³     ³     ³     ³     ³     ³       ³

XOR with Mask ³     ³     ³     ³     ³     ³     ³     ³       ³

Polarity bit  ³ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄ´ÄÄÄÄÄÄÙ

              ³     ³     ³     ³     ³     ³     ³     ³

                                                 

CPU        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  

data       ³  1     1    ±0±±    1     1    ±0±±  1     1  ³  

           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  

     Figure 5-14.  InColor graphics read.


     After the specified pixel values in the latches have been updated from
     the bit planes, the Decoder compares each pixel value in the latches
     with the background value in the Read/Write Color register. The 8-bit
     result of the comparison is returned to the CPU. This is similar to
     read mode 1 on the EGA and the VGA.

     Bits 0 through 3 of the Read/Write Control register are "don't care"
     bits analogous to the Color Don't Care value on the EGA and the VGA.
     Setting a Read/Write Control "don't care" bit to 1 has the effect of
     excluding a latch from the background value compare operation. If you
     set all four "don't care" bits to 1, all pixel values match the
     background value no matter what it is.

     The polarity of the bits in the result returned to the CPU depends
     upon the value of the Mask Polarity bit (bit 6 of the Read/Write
     Control register). When this bit  is 0, bits in the result are 1 where
     a pixel value in the latches matches the background value. Setting the
     Mask Polarity bit to 1 inverts the result; that is, bits are 1 where a
     pixel value in the latches does not match the background value.


Reading a Pixel's Value


     Now it is time to turn to some specific programming techniques for
     manipulating pixels on the various PC and PS/2 video subsystems. Once
     you calculate the byte and bit offsets of a particular pixel in the
     video buffer, determining the pixel's value is a matter of isolating
     the bits that represent it in the buffer. This is as true on the CGA
     and HGC, with their simpler video RAM architecture, as it is on more
     complicated video subsystems that use bit planes.


CGA

     In 640-by-200 2-color mode, the value of a pixel is determined simply
     by reading the byte that contains the pixel from the video buffer and
     testing the value of the bit that represents the pixel (see Listing
     5-2).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-2.  Determining a pixel value in CGA 640-by-200 2-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     The technique for determining the value of a pixel in 320-by-200 
     4-color graphics mode, as shown in Listing 5-3, is similar. After
     isolating the bits that represent the pixel, however, your program
     must shift them rightward so that the value returned represents the
     actual pixel value.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-3.  Determining a pixel value in CGA 320-by-200 4-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC and HGC+

     The only difference between the pixel-read routines for the Hercules
     mono- chrome adapters and the ones used in the CGA's 640-by-200 2-
     color mode lies in how the pixel's address is computed. For example,
     you can adapt the CGA routine shown in Listing 5-2 for the HGC simply
     by substituting PixelAddrHGC for PixelAddr06.


EGA

     In CGA-emulation modes, the routines used for the CGA work unchanged.
     However, in 16-color 200-line modes and in 350-line modes, you must
     program the Graphics Controller to isolate the bits that represent a
     pixel in the video buffer's bit planes, as the routine in Listing 5-4
     does.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-4.  Determining a pixel value in native EGA graphics
     modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     This routine uses the Graphics Controller's read mode 0 to read a
     single byte from each of the EGA's planes. As the bytes are read, the
     desired pixel's bits are masked and concatenated to form the pixel's
     value.

       ÉÍÍÍ»     In 640-by-350 monochrome graphics mode, only bit planes 0
       º T º     and 2 are used to represent pixel values. In these modes,
       º I º     only bits from these two planes are concatenated to form a
       º P º     pixel value (see Listing 5-5).
       ÈÍÍÍ¼

                 As described in Chapter 4, 640-by-350 graphics modes are
                 mapped differently on an EGA with only 64 KB of video RAM
                 than on an EGA with more memory. Memory maps 0 through 1
                 and 2 through 3 are chained to form two bit planes. Pixels
                 at even byte addresses are represented in maps 0 and 2,
                 while pixels at odd byte addresses are represented in maps
                 1 and 3. A routine to read pixel values in these modes
                 must use the pixel's byte address to determine which maps
                 to read (see Listing 5-6).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-5.  Determining a pixel value in EGA monochrome graphics
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-6.  Determining a pixel value in 640-by-350 modes on an EGA 
     with 64 KB.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


InColor Card

     As with the EGA, to read a pixel's value on the InColor Card requires
     reading each bit plane separately. To do this, you must use the "don't
     care" bits in the Read/Write Control register along with the
     background value in the Read/Write Color register to isolate the
     contents of each latch.

     The routine in Listing 5-7 accumulates a pixel's 4-bit value by
     concatenating one bit from each of the InColor card's four bit planes.
     The routine determines the contents of each of the bit planes by
     setting the background value in the Read/Write Color register to 0FH
     (1111B) and by individually zeroing each Read/Write Control register
     "don't care" bit. When each CPU read is executed (with the
     AND CH,ES:[SI] instruction), the value returned to the CPU is thus
     the 8-bit value in one of the four latches. This value is ANDed with
     the bit mask in CH, and the isolated bits are accumulated in BL.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-7.  Determining a pixel value in InColor graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     As usual in bit-plane programming, the tricky part of this
       º T º     process is in setting up the control register values to
       º I º     produce the desired result. For example, here is what
       º P º     happens when the AND CH,ES:[SI] instruction executes:
       ÈÍÍÍ¼

                 1. One byte from each bit plane is copied into the
                    latches.

                 2. Each of the eight pixels in the latches is compared
                    with the background value (1111B), and the eight bits
                    that reflect the result of the eight comparisons are
                    returned to the CPU. Because only one of the four
                    "don't care" bits in the Read/Write Control register
                    is 0, only one of the four bits in each pixel value
                    participates in each comparison. If this bit is 1, the
                    comparison is true, and the Decoder returns a 1 in the
                    bit position corresponding to this pixel value.

                 3. The eight bits returned to the CPU are ANDed with the
                    bit mask in CH to give the desired result.

                 That's a lot of action for a single AND instruction.


MCGA

     In 640-by-200 2-color and 320-by-200 4-color modes, the routines
     written for the CGA (shown in Listings 5-2 and 5-3) also work on the
     MCGA. The two other MCGA graphics modes pose no additional problems
     (see Listings 5-8 and 5-9), because they use no buffer interleave as
     do CGA-compatible modes, and because there are no bit planes to worry
     about.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-8.  Determining a pixel value in MCGA and VGA 640-by-480
     2-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-9.  Determining a pixel value in MCGA and VGA 320-by-200 
     256-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


VGA

     Once you write pixel-read routines for the CGA, the EGA, and the MCGA,
     you have covered all the bases as far as the VGA is concerned. The
     only VGA graphics mode not available on the other subsystems is 640-
     by-480 16-color mode. However, pixel representation and addressing are
     the same in this mode as in the EGA's 640-by-350 16-color mode, so you
     can use the routine in Listing 5-4 for both.


Setting a Pixel's Value


     In some ways, setting a pixel's value is the converse of determining
     its value. Once the byte and bit offsets of a particular pixel have
     been calculated, setting its value is a simple matter of putting the
     right bits in the right places in the video buffer.

     What complicates pixel-setting routines is that you may not always
     wish simply to replace a pixel's old value with a new value. It is
     sometimes desirable to derive a pixel's new value by performing a
     bitwise logical operation on its old value. This is why the EGA and
     the VGA Graphics Controllers directly support logical AND, OR, and XOR
     operations on pixel values, as well as direct replacement of old
     values with new ones.

       ÉÍÍÍ»     Since the bulk of the overhead in a pixel-setting routine 
       º T º     is in calculating the pixel's location in the video
       º I º     buffer, you can keep your code small and modular by
       º P º     integrating different pixel-value manipulations into a
       ÈÍÍÍ¼     single routine rather than writing separate routines to
                 replace pixels and to perform bitwise logical operations
                 on them. The examples in this chapter combine these
                 different pixel-value operations into unified routines.

                 Where each bitwise operation requires a different
                 subroutine, the subroutine's address is stored in a
                 variable (SetPixelOp). This technique is more flexible
                 than coding a jump to the desired pixel operation
                 (replace, AND, OR, or XOR), because you can change the
                 address in the variable with another independent
                 subroutine.

                 The examples in this chapter do not include code for

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                 updating a pixel's value by performing a bitwise NOT
                 operation. You can use the XOR operation to obtain the
                 same result as NOT without decreasing performance and
                 without writing additional code.


CGA

     To set a pixel in 640-by-200 2-color mode, mask the appropriate bit in
     a byte in the video buffer and then set the bit's value. The routine
     in Listing 5-10 implements four different ways of setting the value--
     by replacing the old pixel value with a new value and by using the
     logical operations OR, AND, and XOR.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-10.  Setting a pixel value in CGA and 640-by-200 2-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routine for 320-by-200 4-color mode is similar. This routine,
     shown in  Listing 5-11, differs from the routine for 640-by-200
     2-color mode (see Listing 5-10) only in its technique for computing
     pixel addresses and in its representation of pixels in bit fields that
     are two bits wide.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-11.  Setting a pixel value in CGA 320-by-200 2-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC and HGC+

     As you might expect, a routine for writing a pixel in the HGC's 720-
     by-348 monochrome graphics mode can be derived from the equivalent
     routine for the CGA's 640-by-200 2-color mode in Listing 5-10 by
     substituting the HGC's pixel-address computation routine
     (PixelAddrHGC) for the CGA's.


EGA

     You don't need to worry about CGA-emulation modes (640-by-200 2-color
     and 320-by-200 4-color), because the routines that work on the CGA
     work equally well on the EGA. However, things become considerably more
     complicated in the EGA's native graphics modes. In these modes, there
     are several different ways you can program the Graphics Controller to
     set the value of an individual pixel. Also, the pixel-setting routine
     must properly handle the video memory maps in monochrome and 640-by-
     350 4-color graphics modes (on an EGA with 64 KB).


     Write mode 0
     The method for setting a pixel's value in write mode 0 is shown in
     Listing 5-12. First, as usual, you calculate the byte offset and bit
     mask, which identify the pixel's location in the video buffer. Then
     you program the Graphics Controller: Set up write mode 0, store the
     bit mask value in the Bit Mask register, and configure the Set/Reset
     and Enable Set/Reset registers for the pixel value. Then you can
     perform a CPU read to latch the bit planes, followed by a CPU write to
     copy the contents of the latches and the new pixel value into the bit
     planes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-12.  Setting a pixel value in native EGA graphics modes
     using write mode 0.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Note how the contents of the Graphics Controller registers determine
     how the bit planes are updated during the CPU write in the OR
     instruction. The value in the Bit Mask register has only one nonzero
     bit, so only one pixel is updated. This pixel takes its value from the
     Set/Reset register. (The other seven pixels are updated from the
     latches; since the CPU read loaded the latches with these same pixels,
     the CPU write doesn't change them.) The Enable Set/Reset value is
     1111B, so the CPU data byte in AL plays no part in the operation.

       ÉÍÍÍ»     IBM's EGA BIOS uses write mode 0 to set the values of
       º T º     individual pixels in INT 10H function 0CH, but the BIOS
       º I º     routine does not use the Set/Reset register to specify the
       º P º     pixel value. Instead, it first zeroes the pixel by using
       ÈÍÍÍ¼     the Bit Mask register to isolate it and by writing a CPU
                 data byte of 0. Then the BIOS programs the Sequencer Map
                 Mask register to select only those bit planes in which the
                 desired pixel value contains a nonzero bit. The routine
                 then performs a second CPU write to set the nonzero bits,
                 as shown in Listing 5-13.

                 This technique has two weaknesses: There are easier ways
                 to do the same job, and the routine requires extra coding
                 if you want to AND, OR, or XOR the pixel value in the
                 video buffer. For both reasons, video BIOS INT 10H
                 function 0CH is limited in both speed and flexibility.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-13.  Setting a pixel value in native EGA graphics modes
     using the Sequencer Map Mask.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Write mode 2
     A somewhat simpler way to set the value of an individual pixel is to
     use write mode 2. The routine in Listing 5-14 demonstrates this
     technique. As in write mode 0, the Bit Mask register determines how
     each of the eight pixels is updated. In write mode 2, however, new
     pixel values are derived by combining the CPU data byte with the
     latched pixel values; this avoids the need to program the Set/Reset
     and Enable Set/Reset registers and leads to shorter, faster code.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-14.  Setting a pixel value in native EGA graphics modes
     using write mode 2.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routines in Listings 5-12 and 5-14 are designed to work correctly
     when the Function Select register specifies the AND, OR, or XOR
     function. Thus, you need write no extra code to perform these
     alternative pixel manipulations in the EGA's native graphics modes.

     Furthermore, if you are careful to use the proper pixel values, the
     routines in Listings 5-12 and 5-14 can be used in any native EGA
     graphics mode. To ensure that the appropriate bits in the memory maps
     are updated in 640-by-350 monochrome mode, use pixel values of 0, 1,
     4, and 5 only. On an EGA with 64 KB of RAM, use pixel values 0, 3,
     0CH, and 0FH.


InColor Card

     The routine in Listing 5-15 updates a single pixel in the InColor
     Card's 720-by-348 16-color mode. The InColor Card lacks a functional
     equivalent of the EGA's Function Select register, so this routine
     contains four separate subroutines which perform AND, OR, or XOR
     operations on pixel values.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-15.  Setting a pixel value in InColor graphics
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Each one of these subroutines begins by programming the Read/Write
     Control, Read/Write Color, and Plane Mask registers. Then a CPU read
     loads the latches, and a subsequent CPU write updates the bit planes.

     Each subroutine starts by programming the Read/Write Control register
     for one of the four graphics write modes. At the same time, the "don't
     care" bits are all set to 1 and the Mask Polarity bit is zeroed so
     that the Decoder always returns 11111111B as the result of a CPU read.
     Then the Plane Mask and Read/Write Color foreground values are set up;
     these values depend upon whether the pixel value is to be replaced or
     manipulated by an AND, OR, or XOR operation.

     The instruction AND ES:[BX],CH (or XOR ES:[BX],CH for the pixel XOR
     operation) causes the CPU read and write. During the CPU read, the
     latches are loaded and the value 11111111B is returned to the CPU; the
     CPU ANDs (or XORs) this value with the bit mask in CH and writes the
     result back to the same address in the video buffer. In this way, the
     bit mask in CH selects which pixel value is updated during the CPU
     write.

     Except for the pixel that the bit mask specifies, the contents of the
     latches are copied back into the bit planes from which they were just
     read; the value of the pixel being updated derives from the foreground
     value in the Read/Write Color register. Only the bit planes that the
     Plane Mask register specifies are modified, so the only bits in the
     bit planes that are updated are those that the replace, AND, OR, or
     XOR operation modifies.

       ÉÍÍÍ»     It is instructive to compare the interaction of the write
       º T º     mode, foreground color, and Plane Mask values within each
       º I º     of the subroutines. The logical operation that takes place
       º P º     (replace, AND, OR, or XOR) is not programmed explicitly
       ÈÍÍÍ¼     with an 80x86 instruction. It is implicit in the contents
                 of the graphics control registers, which are programmed to
                 emulate the logical operation by modifying the individual
                 bits in the updated pixel.


MCGA

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     In CGA-compatible graphics modes, the same routines for setting pixel
     values run unchanged on both the CGA and the MCGA. The two non-CGA
     modes (640-by-480 2-color and 320-by-200 256-color) can be handled
     easily with simple modifications to the routine for 640-by-200 2-color
     mode. Listings 5-16 and 5-17 show the necessary changes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-16.  Setting a pixel value in MCGA or VGA 640-by-480 2-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-17.  Setting a pixel value in MCGA or VGA 320-by-200 256-
     color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


VGA

     Once you create routines to update pixels on the MCGA and EGA, doing
     the same for the VGA is easy. The only VGA video mode that does not
     exist on the other subsystems is 640-by-480 16-color mode. Pixel
     addressing in this mode is the same as in the EGA's 640-by-350 16-
     color mode, so the routines in Listings 5-12 through 5-14 may
     be used.


Filling the Video Buffer


     Usually the first thing you do after selecting a new video mode is
     clear the video buffer by filling it with a uniform background of
     repetitive data. In alphanumeric modes, it is easy and efficient to
     fill the buffer with blanks or nulls by using the 80x86 STOSW
     instruction.

     Filling the video buffer in graphics modes is more of a challenge.
     Zeroing the entire buffer is relatively easy, but filling the screen
     with a solid color or pixel pattern is more difficult, particularly on
     the EGA, the VGA, and the InColor Card.


CGA

     On the CGA, you can set the entire buffer to a single pixel value or a
     pattern of vertical stripes with a REP STOSW operation, as the routine
     in Listing 5-18 does. Because of the two-way interleave in the video
     buffer map, this technique fills all even-numbered scan lines before
     filling the odd-numbered lines. You might prefer to clear the buffer
     from the top down by filling it a line at a time. This technique, used
     in Listing 5-19, achieves a slightly smoother appearance, but requires
     slower and bulkier code.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-18.  Simple CGA graphics buffer fill.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-19.  CGA graphics buffer fill using two-way interleave.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     You can exploit the two-way interleave in the video buffer map to
     create a color blend or a simple pattern (see Listing 5-20). In this
     case, the pixel pattern in the even-numbered scan lines is shifted in
     position from the pattern in the odd-numbered scan lines. This creates
     a dithered or halftone pattern on the screen. Because the pixels are
     so close together, the eye blends them, perceiving the dithered
     pattern as gray in 640-by-200 2-color mode or as an intermediate color
     blend in 320-by-200 4-color mode.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-20.  CGA graphics buffer fill with different pixel pattern
     in odd and even rows.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC and HGC+

     You can use the same basic techniques for clearing the video buffer in
     the HGC's 720-by-348 monochrome graphics mode as in the CGA's 640-by-
     200 2-color mode. However, your routine must be able to clear either
     of the two displayable portions of the HGC's video buffer. +Listing
     5-21 demonstrates how you can do this. Again, you can take advantage
     of the interleaved video memory map to create a dithered pattern as
     you clear the buffer.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-21.  HGC graphics buffer fill using four-way interleave.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


EGA and VGA

     The Graphics Controller can provide a certain amount of hardware
     assistance in filling the EGA and VGA video buffer. Also, because the
     buffer holds more data than can be displayed on the screen, you can
     choose to clear only the displayed portion, an undisplayed portion, or
     the entire buffer.

     In 640-by-200 2-color and 320-by-200 4-color modes you can use the
     routines for the CGA (see Listings 5-18 through 5-20). Remember,
     however, that the EGA and the VGA have enough video RAM to support two
     screens of data in 320-by-200 4-color mode. Your routine should
     therefore be capable of clearing any designated area of the buffer.
     Filling the video buffer in 640-by-480 2-color mode (see Listing 5-22)
     and 320-by-200 256-color mode (see Listing 5-23) is also a relatively
     easy task, because pixel addressing in these modes is simple.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-22.  MCGA and VGA 640-by-480 2-color graphics buffer fill.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-23.  MCGA and VGA 320-by-200 256-color graphics buffer fill.
     This routine fills alternate pixel rows separately to allow dithered
     pixel patterns.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In 16-color 200-line graphics modes and all 350-line graphics modes,
     your routines should program the Graphics Controller to exploit its
     parallel processing capabilities. The most efficient way to fill the
     video buffer with a solid color is to use write mode 0 to repeatedly
     copy the Set/Reset value into the video buffer. Because no CPU read is
     required for this operation, you can set the entire video buffer to a
     solid color with a single REP STOSW instruction as shown in Listing
     5-24.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-24.  Solid buffer fill for EGA and VGA native graphics
     modes. The code assumes that the Graphics Controller is already in
     write mode 0 (the BIOS default).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Filling the video buffer with an arbitrary pixel pattern is more
     difficult. Although the basic technique is the same, each component of
     the pattern must be written separately to the bit planes. The example
     in Listing 5-25 fills the video buffer with an 8-by-2 pattern of
     pixels in the VGA's 640-by-480 16-color mode. You can adapt the
     routine to 200-line and 350-line 16-color modes on both the EGA and
     VGA.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-25.  Patterned buffer fill for EGA and VGA native graphics
     modes. The code assumes that the desired pixel pattern is already
     stored in the first eight pixels of the first two rows of the video
     buffer (that is, at A000:0000 and A000:0050).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


InColor Card

     As with the EGA and the VGA, you should use the InColor Card's
     graphics data latches to update the four bit planes in parallel.
     Filling the video buffer with a solid color is straightforward, as
     shown in Listing 5-26. Filling it with a pixel pattern demands the
     same sort of logic used in the equivalent routine for the EGA and VGA
     (shown in Listing 5-27).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-26.  Solid buffer fill for Hercules InColor graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 5-27.  Patterned buffer fill for InColor Card. The code
     assumes that the desired pixel pattern is already stored in the first
     eight pixels of the first two rows of the video buffer (that is, at
     offsets 0 and 2000H in BufferSeg).

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


MCGA

     You can use the routines written for the CGA and the VGA to fill the
     video buffer in equivalent graphics modes on the MCGA.



                             6  Lines


                 An Efficient Line-drawing Algorithm
       Scan-converting a Straight Line ş Bresenham's Algorithm

                            Optimization
                     Efficient Pixel Addressing
               Performance Comparisons ş Special Cases

                     PC and PS/2 Implementations
                          Modular Routines
                  Minimizing Video Buffer Accesses
                   Efficient Address Calculations
                           CGA ş HGC ş EGA
                             MCGA ş VGA
                            InColor Card

                           Line Attributes

                              Clipping
          Pixel-by-Pixel Clipping ş A Brute-Force Approach
                         A Better Algorithm



     Most video graphics applications rely on routines that draw straight
     lines on the screen. Straight lines are components of many graphics
     images, including polygons, filled areas (made up of groups of
     contiguous lines), and curves (made up of a series of short line
     segments joined end to end). Because lines are used frequently in
     video graphics, you need fast line-drawing subroutines to obtain high-
     performance video graphics. This chapter describes how to construct
     efficient and flexible line-drawing routines for IBM video subsystems.


An Efficient Line-drawing Algorithm


     Imagine what would happen if you tried to draw a straight line on a
     piece of paper by painting through the square holes in a sieve (see
     Figure 6-1). The result would not really be a line, but a group of
     square dots that approximates a line.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 6-1 is found on page 162       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 6-1.  Line painted through a sieve.


     A raster video display's rectangular grid of pixels resembles an
     electronic "sieve" when it comes to drawing straight lines and
     geometric curves. The best you can do is to represent each line or
     curve with a group of pixels that closely approximates it. The process
     of determining which set of pixels in the video buffer best
     approximate a particular geometric figure is called scan-conversion.

       ÉÍÍÍ»     The visual consequence of scan-conversion is that
       º T º     mathematically smooth lines and curves appear jagged on
       º I º     the screen. Consider the nearly horizontal line in Figure
       º P º     6-2a. The only way to represent such a line within a grid
       ÈÍÍÍ¼     of pixels is as a series of connected horizontal line
                 segments. The more nearly horizontal or vertical the line,
                 the more jagged it appears. Although sophisticated
                 software techniques can minimize the jagged appearance of
                 a scan-converted line, the easiest way to smooth out a
                 line is to "use a finer sieve"; that is, to use a higher-
                 resolution video mode or higher-resolution video display
                 hardware (see Figure 6-2b).


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 6-2 is found on page 163       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 6-2.  A nearly horizontal line displayed with (a) low
     resolution and (b) higher resolution.


Scan-converting a Straight Line

     The simplest way to draw a line is to use the equation of the line

     y = mx + b

     where m is the slope of the line and b is the y-intercept (the value
     of y at the point where the line crosses the y-axis). You can use this
     equation to calculate the corresponding y-coordinate for each pixel x-
     coordinate between the line's endpoints as shown in Listing 6-1. This
     technique is slow, but it is easy to implement.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-1.  Drawing a line using the equation of the
     line.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The problem is that the computational overhead in performing the
     multiplication, addition, and rounding necessary to generate y for
     each x in the line is considerable. Furthermore, the slope m must be
     maintained as a floating-point number, and using floating-point
     arithmetic in the calculations slows them down.


Bresenham's Algorithm

     Incrementally calculating the appropriate y-coordinates is much more
     efficient. Given the x- and y-coordinates of the first pixel in the
     line, you can calculate the location of each subsequent pixel by
     incrementing the x- and y-coordinates in proportion to the line's
     slope. The arithmetic is simpler and faster than that involved in
     directly using the equation of the line.

     The algorithm presented by J. E. Bresenham in 1965 (IBM Systems
     Journal 4 (1) 1965, pp. 25-30) plots the set of pixels that lie
     closest to the line between two given pixels--(x1,y1) and (x2,y2)--
     assuming that x1 is less than x2 and that the slope of the line is
     between 0 and 1. To simplify the equation of the line, the algorithm
     assumes the location of the first endpoint (x1,y1) is (0,0). The
     equation of the resulting line is

     y = (dy/dx) * x

     where

     dy = y2 - y1

     and

     dx = x2 - x1

     To visualize how Bresenham's algorithm works, consider the portion of
     a line shown in Figure 6-3. The algorithm proceeds by iteratively
     determining the corresponding y-coordinate for each value of x from x1
     to x2. After plotting the pixel at (x(sub i-1),y(sub i-1)), for
     example, the algorithm determines whether pixel A or pixel B is closer
     to the exact line and plots the closer pixel.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 6-3 is found on page 165       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 6-3.  Bresenham's incremental line-drawing algorithm. Given the
     pixel at (x(sub i-1),y(sub i-1)), the algorithm selects either pixel
     A or B depending on the values of a and b.


     The difference between pixel A's y-coordinate and the y-coordinate on
     the exact line at x(sub i) is

     a = (y(sub i)+1) - (dy/dx)*x(sub i)

     where (dy/dx) represents the line's slope. Similarly, the distance b
     from pixel B to the line is

     b = (dy/dx)*x(sub i) - y(sub i)

     If distance b is smaller than distance a, pixel B lies closer to the
     exact line. If a is smaller than b, pixel A is closer. In other words,
     the sign of the difference (b - a) determines whether pixel A or pixel
     B is closer to the line.

     Now, this may seem like much more work than simply using the equation
     for the line. However, the values of a and b can be compared
     implicitly for each x(sub i) by iteratively computing the value of
     (b - a) for each succeeding x(sub i) in terms of simpler quantities
     like dy and dx. The resulting computation is simple, although deriving
     it requires a bit of algebra.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     To derive the computation, combine the equations for a and b:

     (b-a) = 2*(dy/dx)*x(sub i) - 2*y(sub i) - 1

     Since x1 is less than x2, dx is always positive, so dx * (b - a) can
     be used instead of (b - a) to decide whether to plot pixel A or pixel
     B:

     dx*(b-a) = 2*dy*x(sub i) - 2*y(sub i)*dx - dx

              = 2*(dy*x(sub i) - dx*y(sub i) - dx

     Let d(sub i) represent the quantity dx*(b-a). To calculate d(sub i)
     iteratively, you need to know how to compute it from d(sub i-1):

     (d(sub i)-d(sub i-1)) = (2*(dy*x(sub i) - dx*y(sub i))) -
                               (2*(dy*x(sub i-1) - dx*y(sub i-1)))

                           = 2*(dy*(x(sub i)-x(sub i-1))) - dx*(y(sub i)-
                                y(sub i-1))

     x(sub i) - x(sub i-1) is always 1, and y(sub i) - y(sub i-1 is either
     1 (if pixel A at (x(sub i),y(sub i + 1) is plotted) or 0 (if pixel B
     at (x(sub i),y(sub i) is plotted). Thus, computing the difference
     between d(sub i) and d(sub i-1) is easy, and d(sub i) can be
     calculated simply by incrementing d(sub i-1) with one of two
     constants:

     If d(sub i-1) >= 0, plot pixel A at (x(sub i),y(sub i + 1)). The
     increment for d(sub i-1) is then

     (d(sub i)-d(sub i-1)) = 2*(dy-dx)

     If d(sub i-1) < 0, plot pixel B at (x(sub i),y(sub i)). The
     increment for d(sub i-1) is then

     (d(sub i)-d(sub i-1)) = 2*dy

     To calculate d(sub i)'s initial value, remember that the first pixel
     in the line is assumed to be at (0,0). Substituting x(sub i) = 1 and
     y(sub i) = 0 into the equation for d(sub i) gives

     d(sub i) = 2*dy - dx

     The resulting algorithm is efficient, because the most complicated
     calculations are performed only once, outside the loop that plots the
     pixels (see Listing 6-2). Within the loop, incrementally determining
     which pixels lie closest to the desired line (using the decision
     variable d(sub i) eliminates the need for time-consuming floating-
     point arithmetic. The result is a faster line-drawing algorithm.


Optimization


     Nevertheless, there is still room for improvement. The slowest part of
     the line-drawing primitive in Listing 6-2 is the call to SetPixel(),
     which calculates the pixel's address in the video buffer and then sets
     the pixel's value. The pixel address calculation is clearly the
     slowest part of the procedure.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-2.  A high-level implementation of Bresenham's
     algorithm.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Efficient Pixel Addressing

     Fortunately, you can optimize the pixel address calculation
     significantly: The pixel addresses themselves can be calculated
     incrementally, in the same way you increment the decision variable
     d(sub i). After calculating the address of the first pixel in the
     line, you can find its neighbors in the video buffer either by
     incrementing the pixel's byte offset or by rotating the bit mask that
     represents its bit offset. Calculating pixel addresses incrementally
     is significantly faster than performing the computation from scratch
     for each (x,y) coordinate pair in the line.

     For example, you can identify the pixel immediately to the right of a
     given pixel by rotating the given pixel's bit mask one pixel position
     to the right. (If the given pixel is the rightmost pixel in its byte,
     increment the byte offset as well.) To find the pixel immediately
     above a given pixel, decrement the byte offset by the number of bytes
     per row of pixels, but keep the bit mask the same. This calculation is
     slightly more complicated in video modes with an interleaved video
     buffer map, but the principle is the same.


Performance Comparisons

     When you compare the techniques for scan-converting lines, the
     performance gains from using an incremental line-drawing algorithm and
     incremental address calculations are remarkable (see Figure 6-4).
     Writing your line-drawing routines in assembly language also helps.
     Coding and optimizing bit mask manipulation and address computations
     is much easier in assembly language than in a high-level language.


Algorithm                              Language         Pixels per Second
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Algorithm based on the equation
of a line                              C                 4,800
Bresenham's algorithm                  C                16,000
Bresenham's algorithm                  Assembler        26,000
Bresenham's algorithm with             Assembler        70,000
incremental pixel address calculation
     Figure 6-4.  Performance of line-drawing algorithms in C and in
     assembly language. Timings were obtained on a 6 MHz IBM PC/AT with a
     Hercules Graphics Card.


Special Cases

     To further improve the overall performance of your video graphics
     drivers, use special routines for drawing horizontal and vertical
     lines. In many applications, these special cases account for a
     surprising percentage of the calls to the line-drawing primitive. This
     is especially true if you use lines to fill regions.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-3.  A routine that draws horizontal lines.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     For example, the routine FilledRectangle() in Listing 6-3 calls on the
     line-drawing function to draw horizontal lines exclusively. If you
     fill a rectangle that is 100 pixels high, the line-drawing function is
     called 100 times to draw a horizontal line. When the line-drawing
     function recognizes the special case of horizontal lines, functions
     such as FilledRectangle() run significantly faster.

     A special-purpose routine can draw horizontal lines 10 times faster
     than a general-purpose line-drawing routine. For vertical lines, a
     special-purpose routine is about 25 percent faster. Horizontal lines
     are represented in the video buffer by contiguous sequences of bytes
     you can fill with an 80x86 REP STOSB instruction, which runs much
     faster than the iterative loop the general line-drawing primitive
     requires. In drawing vertical lines, no logic is required to determine
     pixel locations. You simply increment the pixel address. Again, the
     resulting code is simpler and faster.


PC and PS/2 Implementations


     Implementations of Bresenham's line-drawing algorithm on IBM video
     hardware are strongly influenced by the CPU's capabilities and by the
     idiosyncrasies of pixel mapping in the video buffer in various
     graphics modes. Nevertheless, once you write a line-drawing routine
     for one graphics mode, you can adapt the source code to other graphics
     modes or to other video hardware with little difficulty.


Modular Routines

     You should build your line-drawing routines with a modular structure.
     One practical way to break your code into modules is to write separate
     routines for horizontal lines, vertical lines, lines with slope less
     than 1, and lines with slope greater than 1. Each module itself
     comprises a set of modules for performing each of the necessary pixel
     manipulations--XOR, AND, OR, and pixel replacement.

       ÉÍÍÍ»     Bresenham's algorithm as derived in this chapter is
       º T º     applicable only to lines whose slope lies between 0 and 1.
       º I º     However, it is easy to use the same algorithm for lines
       º P º     with other slopes. For lines with slopes between -1 and 0,
       ÈÍÍÍ¼     simply change the sign of the y-increment (see Listing
                 6-2). For lines with slopes less than -1 or greater than 1
                 (that is, |(dy/dx)|> 1), use the same algorithm but
                 exchange the x- and y- coordinates.

                 For example, each of the assembly-language line-drawing
                 routines in this chapter contains two similar subroutines,
                 one for |(dy/dx)|<= 1 and another for |(dy/dx)|> 1. Each
                 routine contains a prologue that detects the special
                 cases of horizontal and vertical lines, initializes the
                 appropriate increment values, and selects the proper
                 subroutine  for the slope.

     Breaking your routines into modules helps when you customize your code
     for an application. It also simplifies the task of writing code to run
     symmetrically in different graphics modes. For example, a routine that
     draws a vertical line in 640-by-200 2-color mode on a CGA requires
     little modification to run properly in 320-by-200 4-color mode.


Minimizing Video Buffer Accesses

     In the 8086 family of microprocessors, data transfer instructions of
     the form MOV mem,reg are among the slowest. Try to minimize use of

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     this CPU instruction within your line-drawing primitives. Neighboring
     pixels in a line frequently are grouped in the same byte in the video
     buffer. (Obviously, such groups occur more frequently in more nearly
     horizontal lines.) You can speed your line-drawing routines by
     updating all neighboring pixels in each byte you store in the video
     buffer.


Efficient Address Calculations

     To maximize performance, use CPU registers carefully to hold the
     values most frequently updated in the inner loops of your routines:
     the pixel bit mask, the buffer offset, and the decision variable. In
     Listing 6-4, for example, registers DH and DL hold bit masks,
     register BX holds the buffer offset, and the decision variable d is
     maintained in register DI. These values are the ones most frequently
     updated in these routines, so they are the ones you should try to keep
     in registers rather than in memory variables.

     If you neglect to use the CPU registers effectively, your routines may
     run much slower than necessary. Consider what would happen if you
     rewrote the routine in Listing 6-4 to store the decision variable in
     a memory variable instead of in register DI. Just this minor change
     would cause the routine to run about 20 percent slower. (Not only does
     this emphasize why you must make the best possible use of the CPU
     registers, but it also suggests why writing highly optimized video
     graphics primitives in a high-level language is very difficult.)


CGA

     Listing 6-4 contains code for drawing lines in the CGA's 640-by-200
     2-color graphics mode. The routine consists of a prologue and four
     line-drawing modules. The prologue puts the endpoints in ascending
     order by their x-coordinates, sets  up appropriate vertical increments
     for computing the pixel address within the  inner loop, and selects an
     appropriate line-drawing module according to the  slope of the line.
     The line-drawing modules (VertLine06, HorizLine06, LoSlopeLine06, and
     HiSlopeLine06) contain the inner loops that actually update pixels and
     increment addresses.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-4.  A line-drawing routine for CGA 640-by 200 2-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Most of the execution time in this routine is spent in the inner loops
     of the four line-drawing modules. To optimize the speed of the inner
     loops, as much computation as possible is performed outside of them.
     In particular, the inner loop of HorizLine06 (at label L43) is very
     fast because it consists only of a single 80x86 machine instruction.

     The routines LoSlopeLine06 and HiSlopeLine06 implement Bresenham's
     algorithm. The inner loop of HiSlopeLine06 (at L21) is simpler than
     the inner loop of LoSlopeLine06 (at L11). This is because
     HiSlopeLine06 increments the pixel y-coordinate, and thus the buffer
     offset, on every iteration, so the only other code needed in the loop
     is the code to increment the decision variable and update the pixel
     bit mask. In LoSlopeLine06, the x-coordinate is incremented on each
     iteration by rotating the pixel bit mask. This necessitates some extra
     code to update the bit mask and buffer offset in accordance with the
     decision variable's value.

     The routine for 320-by-200 4-color mode, shown in Listing 6-5, is
     similar to the one for 640-by-200 2-color mode. In fact, you could
     write a single routine that works in either mode without undue
     sacrifice in performance. The differences lie in how the address of
     the first pixel in the line is calculated (that is, a call to
     PixelAddr04 versus one to PixelAddr06) and in how many bits are masked
     and updated for each pixel in the buffer. The bit mask is 1 bit wide
     in 640-by-200 2-color mode and 2 bits wide in 320-by-200 4-color mode.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-5.  A line-drawing routine for CGA 320-by-200 4-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     On the CGA, the code that handles vertical increments is complicated
     by the need to step across the interleaves in the video buffer. The
     pixel address is incremented by 2000H to move from the first
     interleave (even y-coordinates) to the second interleave (odd y-
     coordinates). To increment from a pixel at an odd y-coordinate to the
     pixel just below it, you add -2000H (to increment from the second to
     the first interleave) plus 80 (the number of bytes in each pixel row
     in the buffer). The increment is thus 0E050H (80 - 2000H).

       ÉÍÍÍ»     The routines for the CGA presented in Listings 6-4 and
       º T º     6-5 can only copy the specified pixel value into the
       º I º     video buffer. To perform a XOR, an OR, or an AND operation
       º P º     on the preexisting values in the buffer using the
       ÈÍÍÍ¼     specified pixel value, change the inner loops of each of
                 the four line-drawing modules.

                 In selecting among pixel operations (XOR, AND, and so on),
                 you face the usual trade-off between speed and code size.
                 To maximize speed, write a separate line-drawing module
                 for each pixel operation (AND, OR, XOR, and replace). To
                 minimize redundant code, call a short subroutine, or add
                 some branching logic to perform one of the pixel
                 operations.


HGC

     The routine for the HGC, contained in Listing 6-6, is similar to the
     one for the CGA's 640-by-200 2-color mode. The important difference is
     in how the HGC's video buffer is mapped. Because of the Hercules video
     buffer's four-way interleave, the pixel address is incremented by
     adding the buffer interleave value (2000H or -2000H) until the result
     exceeds the limit of valid buffer offsets. Because valid buffer
     offsets lie in the range 0 through 7FFFH, the routine detects the
     overflow condition by examining the high-order bit of the result. When
     the result overflows, it adds another value (90 - 8000H or 8000H - 90)
     to it, so that the new result is the proper offset in the next buffer
     interleave.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-6.  A line-drawing routine for Hercules monochrome graphics
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routines for the HGC never access the video buffer with 16-bit
     read/write operations such as MOVSW or AND [BX],DX. Avoiding these
     16-bit operations ensures that the routines will run on the InColor
     Card as well as on the HGC and HGC+.

       ÉÍÍÍ»     You can use the same line-drawing routines on either of
       º T º     the HGC's video pages by setting the appropriate value for
       º I º     VideoBufferSeg in PixelAddrHGC. For video page 0, set
       º P º     VideoBufferSeg to B000H. For video page 1, use B800H.
       ÈÍÍÍ¼


EGA

     For the EGA, three line-drawing routines can cover all available
     graphics modes. The routines for the CGA's 640-by-200 2-color and 320-
     by-200 4-color modes work equally well in equivalent modes on the EGA.
     The routine for the remaining graphics modes (200-line 16-color modes
     and all 350-line modes) is complicated by the need to program the
     Graphics Controller, but simplified in that the Graphics Controller
     hardware handles some pixel manipulations that must be performed in
     software on the CGA.

     The routine in Listing 6-7 uses Graphics Controller write mode 0 to
     update the video buffer. The routine stores the pixel value for the
     line in the Set/Reset register. For each pixel updated in the buffer,
     the routine writes the appropriate bit mask to the Bit Mask register.
     Thus, a single 80x86 instruction can read, update, and rewrite up to 8
     pixels at a time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-7.  A line-drawing routine for native EGA graphics modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Within the line-drawing modules, the value 3CEH (the port for the
     Graphics Controller Address register) is maintained in DX, the value 8
     (the Bit Mask register number) is kept in AL, and the current pixel
     bit mask is kept in AH. This lets you update the bit planes with only
     two machine instructions: OUT DX,AX to update the Bit Mask register
     and a MOVSB or OR ES:[DI],AL instruction that causes a CPU read and
     CPU write to occur.

     This routine makes careful use of the 80x86 registers and the Graphics
     Controller. The Graphics Controller's parallel processing helps the
     routine run at about the same speed as do CGA and HGC line-drawing
     routines.

     Native EGA graphics modes use no video buffer interleave, so locating
     a pixel's vertical neighbors in the video buffer is easy. If each line
     contains n bytes of pixels, the next pixel up from a given pixel is -n
     bytes away, and the next pixel down is n bytes away. The code for
     incrementing pixel addresses vertically is thus simpler than the
     corresponding code for the CGA or the HGC. (Compare, for example, the
     code in the loop at label L32 in Listings 6-4 and 6-7.)

     The Graphics Controller handles any of four pixel operations for you
     (XOR, AND, OR, and replace), so the only extra code required to
     support these functions consists of a few instructions to load the
     Data Rotate/Function Select register (03H). This task is part of the
     "configure the Graphics Controller" code near the beginning of the
     routine in Listing 6-7.

       ÉÍÍÍ»     You can use this line-drawing routine in 640-by-350
       º T º     4-color and monochrome modes. Be sure to specify the

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
       º I º     proper pixel value in these modes so that the routine sets
       º P º     bits in the proper bit planes (see Chapter 4).
       ÈÍÍÍ¼


MCGA

     In CGA-compatible modes, you can use the CGA line-drawing routines on
     the MCGA. The non-CGA modes (640-by-480 2-color and 320-by-200 256-
     color) require their own routines, as shown in Listings 6-8 and 6-9,
     but these are easily derived from the code for 640-by-200 2-color
     mode.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-8.  A line-drawing routine for MCGA and VGA 640-by-480
     2-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-9.  A Line-drawing routine for MCGA and VGA 320-by-200
     256-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


VGA

     Once you implement routines for the EGA and the MCGA, you can draw
     lines in any of the VGA's graphics modes. To draw lines in 640-by-480
     16-color mode, use the 640-by-350 16-color routine.


InColor Card

     Because pixel addressing in the video buffer is the same on the
     InColor Card as on Hercules monochrome cards, the only significant
     difference in the line-drawing routines for the InColor Card, as
     you'll see in Listing 6-10, is some extra code to select the
     specified pixel value. Note how the InColor Card's write mode 1 is
     used along with an appropriate foreground value in the Read/Write
     Color register to set the values of neighboring pixels in each byte of
     the buffer. This technique parallels the use of write mode 0 and the
     Set/Reset register on the EGA.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-10.  A line-drawing routine for the InColor Card's 720-by-
     348 16-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Line Attributes


     The line-drawing algorithm in this chapter draws lines that are
     exactly one pixel wide. Consequently, diagonal lines appear less
     bright than horizontal or vertical lines. You can fatten diagonal
     lines by modifying the pixel-setting inner loop of a Bresenham line-
     drawing routine so that it always sets pixel B before selecting the
     next pixel in the line. The resulting lines are fatter, but the
     modified routine runs more slowly because it must update more pixels,
     particularly in lines with slopes near 1 or -1.

     To draw wider lines, simply draw contiguous, neighboring parallel
     lines. If you are using a pointing device to draw a wide line
     interactively, use a series of neighboring horizontal or vertical
     lines. After implementing a fast routine for drawing horizontal lines,
     you can write a high-level routine that paints wide lines by calling
     the horizontal line primitive.

     In some applications, you may wish to draw dashed lines or
     multicolored lines that incorporate a pattern of pixel values. To do
     this, modify the inner loop of your line-drawing routine to select
     pixel values from a circular list of possible values. Rotate the list
     each time you set a pixel.


Clipping


     Not one of the assembly-language routines in this chapter validates
     the pixel coordinates you supply as endpoints. For example, if you
     call the 640-by-200 2-color routine to draw a line from (0,0) to
     (1000,1000), the routine blithely updates about 800 pixels at memory
     locations that don't exist in the available video RAM, all the way
     from (200,200) through (1000,1000). To avoid this sort of error, you
     must determine which part of any arbitrary line lies within a given
     area of the video buffer. This process is known as clipping.

     In the case of 640-by-200 2-color mode, the area into which lines must
     be clipped is the rectangular region defined by (0,0) in the upper
     left corner and (639,199) in the lower right corner. You would
     therefore clip a line with endpoints at (0,0) and (1000,1000) so that
     only the portion from (0,0) to (199,199) is drawn. In avoiding the
     error of updating nonexistent RAM, you might also improve your
     program's performance, since the line-drawing primitive will not
     attempt to update those nonexistent pixels.


Pixel-by-Pixel Clipping

     A simplistic approach to clipping is to include a clipping test in the
     inner loop of your line-drawing routines. Just before setting the
     value of each pixel, your routine could compare the current pixel bit
     mask and buffer address with a set of precalculated limits. If the
     address, the bit mask, or both exceeded the limits, the routine would
     not update the video buffer. However, the overhead involved in
     clipping in this manner can be considerably greater than the work
     required to calculate and draw the pixels in the line.

       ÉÍÍÍ»     In general, avoid integrating code for line clipping into
       º T º     low-level line-drawing routines, regardless of how
       º I º     efficient the code might be. Keeping the functions
       º P º     separate can improve performance, because an application
       ÈÍÍÍ¼     can invoke the line-drawing routines directly, bypassing
                 the clipping code altogether when it's not needed.


A Brute-Force Approach

     Another way to clip a line is to use its equation to calculate where,
     if anywhere, the line segment to be drawn intersects the edges of the
     rectangular display region. For example, in Figure 6-5, the slope m
     of the line is

     m = dy/dx = (y2-y1)/(x2-x1) = (100-40)/(750-150) = 0.1

     The y-intercept can be calculated by substituting x1 and y1 into the
     equation of  the line:

     b = y1 - m*x1 = 40 - (0.1*150) = 25

     The equation of the line is thus

     y = 0.1*x + 25

     To calculate the coordinates of the intersections of the line and the
     edges of the window, substitute the x-coordinates of the window's
     vertical edges and the y-coordinates of its horizontal edges into the
     equation. Each time you solve the equation for one side of the
     rectangle, check the result to see whether the intersection point
     actually lies within the line segment to be drawn as well as within
     the rectangle.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 6-5 is found on page 216       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 6-5.  Line segment (150,40)-(750,100) clipped at (639,89) in
     640-by-200 2-color mode.


     This approach to line clipping involves a lot of computation,
     primarily because the equation of the line must be solved four times
     for every line segment you clip. You must also check the results
     against the limits of the line segment to determine whether the
     intersection points fall between the endpoints. Furthermore, you must
     still handle special cases such as horizontal and vertical lines or
     degenerate "lines" consisting of a single pixel. This computational
     burden makes brute-force clipping impractical.


A Better Algorithm

     A more efficient algorithm for line clipping compares the endpoints of
     the line segment with the boundaries of the rectangular region before
     computing intersection points. Thus, little computation is performed
     for lines that need not be clipped. The Sutherland-Cohen algorithm,
     which uses this approach, is widely known because of its simplicity
     and computational efficiency. (See Sproull and Sutherland, "A Clipping
     Divider," Conference Proceedings, Fall Joint Computer Conference,
     volume 33, pp. 765-776. AFIPS Press, 1968.)

     Conceptually, the algorithm extends the edges of the rectangular
     clipping region, dividing the plane into nine regions (see Figure
     6-6). Each endpoint of the line segment to be clipped falls into
     one of these regions. Identifying the region that corresponds to each
     endpoint makes it easy to determine the location of the line segment
     relative to the rectangular clipping area.


                  ³              ³
         0011     ³     0010     ³     0110
                  ³              ³                Mapping of bits
                  ³              ³                in 4-bit codes
     ÄÄÄÄÄÄÄÄÄÄÄÄÄşÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄ
                  ³(x(sub ul),y(sub ul))          bit 0:1 = left
                  ³              ³                    1:1 = above
         0001     ³     0000     ³     0100           2:1 = right

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                  ³              ³                    3:1 = below
     ÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄşÄÄÄÄÄÄÄÄÄÄÄÄÄ
                  ³              ³(x(sub lr),y(sub lr))
                  ³              ³
         1001     ³     1000     ³     1100
                  ³              ³

     Figure 6-6.  Rectangular clipping using the Sutherland-Cohen
     algorithm.


     The algorithm uses a computational shortcut to determine the relative
     location of the line segment. Each of the nine regions is represented
     by a 4-bit code; each bit corresponds to whether the region is above,
     below, left, or right of the clipping rectangle. The relationship of
     the endpoints to the rectangle is then quickly determined by bitwise
     combination of the 4-bit codes.

     If the logical OR of the two codes is 0 (that is, the 4-bit code for
     both endpoints is 0), both endpoints lie within the rectangle, and no
     clipping is needed. If the logical AND of the two 4-bit codes is
     nonzero, both endpoints lie on the same side of the rectangle, and the
     entire line is clipped out. These tests can be performed rapidly,
     because both the bitwise AND and OR operations can be implemented in
     single 80x86 machine instructions.

     If the logical OR of the endpoints' 4-bit codes is nonzero but the
     logical AND is 0, then the line segment is clipped against one of the
     rectangle's edges. The values of the 4-bit codes then determine which
     edge is used. The resulting intersection point becomes a new endpoint
     for the line segment.

     This process is repeated for the new line segment. The 4-bit codes are
     recalculated, the bitwise comparison is again performed, and, if
     necessary, a new endpoint is calculated. Since a rectangle has four
     sides, the algorithm requires at most four iterations.

     The routine Clip() in Listing 6-11 is a C illustration of the
     Sutherland-Cohen algorithm. The while block repeats while neither of
     the two termination conditions (Inside or Outside) is true. The 4-bit
     codes are used to determine which of the four sides of the rectangle
     the clipping calculation uses. The intersection point between the line
     segment and the side of the rectangle becomes a new endpoint. At the
     bottom of the while block, the 4-bit code for the new endpoint is
     calculated, and the loop repeats.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 6-11.  An implementation of the Sutherland-Cohen clipping
     algorithm.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     A program could call Clip() before drawing a line with a fast
     primitive such as Line(). If you are careful to define the values XUL,
     YUL, XLR, and YLR as variables rather than constants, you can use
     Clip() in any video mode. Furthermore, line clipping need not be
     limited to clipping lines to the limits of available RAM in the video
     buffer. You may instead want to define an arbitrary rectangular region
     in the video buffer and clip lines against it. A good high-level video
     graphics interface supports clipping into such arbitrary regions.



                      7  Circles and Ellipses

                      Circles and Pixel Scaling

                    An Ellipse-drawing Algorithm
                     Scan-converting an Ellipse
                      An Incremental Algorithm
                      A Typical Implementation
                        Problems and Pitfalls
                              Accuracy

                            Optimization

                              Clipping

                            True Circles



     Circles and ellipses are probably the most common graphics elements
     other than straight lines. This chapter describes techniques for
     displaying circles, ellipses, and arcs with IBM video hardware. These
     techniques are similar to the algorithms and programming examples for
     displaying straight lines (described in Chapter 6). Although an
     ellipse-drawing routine is somewhat more complicated than a routine
     for drawing straight lines, the algorithmic design and programming
     techniques are similar.


Circles and Pixel Scaling


     The only way to draw a circle on the IBM video subsystems discussed in
     this book is to calculate and draw an ellipse. The reason is that the
     horizontal scale in which pixels are displayed differs from the
     vertical scale in most graphics modes (Chapter 4). If you display a
     "circle" whose pixels are computed without scaling, what you see on
     the screen is an ellipse. For example, Figure 7-1a shows a "circle"
     with a radius of 100 pixels in both horizontal and vertical directions
     as displayed in a 640-by-200 graphics mode.

     Because of this problem of pixel scaling, drawing a circle on the
     screen requires that you compute the pixels that correspond to a
     mathematical ellipse. In other words, to draw a circle that really
     looks like a circle, you must compute an ellipse whose major and
     minor axes are in the same ratio as the pixel coordinate scaling
     factor. On the screen, such an ellipse appears circular (see Figure
     7-1b). For this reason, this chapter concentrates on a practical
     algorithm for drawing ellipses.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-1 is found on page 222       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-1.  In Figure 7-1a, a mathematical circle with a 100-pixel
     radius appears elliptical in 640-by-200 2-color mode. In Figure 7-1b,
     an ellipse whose axes have been properly scaled appears circular when
     displayed in this mode.


An Ellipse-drawing Algorithm


Scan-converting an Ellipse

     You can use the algebraic formula for an ellipse to compute x- and y-
     coordinates for all of the pixels that represent a given ellipse. As
     in the case of scan-converting a straight line, many of these pixel
     coordinates will necessarily approximate the actual values, and the
     resulting figure will be jagged. This effect is especially noticeable
     when displaying a very thin ellipse (see Figure 7-2), but in most
     cases this side effect is acceptable.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-2 is found on page 223       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-2.  A thin ellipse can appear jagged when it is scan-
     converted.


     You can use the equation of the ellipse

     (x - xc)^2  +  (y - yc)^2 = 1
        a^2            b^2

     to scan-convert and display an ellipse. This equation describes an
     ellipse centered at (xc,yc) with major and minor axes a and b parallel
     to the x- and y-axes. However, the computational overhead of drawing
     ellipses by solving this equation, as in Listing 7-1, is very large.
     The multiplication, division, and square-root operations to determine
     each pixel's coordinates are very time-consuming. A better approach is
     to compute pixel coordinates incrementally in a manner similar to that
     used in the line-drawing algorithm in Chapter 6.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 7-1.  Drawing an ellipse using the equation of the
     ellipse.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


An Incremental Algorithm

     The derivation of an incremental algorithm for drawing ellipses
     resembles the derivation of Bresenham's line algorithm. The ellipse-
     drawing algorithm draws an ellipse pixel by pixel. After drawing each
     pixel, the algorithm selects the next pixel by determining which of
     the current pixel's two neighbors is closer to the actual ellipse.

     Creating an ellipse-drawing algorithm is easiest for an ellipse
     centered at the origin of the coordinate system, with major and minor
     axes congruent with the x- and y-axes (see Figure 7-3). The equation
     of such an ellipse is

     b^2x^2 + a^2y^2 - a^2b^2 = 0

     Because the ellipse is symmetric in relation to both the x- and y-
     axes, you only need derive an algorithm to draw one of its quadrants.
     Your routine can then determine the pixel coordinates in the other
     three quadrants by symmetry.

       ÉÍÍÍ»     If you need an algorithm to draw ellipses with axes that
       º T º     are not parallel to the video buffer's x- and y-axes,

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
       º I º     refer to M. L. V. Pitteway, "Algorithm for Drawing
       º P º     Ellipses or Hyperbolae with a Digital Plotter," Computer
       ÈÍÍÍ¼     Journal vol. 11 no. 3 (November 1967), p. 282.

     The algorithm presented here is known as the "midpoint algorithm." It
     draws an ellipse iteratively, pixel by pixel. For each pixel it draws,
     the algorithm selects which of the pixel's neighbors is closer to the
     ellipse by computing whether the point halfway between the pixels lies
     inside or outside the ellipse (see Figure 7-4). (This algorithm was
     described by J. R. Van Aken in "An Efficient Ellipse-Drawing
     Algorithm," IEEE Computer Graphics and Applications, September 1984,
     p. 24, and improved by M. R. Kappel in "An Ellipse-Drawing Algorithm
     for Raster Displays," Fundamental Algorithms for Computer Graphics,
     R. A. Earnshaw [editor], Springer-Verlag 1985, p. 257.)


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-3 is found on page 225       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-3.  An ellipse centered at the origin of the coordinate
     system.


     To determine which pixel lies closer to the ellipse, the algorithm
     uses the value of the equation of the ellipse at the midpoint between
     the pixels. If the value is 0, the midpoint lies on the ellipse. If
     the value is negative, then the midpoint lies inside the ellipse; if
     the value is positive, the midpoint is outside the ellipse. Thus, the
     algorithm can choose which of the two pixels lies closer to the
     ellipse by examining the value's sign.

     One complication lies in determining which pair of neighboring pixels
     to investigate at each step in the iteration. This depends on dy/dx,
     the slope of the tangent to the ellipse (see Figure 7-5). When dy/dx
     is greater than -1, the algorithm chooses between two vertically
     oriented pixels (see Figure 7-6a). When dy/dx is less than -1, the
     choice is between two horizontally oriented pixels (see Figure 7-6b).

     While dy/dx is greater than -1, the algorithm iteratively determines,
     for each pixel it draws, whether neighboring pixel A or B is
     closer to the ellipse. This is done by deciding whether the mid-
     point between A and B lies inside or outside the exact ellipse. In
     Figure 7-6a, the pixel selected in the previous iteration is at
     (x(sub i-1),y(sub i-1)). The midpoint between A and B is therefore
     (x(sub i-1)+1,y(sub i-1)-1/2).

     The algorithm chooses between pixel A and pixel B by examining the
     sign of the value of the ellipse equation evaluated at the midpoint:

     d = b^2(x(sub i-1)+1)^2 + a^2(y(sub i-1)-1/2)^2 - a^2b^2


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-4 is found on page 226       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-4.  Three iterations of the midpoint algorithm. After drawing
     the black pixel in illustration 7-4a, the algorithm chooses to draw
     either pixel A or pixel B by comparing the midpoint M to the actual
     ellipse. Because M is inside the ellipse, it chooses pixel A.
     Illustrations 7-4b and 7-4c represent the next two iterations.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-5 is found on page 227       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-5.  The slope of the tangent to the ellipse within the first
     quadrant.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-6 is found on page 227       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-6.  The midpoint algorithm chooses between A and B by
     substituting x and y at the midpoint M into the formula for the
     ellipse and testing the sign of the result. If the result is
     positive, pixel B is chosen; if the result is  negative, pixel A is
     chosen.


     The variable d, the value of the function at the midpoint, is the
     algorithm's decision variable. As in Bresenham's line algorithm, the
     key to this algorithm's speed is that it can compute d iteratively on
     the basis of its value at each previous step in the iteration. The
     difference between the current value of d and its previous value is

     d(sub i)-d(sub i-1) = [b^2(x(sub i-1)+1)^2 +
                             a^2(y(sub i-1)-1/2)^2 - a^2b^2] -
                             [b^2(x(sub i-1))^2 + a^2(y(sub i-1)-1/2)^2 -
                             a^2b^2]

                         = b^2(2x(sub i-1)+1)

                         = 2b^2x(sub i-1) + b^2

     Now, finding the difference between d(sub i) and d(sub i-1) (that
     is, dx) still involves multiplying the previous value of x by a
     constant. You can avoid this multiplication, however, by computing dx,
     as well as d, incrementally; that is, by adding 2b^2 to dx at each
     step of the iteration.

     If pixel A is nearer to the ellipse (that is, d(sub i) > 0), the newly
     calculated value of d(sub i) can be used as d(sub i-1) in the next
     iteration. If pixel B is nearer, however, d(sub i) must be adjusted
     for the downward step in the y direction. In this case, the value of
     the equation of the ellipse for the midpoint below pixel B must be
     computed. If (x(sub i-1),y(sub i-1)+1/2) is the midpoint between
     pixels A and B, then (x(sub i-1),y(sub i-1)-1/2) is the midpoint below
     pixel B, and dy is then

     d(sub i)-d(sub i-1) = [b^2(x(sub i-1))^2 +
                             a^2(y(sub i-1)-1/2)^2 - a^2b^2] -
                             [b^2(x(sub i-1))^2 + a^2(y(sub i-1)+1/2)^2 -
                             a^2b^2]

                         = -2a^2y(sub i-1)

     When dy/dx is less than -1, pixels A and B are horizontal rather than
     vertical neighbors (see Figure 7-6b). The values of dy and dx are
     therefore computed somewhat differently. When pixel B is chosen, the
     midpoint at (x(sub i-1)+1/2,y(sub i-1)-1) is used, so the increment
     for d is

     d(sub i)-d(sub i-1) = [b^2(x(sub i-1)+1/2)^2 +
                             a^2(y(sub i-1)-1)^2 - a^2b^2] -
                             [b^2(x(sub i-1)+1/2)^2 + a^2(y(sub i-1))^2 -
                             a^2b^2]

                         = a^2(-2y(sub i-1)+1)

                         = -2a^2y(sub i-1) + a^2

     Also, when pixel A is chosen, d must be adjusted for the step in the
     rightward direction:

     d(sub i)-d(sub i-1) = [b^2(x(sub i-1)-1/2)^2 +
                             a^2(y(sub i-1))^2 - a^2b^2] -
                             [b^2(x(sub i-1)+1/2)^2 + a^2(y(sub i-1))^2 -
                             a^2b^2]

                         = -2b^2x(sub i-1)

     These derivations provide a way to draw an ellipse iteratively, with
     only simple addition and subtraction required within the iterative
     loops. The analysis distinguishes between the case where dy/dx is
     greater than -1 and the case where dy/dx is less than -1. You
     determine when dy/dx has reached -1 by differentiating the equation of
     the ellipse and setting dy/dx to -1.

     d    (b^2x^2 + a^2y^2 - a^2b^2) = 0
     dx
       
       
     2b^2x + 2a^2y dy = 0
                   dx
       
       
     dy  =  -2b^2x
     dx      2a^2y

     Thus, at the point where dy/dx = -1,

     2b^2x = 2a^2y

     Because the algorithm already keeps track of the quantities 2b^2x and
     2a^2y to compute the differentials dx and dy, these quantities can be
     used to detect where dy/dx reaches -1. The algorithm can then start at
     the point (0,b) on the y-axis and proceed clockwise around the ellipse
     until it reaches (a,0).

     Initially, the quantity dy/dx is greater than -1, and the choice is
     made iteratively between vertically oriented pixels (see Figure
     7-6a). When dy/dx reaches -1, the algorithm chooses between
     horizontally oriented pixels (see Figure 7-6b) and continues to do
     so until it reaches the x-axis.

     The only remaining computation occurs when the algorithm reaches the
     pixel for which dy/dx = -1. At this point, a new value for d will
     already have been computed (M(sub old) in Figure 7-7) under
     the assumption that the next midpoint would have been between two
     vertically oriented pixels. Therefore, the value of d must be adjusted
     to reflect the value of the ellipse function at the midpoint between
     two horizontally oriented pixels (M(sub new) in Figure 7-7). The
     increment for d (from M(sub old) to M(sub new)) in this
     case is

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     d(sub i)-d(sub i-1) = [b^2(x(sub i-1)+1/2)^2 +
                             a^2(y(sub i-1)-1)^2 - a^2b^2] -
                             [b^2(x(sub i-1)+1)^2 + a^2(y(sub i-1)-1/2)^2 -
                             a^2b^2]

                         = b^2(-x(sub i-1)-3/4) + a^2(-y(sub i-1)+3/4)

                         = 3(a^2-b^2)/4 - (b^2x(sub i-1) + a^2y(sub i-1))

     Again, since the algorithm already uses the quantities 2b^2x and
     2a^2y, the increment for d at this point can be computed by

     d(sub i)-d(sub i-1) = 3(a^2-b^2)/4 - (2b^2x(sub i-i)+2a^2y(sub i-1))/2

     Adding this value to d at the point where dy/dx = -1 gives the new
     value for d.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-7 is found on page 230       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 7-7.  When the value of dy/dx  reaches -1, a new
     midpoint (M(sub new)) is selected, and d, which has
     already been computed for M(sub old), is adjusted to reflect the
     value of the equation of the ellipse at M(sub new).


A Typical Implementation

     The C routine in Listing 7-2 is fast and efficient because all
     decision-variable computation within the inner iterative loops has
     been reduced to addition and subtraction. The routine eliminates
     multiplication within the inner loops by precalculating the values of
     a^2, b^2, 2a^2, and 2b^2. The initial values for the decision
     variables are computed assuming that the first pixel to be drawn is at
     (0,b). Thus, the initial value of d is calculated for the midpoint
     between the pixels at (1,b) and (1,b-1); that is, at (1,b-1/2):

     d = b^2(1)^2 + a^2(b-1/2)^2 - a^2b^2

       = b^2 - a^2b + a^2/4

     The initial values for dx and dy are

     dx = 2b^2(x(sub 0)) = 0

     and

     dy = 2a^2(y(sub 0)) = 2a^2b

     The routine Ellipse() follows the algorithm closely. It first draws
     all the pixels between (0,b) and the point where dy/dx becomes -1.
     Then it updates d as in Figure 7-7. Iterative pixel selection
     continues until the routine reaches the x-axis. The routine calls the
     function Set4Pixels() to replicate each pixel in each of the four
     quadrants of the ellipse. Set4Pixels() also translates each pixel's
     coordinates relative to the actual center of the ellipse.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 7-2.  A high-level implementation of the midpoint
     algorithm.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Problems and Pitfalls

     One difficult problem you'll encounter is that tiny ellipses appear
     somewhat angular rather than elliptical when they are scan-converted.
     When an ellipse is small and comparatively few pixels are used to
     display it, the best approximation generated by the algorithm can
     appear polygonal.

     Although it is possible to redesign the ellipse-drawing algorithm to
     draw "fatter" or "thinner" ellipses in this situation, a better
     solution is to display the ellipses with higher resolution. Tiny
     ellipses look much better with 640-by-480 resolution than they do with
     320-by-200 resolution.

     A related problem is that very eccentric ellipses may be drawn
     inaccurately at the points where they curve most sharply. This
     happens when the point where  dy/dx = -1 lies nearly adjacent to
     either the x-axis or the y-axis. Again, you can modify the algorithm
     to accommodate this situation, but if your application requires
     accurate representations of very thin ellipses, a better solution is
     to display them at higher resolution.

     A further consideration involves "degenerate" ellipses for which the
     length of either the major or minor axis is 0 (that is, a = 0 or b =
     0). Because either dy or  dx is 0 in this situation, the iterative
     routines do not terminate correctly. In these cases, either test for
     the special condition before executing the loops (and draw the
     appropriate straight line) or modify the termination conditions of the
     loops.


Accuracy

     As does Bresenham's line algorithm, the midpoint algorithm attempts to
     minimize the vertical or horizontal distance to the ellipse from the
     pixels it selects. This is faster than minimizing the distance between
     each pixel and the nearest point to it on the ellipse, but if you
     examine its performance closely, you may find rare occasions when the
     pixel that the midpoint algorithm selects is not the one closest to
     the ellipse. Nevertheless, the accuracy of the midpoint algorithm in
     selecting the best pixels to represent the ellipse is sufficient for
     nearly all applications. (For more discussion of this topic, see Van
     Aken and Novak, "Curve-Drawing Algorithms for Raster Displays," ACM
     Transactions on Graphics, April 1985, p. 147, or Kappel, "An Ellipse-
     Drawing Algorithm for Raster Displays," Fundamental Algorithms for
     Computer Graphics, p. 257.)

     Although the source code in Listing 7-2 is a straightforward
     implementation of the algorithm, you need to remember a few details if
     you plan to modify the code or translate it into another language. It
     is important to compute all decision variables as 32-bit integers.
     Because these values involve the squaring of pixel coordinates, 16
     bits are inadequate to maintain precision.

     Another detail to remember is that this routine can draw the same
     pixels twice. This is an artifact of the ellipse's four-way symmetry.
     For example, the pixels at (ña,0) and (0,ñb) are updated twice by
     Set4Pixels() in Listing 7-2. This becomes a problem when you use the
     routine to XOR pixels into the video buffer. If you perform a XOR on
     these pixels twice, they disappear. To avoid this, either test for
     these special cases in Set4Pixels() (Listing 7-3) or modify Ellipse()
     to draw these pixels separately.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 7-3.  A modified version of Set4Pixels that avoids updating
     the same pixel twice.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Optimization


     For many applications, a high-level language implementation such as
     the one in Listing 7-2 is fast enough. The slowest part of the high-
     level version of Ellipse() is its repeated calls to the pixel-setting
     routine, which recomputes pixel addresses with every iteration. By
     writing Ellipse() in assembly language, you can calculate the pixel
     addresses much more efficiently. The resulting assembly-language
     routine is about three times faster than the equivalent high-level
     version.

     Listing 7-4 is a typical assembly-language implementation, in this
     case for the EGA. Note how the routine Set4Pixels maintains a set of
     four buffer offsets and bit masks instead of (x,y) coordinates for the
     four pixels it updates. When  Set4Pixels increments a pixel x-
     coordinate, it rotates a bit mask in the proper direction. The y-
     coordinates are incremented by adding the number of bytes in each line
     of pixels to the buffer offset. (This is the same technique used in
     the line routines in Chapter 6.) This method of video buffer
     addressing is much faster than making a call to a SetPixel() function
     for every pixel in the ellipse.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 7-4.  An assembly-language implementation of the midpoint
     algorithm.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     One optimization technique used in Chapter 6 is omitted here. In
     practice, minimizing video buffer accesses by setting more than one
     pixel at a time in each byte of the buffer is not worthwhile. The
     overhead involved in keeping track of which bytes contain more than
     one updated pixel is greater than the time saved in reducing video
     buffer accesses. Besides, the code is complicated enough already.


Clipping


     If you clip an ellipse within a rectangular window, the result is an
     arc (see Figure 7-8). The place to perform the clipping is in the
     Set4Pixels() routine. You can clip each pixel's (x,y) coordinates
     against the window boundary before you call SetPixel() to update the
     video buffer.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 7-8 is found on page 241       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     Figure 7-8.  Clipping an ellipse produces an arc.


     Implementing clipping in this way slows the ellipse-drawing routine
     somewhat. If your application rarely requires clipping, consider
     implementing two different versions of Set4Pixels(), one that performs
     clipping and one that omits it. Before calling Ellipse(), you can
     compare the maximum and minimum coordinate values of the pixels in the
     ellipse (xc ñ a,yc ñ b) with the clipping boundaries to determine
     whether it can be drawn without clipping. Only if clipping is required
     do you need to use the slower, clipping version of Set4Pixels().


True Circles


     After you implement the ellipse routine, you can draw true circles in
     all graphics modes on PC and PS/2 video subsystems. To display a
     circle, draw an ellipse with its major and minor axes scaled in
     proportion to your video display's horizontal and vertical
     resolutions. Listing 7-5 shows how you might do this in a 640-by-350
     graphics mode on an EGA.

     Because the scaling varies with the video mode, the same routine
     cannot draw circles in different video modes unless it accommodates
     the pixel coordinate scaling in each mode. Figure 4-9 in Chapter 4
     is a table of pixel scaling factors for all graphics modes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 7-5.  Using pixel coordinate scaling to display a circle in
     640-by-350 16-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



                           8  Region Fill


                          What Is a Region?
              Interior and Border Pixels ş Connectivity

                 Simple Fills with Horizontal Lines

                    Three Region Fill Algorithms
                        Simple Recursive Fill
                         Line-Adjacency Fill
                             Border Fill

                      Comparing the Algorithms



     This chapter describes several methods for filling a region of the
     video buffer with a pattern of pixels. Region fill techniques are used
     in many areas of computer graphics programming, including color
     manipulation, shading, and representation of three-dimensional
     objects, as well as in applications such as image processing, image
     data transmission, and computer animation.

     This chapter contains working source code for three region fill
     algorithms, but the discussion is by no means comprehensive. These
     algorithms and implementations are intended to be working models that
     you can experiment with, modify, and optimize for your own
     applications.


What Is a Region?


     A region is a connected group of pixels in the video buffer that is
     delineated by some sort of boundary. You can think of a region in the
     video buffer as comprising an interior and a border. To understand how
     the algorithms in this chapter are implemented, however, it is worth
     considering how a region can be clearly defined in terms of pixel
     values and pixel geometry in the video buffer.


Interior and Border Pixels

     In this chapter, a region is assumed to be surrounded by pixels whose
     values distinguish them from the pixels in the interior. You could
     assume, for instance, that all interior pixels have the same value, in
     which case a border pixel is simply any pixel whose value differs from
     the values of pixels in the interior (see Figure 8-1a). You could
     also assign a range of allowable pixel values to both interior and
     border pixels. The algorithms in this chapter adhere to the convention
     that all pixels in the border have one specified value and pixels in
     the interior can be of any other value (see Figure 8-1b).

     In many applications, it is practical to use a range of pixel
     coordinates to define all or part of a region's border. The definition
     of a "border pixel" can thus be broadened to include pixels outside a
     predetermined range of (x,y) coordinates. In this way a region can be
     bounded by the limits of the screen buffer or by a software window, as
     well as by pixels of a predetermined value or range of values.


       ±±    ±±    ±±        ±±
           ±±  ±±        ±±                      ±±±±±±±±±±±±
     ±±    ÛÛÛÛÛÛÛÛÛÛÛÛ±±                      ±±ÛÛÛÛÛÛÛÛÛÛÛÛ±±
       ±±±±ÛÛÛÛÛÛÛÛÛÛÛÛ  ±±                    ±±ÛÛÛÛÛÛÛÛÛÛÛÛ±±
   ±±      ÛÛÛÛÛÛÛÛÛÛÛÛ                        ±±ÛÛÛÛÛÛÛÛÛÛÛÛ±±
       ±±  ÛÛÛÛÛÛÛÛÛÛÛÛ    ±±                  ±±ÛÛÛÛÛÛÛÛÛÛÛÛ±±
           ±±          ±±                        ±±±±±±±±±±±±
               ±±         ±±

   a.                                          b.

     Figure 8-1.  In Figure 8-1a, a region is defined by interior pixels of
     a given value. In Figure 8-1b, a region is defined by border pixels of
     a given value.


Connectivity

     To distinguish border pixels from interior pixels, you must also
     specify the way the pixels are connected. If you allow interior pixels
     to be connected diagonally as well as orthogonally (horizontally and
     vertically), you must assume that the border pixels surrounding the
     region are always connected orthogonally (see Figure 8-2a).
     Conversely, if you allow border pixels to be diagonally connected, you
     must constrain interior pixels to orthogonal connections (see Figure
     8-2b). Consider the reason for this constraint: If both border and
     interior pixels could be diagonally connected, then interior pixels
     could be connected to pixels outside the border at places where border
     pixels are diagonally connected.


     ÚÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄ¿
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±± ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÀÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÙ

     a.

     ÚÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄÂÄÄ¿
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³ÛÛ³±±³±±³±±³±±³±±³±±³ÛÛ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³ÛÛ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÃÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄÅÄÄ´
     ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³  ³
     ÀÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÁÄÄÙ

     b.

     Figure 8-2.  Connectivity of pixels. In Figure 8-2a, border pixels
     (black) are orthogonally connected, while interior pixels (gray) are
     both orthogonally and diagonally connected. In Figure 8-2b, border
     pixels are both orthogonally and diagonally connected, so interior
     pixels are only connected orthogonally.


Simple Fills with Horizontal Lines


     Before you become involved with the intricacies of region fill
     algorithms, remember that you can fill many regular geometric shapes
     without using a specialized algorithm. A common application of this
     technique is shown in Listing 8-1. This routine fills a rectangular
     region in the video buffer with pixels of a specified value. It is
     fast, because the subroutine that draws horizontal lines is fast.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 8-1.  Filling a rectangle with horizontal lines.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Creating similar routines to draw filled triangles, hexagons, and
     circles is not difficult, because of these objects' regularity and
     symmetry. Writing a general-purpose routine that can fill convex or
     irregular polygons is more difficult; in  this case, you must scan-
     convert each of the polygon's sides (using, for example, Bresenham's
     algorithm from Chapter 6) to create a list of the pixels that define
     the border of the polygon. This list contains pairs of pixels that can
     then be connected with horizontal lines to fill the interior of the
     polygon.

       ÉÍÍÍ»     Several good textbooks deal with the problem of scan-
       º T º     converting and filling arbitrary polygons. For example,
       º I º     see Fundamentals of Interactive Computer Graphics by J. D.
       º P º     Foley and A. VanDam (Addison-Wesley 1982).
       ÈÍÍÍ¼

     Though polygon fill techniques have many uses, some applications
     require filling a region with completely arbitrary borders, such as a
     map or an irregular shape that was drawn interactively. In this case,
     your fill routine must define the region using only the pixel values
     in the video buffer. The remainder of this chapter presents algorithms
     and working source code for three such routines.


Three Region Fill Algorithms


     The three algorithms described here are all designed with IBM video
     subsystems in mind. They use the pixel manipulation and line-drawing
     subroutines developed in Chapters 4, 5, and 6. Also, all three
     algorithms assume that border pixels can be diagonally connected
     and that interior pixels must be orthogonally connected (as in Figure
     8-2b). You can thus fill regions with boundaries drawn using the
     line-drawing and ellipse-drawing routines in Chapters 6 and 7, since
     those line and ellipse routines draw diagonally connected figures.

     Furthermore, all three algorithms can fill a region that contains a
     hole in its interior (see Figure 8-3). Such holes are collections of
     border pixels that are  not contiguous with the pixels in the region's
     outer border. Each algorithm is designed to detect the presence of
     holes and to properly fill the interior pixels surrounding them.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 8-3 is found on page 247       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 8-3.  A region whose interior (gray pixels) contains two holes.


Simple Recursive Fill

     One way to fill a region is to start by filling a given "seed" pixel
     in its interior, and then to fill each of the seed's immediate
     neighbors, each of the neighbors' neighbors, and so on until the
     entire region is filled. The C routine in Listing 8-2, PixelFill(),
     shows how to do this. In PixelFill(), as in the other algorithms in
     this chapter, pixels in the interior of the region are assumed to be
     connected horizontally and vertically, but not diagonally.
     (PixelFill() can be easily modified to fill diagonally connected
     regions if so desired.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 8-2.  A simple recursive region fill.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Before it fills a pixel, PixelFill() examines the pixel's value to
     determine whether filling is required. If the pixel is neither a
     border pixel nor a previously filled pixel, the routine updates the
     pixel value and calls itself recursively. Because PixelFill() does not
     fill previously filled pixels, the routine works properly even in
     regions with holes.

     Although simple, PixelFill() is inefficient. One reason is that on
     average only one of the four recursive calls to PixelFill() ever does
     anything. (Each pixel can only be filled once, but each time a pixel
     is filled, four recursive calls are made to the function. The only
     exception is in the case of the seed pixel.) Thus, PixelFill()
     accomplishes nothing about 75 percent of the time, which is not very
     efficient.

       ÉÍÍÍ»     Another problem with PixelFill() is that the depth of
       º T º     recursion can increase beyond the limits of available
       º I º     stack memory. For example, the default stack space for
       º P º     code generated with the Microsoft C compiler is 2 KB. You
       ÈÍÍÍ¼     can easily exceed this limit by using PixelFill() to fill
                 even relatively small regions.


Line-Adjacency Fill

     A better approach is to regard the interior of the region as a group
     of adjacent line segments that are connected vertically instead of as
     a group of pixels connected both vertically and horizontally. An
     algorithm that fills adjacent line segments tends to be much more
     efficient than a pixel-by-pixel recursive fill, because it inspects
     and fills pixels more efficiently. Also, this conception of the region
     is closer to the physical representation of pixels in the video
     buffer, in which pixels are arranged in horizontal rows to be
     displayed during the raster scan.

     The routine in Listing 8-3, LineAdjFill(), implements a line-adjacency
     algorithm for filling a region. Its general strategy is to locate each
     group of horizontally connected pixels in the interior of the region.
     Like the simple recursive fill, this algorithm also starts at a seed
     pixel known to be in the region's interior. It scans left and right to
     find the ends of the seed pixel's row, then fills the entire row.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 8-3.  A line-adjacency fill routine.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The algorithm proceeds by locating all groups of horizontally
     connected pixels that are vertically adjacent to the group it just
     scanned. Each time it finds an adjacent group of not-yet-filled
     pixels, LineAdjFill() is called recursively to fill them. The
     algorithm terminates when all interior pixels have been filled.

     Figure 8-4 illustrates the order in which LineAdjFill() fills a
     simple region comprising seven line segments. The seed pixel is
     assumed to lie inside line segment 1, and the routine is initially
     called with an upward search direction. The routine first searches the
     row of pixels above the seed (that is, line segment 2) for unfilled
     pixels. Because the row has not yet been filled, the routine is called
     recursively to fill it. Similarly, line segments 3 and 4 are filled by
     subsequent recursive calls to LineAdjFill(). At this point, neither
     line segment 4 nor line segment 3 has any unfilled pixels adjacent to
     it, but when the pixels below line segment 2 are scanned, line segment
     5 is discovered and filled. Finally, line segments 6 and 7 are filled
     recursively.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 8-4 is found on page 250       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 8-4.  Given a seed pixel in line segment 1, LineAdjFill() fills
     the adjacent line segments in this region in numerical order.


       ÉÍÍÍ»     A line-adjacency graph (LAG) is essentially a diagram of
       º T º     the connections between the adjacent line segments in the
       º I º     interior of a region (see Figure 8-5). The problem of
       º P º     filling a region is equivalent to traversing its LAG in
       ÈÍÍÍ¼     such a way that all nodes in the graph are visited. In
                 practice, traversing the LAG is relatively easy (there are
                 several textbook algorithms for graph traversal) compared
                 to generating the graph given only the pixels in the video
                 buffer (which is essentially what LineAdjFill() does). For
                 more information see "Filling Regions in Binary Raster
                 Images: A Graph-Theoretic Approach" by U. Shani (SIGGRAPH
                 Proceedings 1980, pp. 321-327).


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 8-5 is found on page 251       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 8-5.  A simple line-adjacency graph (LAG).


     LineAdjFill() is much more efficient than PixelFill(), because it
     rarely visits a pixel more than once to determine whether it needs to
     be filled. Each time the routine is called, it fills one line segment
     and then inspects the adjacent rows of pixels for unfilled pixels. The
     routine does not examine pixels that were inspected during the
     previous invocation of the routine (that is, pixels between PrevXL and
     PrevXR), nor does it inspect pixels to be filled by subsequent
     invocations (that is, pixels between the current value of x and the
     value returned from a call to LineAdjFill()). The recursive logic
     becomes clear when you trace the execution of the routine as it fills
     a region such as the one diagrammed in Figure 8-4.

       ÉÍÍÍ»     If you implement a line-adjacency fill algorithm in

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
       º T º     assembly language, you can improve its efficiency by
       º I º     maintaining a push-down stack of parameters and executing
       º P º     the function iteratively rather than recursively. The
       ÈÍÍÍ¼     skeleton of the algorithm then becomes

                 push ( .. initial parameters on stack .. );
                 while ( .. stack not empty .. )
                   LineAdjFill();

                 The fill routine pops the topmost parameters off the stack
                 and pushes new sets of parameters instead of calling
                 itself recursively.

                 LineAdjFill
                 {
                   pop ( .. current parameters off of stack .. )
                   .
                   .
                   .
                   if ( .. adjacent line needs to be filled .. )
                     push ( .. new parameters .. )
                 }

                 In assembly language, a single machine instruction can
                 perform each push and pop, so the algorithm's performance
                 is greatly improved.

     A line-adjacency algorithm can be adapted to fill a region with a
     pattern of pixels as well as with a single pixel value. For this
     reason, it is used commonly in commercial graphics packages. (IBM
     BASICA and Microsoft GW-BASIC are examples.) Modifying the algorithm
     to do patterned fills requires that the horizontal line-drawing
     routine be replaced with a pattern-drawing routine and that the test
     that determines whether a pixel has been filled take into account the
     pixel values in the fill pattern.

     These modifications may seem innocuous, but they can significantly
     degrade the fill routine's performance. The logic required to detect
     the presence of previously filled pixels can be complicated,
     particularly if you allow the fill pattern to contain pixels with the
     same value as border pixels.


Border Fill

     Because the border of a region defines the extent of its interior, it
     is possible to fill a region by following the connected border pixels
     at the ends of the adjacent line segments that make up the interior.
     (See "Contour Filling in Raster Graphics" by T. Pavlidis, Computer
     Graphics, August 1981, p. 29). As long as you fill the region at the
     same time that you trace the border, however, this kind of border-
     tracing fill algorithm offers no clear advantage over a line-adjacency
     algorithm.

     However, if you separate the problem of tracing the border from that
     of filling the region's interior, the resulting algorithm becomes more
     flexible. The process of filling a region then breaks down into three
     discrete steps:

     1)  Create an ordered list of the border pixels (trace the border).

     2)  Scan the interior of the region for holes.

     3)  "Connect the dots" in the list from left to right with horizontal
         lines, thereby filling the region.

     The routine BorderFill() in Listing 8-4 performs a region fill using
     this three-step method. The algorithm executes the three steps
     iteratively, once for the boundary of the region and once for each
     hole in the interior of the region.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 8-4.  A region fill routine that traces a region's
     border.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The module TraceBorder() creates a table that contains the pixel
     address  of every pixel in the region's border. SortBP() then sorts
     the table of border pixels by increasing y- and x-coordinates. The
     routine ScanRegion() examines the interior line segment between each
     pair of border pixels in the table. If it detects a border pixel
     within the line segment, ScanRegion() assumes it has encountered a
     hole in the region; it then returns the border pixel's (x,y)
     coordinates so that TraceBorder() and SortBP() can update the table
     with the hole's border pixels. This process continues until the entire
     interior of the region has been scanned. Then FillRegion() uses the
     sorted list of border pixels to fill the region by drawing a
     horizontal line between each pair of pixels in the list.

     TraceBorder() starts with a seed pixel on the right-hand border of the
     region. It steps clockwise from pixel to pixel in the border. Because
     the search proceeds clockwise, the interior of the region is always to
     the right of the direction in which the search is moving. If a pixel
     is not adjacent to the interior, the algorithm does not identify it as
     a border pixel. The algorithm ensures that the border pixels it
     detects are indeed adjacent to the interior by always examining pixels
     to the right of the search direction first.

     The algorithm identifies its search direction with one of the eight
     numeric codes shown in Figure 8-6. (This technique is taken from
     "Algorithms for Graphics and Image Processing" by T. Pavlidis
     [Computer Science Press, 1982].) Thus, in Figure 8-7, the algorithm
     moves from pixel b to pixel c in direction 6 (downward). To  find the
     next pixel in the border, the algorithm starts by examining the pixel
     to the right of direction 6; that is, direction 4. This pixel is not a
     border pixel, but the pixel in direction 5 (pixel d) is, so d is added
     to the list. The algorithm continues to trace the border until it
     returns to the starting pixel. (The search terminates immediately in
     the case of a degenerate "border" consisting of only one pixel.)

     TraceBorder() performs another task in addition to identifying the
     pixels in the border. It also indicates whether each border pixel
     defines the left or right endpoint of a horizontal interior line
     segment. (Because FillRegion() draws horizontal lines from left to
     right, TraceBorder() marks each border pixel with a flag indicating
     whether the pixel can be used as a left border.) Furthermore, if a
     pixel can serve as both a left and a right border (see Figure 8-8),
     TraceBorder() adds it to the table twice. The logic in SameDirection()
     and DifferentDirection() accomplishes these tasks.


     ÚÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄ¿
     ³       ³   2   ³       ³
     ³   3   ³       ³   1   ³
     ³      ³      ³      ³
     ³      \³   ³   ³/      ³
     ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄ´
     ³       ³       ³       ³
     ³  4 ÄÄ³       ³ÄÄ  0 ³
     ³       ³       ³       ³
     ÃÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄ´
     ³      /³   ³   ³\      ³
     ³      ³      ³      ³
     ³   5   ³       ³   7   ³
     ³       ³   6   ³       ³
     ÀÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÙ

     Figure 8-6.  Numeric codes for border pixel trace directions.


                     ÚÄÄÄ¿                  Direction
                     ³ a ³           ab        6
                    ÃÄÄÄÅÄÄÄ¿       bc        6
                     ³ b ³   ³       cd        5
                    ÃÄÄÄÅÄÄÄÙ       de        5
               /     ³ c ³           ef        4
                ÚÄÄÄÅÄÄÄ´           fg        4
               ³ d ³   ³
     ÚÄÄÄÂÄÄÄÂÄÄÄÅÄÄÄÅÄÄÄÙ
     ³ g ³ f ³ e ³   ³
     ÀÄÄÄÁÄÄÄÅÄÄÄÅÄÄÄÙ
             ³   ³
             ÀÄÄÄÙ

     Figure 8-7.  Border pixel identification in TraceBorder().


         ÚÄÄÄÂÄÄÄÂÄÄÄ¿                       ÚÄÄÄÂÄÄÄ¿
         ³   ³   ³   ³                       ³   ³   ³
     ÚÄÄÄÅÄÄÄÁÄÄÄÁÄÄÄÅÄÄÄ¿               ÚÄÄÄÅÄÄÄÁÄÄÄÅÄÄÄ¿
     ³   ³           ³   ³               ³   ³       ³   ³
     ÃÄÄÄ´           ÀÄÄÄÅÄÄÄÂÄÄÄÂÄÄÄÂÄÄÄÅÄÄÄÙ       ÃÄÄÄ´
     ³   ³               ³ a ³   ³   ³   ³           ³   ³
     ÃÄÄÄ´               ÀÄÄÄÁÄÄÄÁÄÄÄÁÄÄÄÙ           ÃÄÄÄ´
     ³   ³                                           ³   ³
     ÃÄÄÄ´                                           ÃÄÄÄ´
     ³   ³                                           ³   ³
     ÃÄÄÄ´                   ÚÄÄÄ¿                   ÃÄÄÄ´
     ³   ³                   ³ b ³                   ³   ³
     ÀÄÄÄÅÄÄÄ¿           ÚÄÄÄÅÄÄÄÅÄÄÄ¿           ÚÄÄÄÅÄÄÄÙ
         ³   ³           ³   ³   ³   ³           ³   ³
         ÀÄÄÄÅÄÄÄÂÄÄÄÂÄÄÄÅÄÄÄÙ   ÀÄÄÄÅÄÄÄÂÄÄÄÂÄÄÄÅÄÄÄÙ
             ³   ³   ³   ³           ³   ³   ³   ³
             ÀÄÄÄÁÄÄÄÁÄÄÄÙ           ÀÄÄÄÁÄÄÄÁÄÄÄÙ

     Figure 8-8.  Pixels may border the interior on the left, right, or
     both directions: Pixel a is a border pixel on the right of a
     row of interior pixels; it is blocked to its right by other border
     pixels. Pixel b serves as both a left and a right border.


     TraceBorder() may seem complex, but it is a relatively fast routine.
     The slowest steps in BorderFill() are actually SortBP(), which sorts
     the table of border pixels, and ScanRegion(), which searches for
     border pixels in the interior of the region. If SortBP() and
     ScanRegion() are slow, BorderFill() will be slow, because these
     routines are executed iteratively, once for each hole in the region.

     You can significantly improve BorderFill()'s performance by modifying
     TraceBorder() so that it builds its list of border pixels in the
     proper order to begin with, avoiding the sort altogether. You can
     build the ordered list efficiently using any of several data
     structures, including a linked list, a heap, or a fixed-size table.
     This type of modification is particularly effective when the algorithm
     is used to fill regions that contain one or more holes. Instead of
     sorting the list each time it detects a hole, the modified algorithm

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     simply inserts the hole's border pixels into the list.

     Writing ScanRegion() in a high-level language is relatively easy, but
     because the routine examines all pixels in the interior of the region,
     you should write it in assembly language so it will execute rapidly.
     Furthermore, using assembly language on the EGA, the VGA, and the
     InColor Card offers a distinct advantage, because the graphics control
     hardware in these subsystems can examine eight pixels at a time and
     indicate which, if any, match the border pixel value. The assembly-
     language routine ScanRight() in Listing 8-5, which can be used in EGA
     and VGA 16-color graphics modes, runs 50 times faster than the C
     version in Listing 8-4.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 8-5.  An assembly-language version of ScanRight().

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The fastest step in BorderFill() is the fill itself, because
     horizontal lines can be drawn rapidly. Thus, if you need to fill the
     same region repeatedly or to copy the same filled region several
     times, you can preserve the list of border pixels generated the first
     time you execute BorderFill(). This greatly accelerates subsequent
     fills, because you can skip the border-tracing and sorting steps.


Comparing the Algorithms


     Which region fill algorithm is best? Each algorithm described in this
     chapter has its pros and cons. You can compare them in several ways. A
     valid comparison considers the simplicity of the algorithm, the speed
     of the compiled code, and the suitability of each algorithm for
     particular types of region fills.

     The recursive, pixel-by-pixel algorithm implemented as PixelFill() is
     about as simple as you can get. The source code is short and easy to
     implement in assembly language as well as in a high-level language.
     However, PixelFill() is too inefficient and too highly recursive to be
     generally useful.

     The line-adjacency fill algorithm LineAdjFill() is more complicated
     than PixelFill(). Nevertheless, LineAdjFill() improves on the
     performance of PixelFill() because it examines pixel groups instead of
     individual pixels. LineAdjFill() also runs faster when it is written
     to access the video buffer in one-byte increments instead of one-pixel
     increments. LineAdjFill() is also much less recursive than
     PixelFill(), so its runtime memory requirements are smaller than those
     of PixelFill().

     The three-step algorithm implemented in BorderFill() is more
     complicated and somewhat slower than the other two algorithms. The
     advantage of using BorderFill() is its generality. Its modules can be
     readily adapted to alternate types of region fills, including pattern
     fills and fills of regions defined as numeric lists of (x,y)
     coordinates.

     The performance of BorderFill() depends on the number of holes in the
     region. It is as fast as LineAdjFill() in filling a region without
     holes. However, when the region to be filled looks like Swiss cheese,
     BorderFill() slows down because it must update the sorted list of
     border pixels whenever it fills around a hole.

     Nevertheless, BorderFill() can do several things that the other
     algorithms cannot. For example, it can reliably fill regions that
     contain previously filled pixels. Unlike BorderFill(), both
     PixelFill() and LineAdjFill() rely on the implicit assumption tht no
     interior pixels have the same value as the fill value. Thus,
     BorderFill() correctly fills the region shown in Figure 8-9, but both
     of the other routines fail.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 8-9 is found on page 264       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 8-9.  A test case for fill algorithms. Neither PixelFill() nor
     LineAdjFill() can correctly fill this region with gray pixels, because
     the "holes" are treated as if they have been already filled.


       ÉÍÍÍ»     You could modify a routine such as LineAdjFill() so that
       º T º     its detection of holes in the region does not depend on
       º I º     the presence of previously filled pixels. This means the
       º P º     algorithm must somehow keep track of pixels it has already
       ÈÍÍÍ¼     filled. One way to do this is to keep track of points
                 where the border reaches a local minimum or maximum (see
                 Figure 8-10). These locations can identify the top and
                 bottom of a hole in the region, enabling the fill
                 algorithm to determine when to stop working its way around
                 the hole.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 8-10 is found on page 265      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 8-10.  An algorithm can detect the presence of a hole in a
     region by locating the border's local maximum and minimum. Pixels
     marked a identify a local maximum. Pixels marked b identify a
     local minimum.


     For some applications, BorderFill() has a strong advantage over the
     other algorithms, because its border-tracing and sorting steps
     generate a list of numeric pixel coordinates. This list completely
     defines a two-dimensional region of pixels. You can translate or
     change the scale of the region by applying the appropriate conversions
     to the list of border pixels. As long as you preserve the pixels'
     order in the list, you can use the FillRegion() routine in
     BorderFill() to fill the region the list defines. For this reason, the
     BorderFill() algorithm is best suited for applications that must copy
     arbitrary regions, change their scale or size, or draw them repeatedly
     into the video buffer.

     Furthermore, by modifying the horizontal line routine in BorderFill()
     you can easily fill a region with an arbitrary pattern or allow pixel
     AND, OR, and XOR functions. Although you can augment PixelFill() or
     LineAdjFill() in this way, the source code can become complicated
     because these algorithms inspect pixels to determine whether they have
     been filled.

     The trade-offs in complexity and performance in these algorithms leave
     a great deal to your programming judgment. No single region fill
     algorithm is best for all possible graphics applications. Your choice
     of implementation should depend on your performance demands, the
     requirements of the application itself, the capabilities of your video
     display hardware, and the effort you can afford to expend in
     integrating and optimizing the code.



                         9  Graphics Text


                     Character Definition Tables
                         Video BIOS Support
                Creating a Character Definition Table

                    Software Character Generators
                 Video BIOS Support ş Pixel Handling

              Designing a Software Character Generator
                        Horizontal Alignment
                 Variable Character Sizes ş Clipping
                        Character Orientation
                   Cooperating with the Video BIOS
                     More Power, More Complexity

             Implementing a Software Character Generator
                      CGA ş HGC and HCG+ ş MCGA
                     EGA and VGA ş InColor Card



     Few programs are complete without some sort of text display. Most
     graphics applications incorporate text with graphics images. In
     graphics modes, the software that draws characters requires the same
     thoughtful design and construction as do routines that draw geometric
     figures such as lines and ellipses.

     In alphanumeric video modes, of course, displaying text is easy. You
     simply place a character code and attribute in the video buffer and
     let the hardware character generator put pixels on the screen. In
     graphics modes, however, your program must store every pixel of every
     character in the video buffer.

     This chapter discusses how to translate character codes into the pixel
     patterns that form characters in graphics modes. The programming
     examples are hardware-specific, of course, but you can adapt the
     table-driven character generator described here for use with other
     computers and in other graphics applications.


Character Definition Tables


     Every character that an IBM video subsystem displays is made up of a
     pattern of contiguous pixels. The pixels are arranged to appear as
     coherent, recognizable characters on the screen. The pixel pattern
     that represents a character is the same no matter where in the buffer
     or on the screen the character is located.

     The most convenient way to describe the pixel patterns that represent
     the characters in a character set is to create a table in which bit
     patterns represent the pixel patterns. Such a character definition
     table contains a bit pattern for every displayable character (see
     Figure 9-1). Each character's bit pattern is defined within a
     rectangular matrix. When the character matrix is the same size for all
     characters in the table, and the definitions in the table are
     organized by character code, converting a character code to an offset

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     into the table is easy.

     You can use a character definition table formatted in this way in
     alphanumeric as well as graphics modes in video subsystems that
     support RAM-based alphanumeric character definitions. Chapter 10
     covers this topic in detail.


                                           Hex    Binary  ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
                                       ÚÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                                       ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                                       ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA6E  00 00 00 00 00 00 00 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   A5    10100101 ³Û³ ³Û³ ³ ³Û³ ³Û³
FOOO:FA76 ³7E 81 A5 81 BD 99 81 7E                        ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
          ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FA7E  7E FF DB FF C3 E7 FF 7E     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA86  6C FE FE FE 7C 38 10 00     ³   B0    10111101 ³Û³ ³Û³Û³Û³Û³ ³Û³
FOOO:FA8E  10 38 7C FE 7C 38 10 00     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FA96  38 7C 38 FE FE 7C 38 7C     ³   99    10011001 ³Û³ ³ ³Û³Û³ ³ ³Û³
FOOO:FA9E  10 10 38 7C FE 7C 38 7C     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
FOOO:FAA6  00 00 18 3C 3C 18 00 00     ³   81    10000001 ³Û³ ³ ³ ³ ³ ³ ³Û³
FOOO:FAAE  FF FF E7 C3 C3 E7 FF FF     ³                  ÃÄÅÄÅÄÅÄÅÄÅÄÅÄÅÄ´
                    .                  ÀÄÄÄ7E    01111110 ³ ³Û³Û³Û³Û³Û³Û³ ³
                    .                                     ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
                    .

     Figure 9-1.  The beginning of the bit patterns that define IBM's ROM
     BIOS 8-by-8 character definitions.


Video BIOS Support

     The PC and PS/2 ROM BIOS contains default character definition tables
     for use in graphics modes. The size of the characters in the table
     depends on the vertical resolution of the video mode. In 200-line,
     CGA-compatible video modes, the default character matrix is 8 pixels
     wide and 8 pixels high; in 350-line graphics modes, it is 8 wide by 14
     high; in 400-line and 480-line modes, it is 8 by 16. In all graphics
     modes, the default characters are 8 pixels wide simply because there
     are 8 bits in a byte. Because each byte in a character definition
     table represents 8 horizontal pixels, defining characters as a
     multiple of 8 pixels in width makes the table easy to manipulate in
     software.

     No equivalent constraint applies to the height of characters defined
     in a character definition table. In practice, however, the character
     matrix used with IBM video subsystems should rarely be smaller than 8
     by 6 pixels or larger than 8 by 16 pixels. With a character matrix
     outside this range, the displayed height and width of the characters
     become disproportionate and the characters tend to appear too short or
     too elongated to be easily read.


     Default CGA Characters
     Figure 9-1 shows the beginning of the character definition table for
     the default character set in CGA graphics modes. The table contains an
     8-byte definition for each of the first 128 ASCII characters (0
     through 7FH). The first eight bytes of the table correspond to
     character code 0, the second eight bytes to character code 1, and so
     forth. The bit pattern in each group of eight bytes represents the
     pixel pattern displayed for the corresponding row of pixels in the
     character. The first of the eight bytes in each group corresponds to
     the topmost row of eight pixels.

     This table of 8-by-8 character definitions is located at F000:FA6E in
     the motherboard ROM on all PCs and PS/2s. However, the table defines
     only the first 128 ASCII characters. Character definitions for the
     second group of 128 ASCII codes (80H through 0FFH) are found in a
     table whose address is stored in interrupt vector 1FH (0000:007C).
     Because the motherboard BIOS contains no definitions for these
     characters, the address is initialized to 0000:0000. If you use the
     ROM BIOS to display ASCII characters between 80H and 0FFH in CGA
     graphics modes without pointing this interrupt vector to a character
     definition table, the "characters" you see on the screen are whatever
     binary patterns happen to lie in the first 1024 bytes of RAM.

       ÉÍÍÍ»     The MS-DOS utility GRAFTABL leaves a table of definitions
       º T º     for characters 80H through 0FFH resident in RAM and
       º I º     updates the interrupt 1FH vector to point to it. The
       º P º     characters defined in GRAFTABL are the same as those the
       ÈÍÍÍ¼     alphanumeric character generator displays for ASCII codes
                 80H through 0FFH.


     Default EGA, VGA, and MCGA Characters
     The ROM BIOS in the EGA, VGA, and MCGA subsystems contains definitions
     for all 256 ASCII codes for all graphics modes. (You can access these
     tables directly; their addresses may be obtained by calling INT 10H
     function 11H with AL = 30H.) When you select a graphics mode with INT
     10H function 0, the video BIOS loads the address of the appropriate
     character definition table for the graphics mode into interrupt vector
     43H (0000:010C). In CGA-compatible 200-line graphics modes, the BIOS
     also points the interrupt 1FH vector to the definitions for characters
     80H through  0FFH.


Creating a Character Definition Table

     The easiest way to obtain a character definition table is to use one
     of the default BIOS tables. If the staid, placid characters in those
     tables aren't to your liking, you can find many others commercially
     available or in the public domain.

       ÉÍÍÍ»     Several standard character sets are defined and registered
       º T º     with the International Standards Organization (ISO). IBM
       º I º     refers to these character sets as code pages and has
       º P º     assigned arbitrary identification numbers to them. For
       ÈÍÍÍ¼     example, the standard IBM PC ASCII character set is
                 designated by code page 437; the Canadian French code page
                 is 863; and code page 850 is the general-purpose
                 "multilingual" character set devised by IBM for languages
                 that use a Latin alphabet.

                 Both MS-DOS (starting in version 3.3) and OS/2 allow
                 applications to switch between code pages on an EGA or
                 VGA. When a program displays characters with operating
                 system function calls, the operating system uses the
                 character definitions in the currently selected code page.
                 Applications that use foreign language character sets
                 should, whenever possible, exploit the code pages
                 supported by the operating system.


     When you define your own character set, you can select among several
     alternative methods. The ugly alternative is to build your character
     definition table by specifying every byte in source code. Figure 9-2
     shows the beginning of such a table. A more elegant alternative is to
     use a character-set editing program. With such editors, you use
     cursor-control keys or a pointing device such as a light pen or mouse
     to specify the bit patterns in the table. Character-set editors are
     also available both commercially and in the public domain. (You can
     even write your own, using the routines in this book.)

     Another approach is to start with one of the BIOS character sets and
     transform the bit patterns in a regular way. For example, you could
     reverse the bit patterns in a table by converting 0s to 1s and 1s to
     0s (that is, apply a bitwise logical NOT to each byte in the table),
     thus creating a "reverse" character set.


     CharDefs    db   000h,000h,000h,000h,000h,000h,000h,000h ; character 0
                 db   03Ch,066h,0C0h,0C0h,0C0h,066h,03Ch,000h ; character 1
                 db   0FCh,066h,066h,07Ch,06Ch,066h,0E6h,000h ; character 2
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 3
                 db   078h,0CCh,0CCh,078h,0CCh,0CCh,078h,000h ; character 4
                 db   078h,030h,030h,030h,030h,030h,078h,000h ; character 5
                 db   0CCh,0CCh,0CCh,0CCh,0CCh,078h,030h,000h ; character 6
                 db   0FEh,062h,068h,078h,068h,062h,0FEh,000h ; character 7
                                      .
                                      .
                                      .

     Figure 9-2.  A hand-coded character definition table.


Software Character Generators


     A software routine that uses the bit patterns in a character
     definition table to draw characters in the video buffer is called a
     software character generator. A software character generator performs
     several functions. It locates the bit pattern for a given character
     code, translates the bit pattern into a corresponding pattern of
     pixels, and updates pixels at a specified location in the video
     buffer.


Video BIOS Support

     The video BIOS provides a software character generator that is used
     whenever INT 10H functions 09H, 0AH, 0EH, and 13H are called in
     graphics modes. The software character generator in the IBM PC and AT
     uses only the 8-by-8 characters defined at F000:FA6E and at the
     address indicated by interrupt vector 1FH. The version in the EGA and
     PS/2 BIOS uses the table to which interrupt vector 43H points; this
     version determines the height of displayed characters from the BIOS
     variable POINTS at 0040:0085.

     You can use the BIOS software character generator to display
     characters from any character definition table by updating the
     appropriate interrupt vectors with the address of the table. On the
     EGA and PS/2s, use INT 10H function 11H to do this.

     The BIOS character generator is convenient to use, but it is somewhat
     limited in its capabilities. In particular, it can only store byte-
     aligned characters in the video buffer. If you are willing to
     sacrifice compatibility with the INT 10H interface, you can write a
     faster software character generator that is more powerful than the
     default video BIOS version.


Pixel Handling

     You store characters in the video buffer by changing the values of the
     appropriate pixel groups. You can update the video buffer simply by
     replacing old pixel values with new ones. You can also perform bitwise
     logical operations (AND, OR, or XOR) to update the pixels.

     Your routine to display text in graphics modes can handle the

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     background pixels in the character matrix in one of two ways. One is
     to preserve the contents of the video buffer as much as possible by
     updating only foreground pixels; that is, by updating only those
     pixels that represent the character itself (see Figure 9-3a). The
     other is to update all foreground and background pixels within the
     bounds of the rectangular character matrix (see Figure 9-3b).


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-3 is found on page 272       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-3.  Characters written without background pixels (a.) and
     with background pixels (b.).


     Updating only the character's foreground pixels preserves as many
     pixels in the video buffer as possible. This may be the best way to
     display text in front of a detailed or patterned graphics image.
     However, reading the displayed characters can be difficult if the
     graphics image in some way blends with the character. For example,
     text is invisible against a region filled with pixels having the same
     value as the character's foreground pixels.

     To avoid such problems, you can update all foreground and background
     pixels in the character matrix each time you store a character in the
     buffer. This avoids a background pattern inadvertently masking the
     characters. The trade-off is that each time you store a character in
     the buffer you must replace the previous contents of the buffer with a
     rectangular blot.

     The source code for the two types of graphics text routines is
     similar. The examples in this chapter demonstrate the second type,
     which makes them more complicated than routines that draw only
     foreground pixels. You can convert the routines to draw only the
     foreground pixels by eliminating the code for incorporating the
     background pixels.


Designing a Software Character Generator


     Software character generators for IBM PC video subsystems have a
     number of design considerations in common. Because the performance of
     your character generator strongly influences the overall performance
     of many graphics applications, always consider the trade-offs between
     function and simplicity in your character generator routines.


Horizontal Alignment

     In graphics modes, the left edge of a character is not necessarily
     byte-aligned. When a character is written so that its leftmost pixels
     fall somewhere in the middle of a byte in the video buffer (see Figure
     9-4a), the character generator must shift and mask the character
     matrix so that only pixels that are part of the character are updated.

     Usually, however, characters are written into the video buffer at
     byte-aligned pixel addresses (see Figure 9-4b). This is the case, for
     example, whenever the display is used in a "teletype mode"; that is,
     when each line of characters starts at the left edge of the display.
     Generating byte-aligned characters requires no rotation or masking of
     pixels, so using a separate routine for byte-aligned characters
     improves the character generator's performance.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 9-4 is found on page 273       º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 9-4.  Alignment of characters in the video buffer. In Figure
     9-4a, characters are not aligned; in Figure 9-4b, characters are byte-
     aligned.


Variable Character Sizes

     Writing a character generator that accommodates characters of
     different heights is relatively easy. The height of a character
     corresponds to the number of bytes in its definition in the character
     definition table. You can thus use the height of your characters as a
     loop limit inside the character generator routine without
     significantly affecting the complexity of the routine.

     Handling characters of different widths is more difficult. If the
     width of a character does not fit exactly into an integer number of
     bytes, you must mask each row of pixels in the character as you store
     it in the video buffer. Again, the extra overhead of forming the
     appropriate bit mask and masking pixels in the video buffer
     complicates and slows the character generator routine.


Clipping

     You can clip characters in several ways. The simplest is to clip the
     entire character before you store it in the video buffer; if any
     portion of the character matrix would lie outside the clipping area,
     don't write the character.

     Clipping a character so that only a portion of it is stored in the
     video buffer is more difficult. One way to do this is to modify the
     character generator so that any clipped portion of a character is not
     written to the buffer. Another approach is to write the entire
     character into an auxiliary buffer and then copy the clipped character
     into the video buffer with a pixel block copy routine (see Chapter
     11).


Character Orientation

     Usually, characters are displayed so that they can be read from left
     to right and from the top down. To change this orientation, apply the
     appropriate transformation to the bit patterns in the character
     definition table. For example, the subroutine in Listing 9-1 rotates
     the 8-byte bit pattern that represents an 8-by-8 character so that the
     displayed characters read upward. With this transformation, you can
     use the same character generator to display vertically or horizontally
     oriented characters. Only the bit patterns differ.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-1.  A routine that rotates an 8-by-8 character
     definition by 90 degrees.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Cooperating with the Video BIOS

     Even if your character definition tables and character generator
     software avoid using video BIOS functions, you should nevertheless try
     to preserve compatibility by cooperating with the BIOS routines when
     possible. In 200-line graphics modes, you should update the address in
     interrupt vector 1FH whenever you use an 8-by-8 character definition
     table that includes the second 128 ASCII characters. On the EGA, VGA,
     and MCGA, you should generally use INT 10H function 11H to keep the
     BIOS interrupt vectors and Video Display Data Area variables up to
     date.


More Power, More Complexity

     You can add functionality to a software character generator in several
     ways. You might, for example, write a character generator that refers
     to a table of relative character widths to display proportionally
     spaced characters. As your routine reads bit patterns from the
     character definition table, you might have it shift them to the right
     by a predetermined number of pixels to generate bold or italic
     character sets. You might apply a pattern of pixel values to the
     foreground pixels you update. You might allow a character definition
     table to extend beyond the usual range of 256 characters; the more
     characters you define, the wider range of characters you can display
     at one time. Any of these possibilities adds power and flexibility to
     your software character generator, but all of them complicate your
     source code and ultimately slow it down.


Implementing a Software Character Generator


     All software character generator examples in this chapter require that
     you specify the x- and y-coordinates of the pixel in the upper left
     corner of the displayed character matrix. Each routine detects the
     special case where the character matrix is byte-aligned in the video
     buffer, but the routines do not validate pixel coordinates or perform
     any clipping. All the routines except DisplayChar10() update pixels in
     the video buffer by replacing their values. To perform a bitwise AND,
     OR, or XOR operation, you must modify the routines (see Chapter 5).


CGA

     In 640-by-200 2-color mode on the CGA, the software character
     generator applies the bit patterns in the character definition table
     directly to the pixels in the video buffer (see Listing 9-2). When
     the character is byte-aligned in the video buffer, the routine copies
     pixel values directly from the character definition table. Otherwise,
     for each row of eight pixels in the character, a rotated 16-bit mask
     is used to zero the proper eight pixels in the buffer. Then the pixels
     from the character definition table are rotated into position and
     stored in the buffer using a bitwise OR operation.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-2.  A software character generator for 640-by-200 2-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The routine for 320-by-200 4-color mode in Listing 9-3 is more
     complicated because each bit in the character definition must be

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     expanded into the appropriate 2-bit pixel value. A 0 bit in the
     character definition table becomes a 2-bit background pixel value; a
     1 bit in the table is expanded into a 2-bit foreground pixel value.
     Thus, each byte in the table is transformed into a word of pixels.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-3.  A software character generator for 640-by-200
     4-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In Listing 9-3, when the character is byte-aligned in the video
     buffer, the routine moves the 16-bit word of pixels directly into the
     buffer. A character that is not byte-aligned spans three bytes in the
     buffer. In this case, the routine must rotate the eight pixels in each
     row of the character into position. Then the first two bytes of the
     character in the buffer are masked and updated, followed by the third
     (rightmost) byte of the character.


HGC and HGC+

     A routine for the 720-by-348 monochrome graphics mode on the HGC and
     the HGC+ can use the same bit-masking technique that the CGA 640-by-
     200 2-color routine uses. You could convert DisplayChar06() into a
     Hercules-compatible routine by revising the call to PixelAddr06() and
     by changing video buffer addressing to accommodate the different
     buffer interleaves on the two adapters.

     It is worthwhile, however, to exploit the HGC's 720-pixel horizontal
     resolution by displaying characters in a matrix that is 9 pixels wide,
     so that each row on the screen contains 80 evenly spaced characters.
     The routine in Listing 9-4 does this by appending a ninth bit to each
     8-bit pattern it reads from the character definition table. The
     ninth bit is 0 except for box-drawing characters (ASCII 0C0-0DFH).
     For these characters, the ninth bit is a copy of the rightmost
     bit in the bit pattern. (This mimics the function of the hardware
     character generator in alphanumeric modes. See Chapter 10.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-4.  A software character generator for Hercules monochrome
     graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     Note how the CGA and Hercules routines use interrupt
       º T º     vector 43H to point to the start of the current character
       º I º     definition table. This is the interrupt vector the EGA and
       º P º     VGA ROM BIOS uses for this purpose. Also, the routines
       ÈÍÍÍ¼     determine the size of the displayed character matrix by
                 inspecting the variables POINTS (0040:0085) and CRT_COLS
                 (0040:004A) in the BIOS Video Display Data Area. If you
                 are not using an EGA, MCGA, or VGA, the BIOS won't keep
                 the interrupt vector and POINTS up to date; in this case,
                 your program should either update these values explicitly
                 or maintain equivalent values elsewhere.


MCGA

     In 640-by-480 2-color mode on the MCGA, pixels are stored eight to a
     byte, so you can adapt the 640-by-200 2-color character generator for
     use in this mode by modifying its video buffer addressing. A character
     generator for 320-by-200 256-color mode is a little different, because
     each bit in the character definition table expands into a byte in the
     video buffer (see Listing 9-5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-5.  A character generator for MCGA and VGA 320-by-200 256-
     color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


EGA and VGA

     The routine for the EGA and VGA in Listing 9-6 uses the Graphics
     Controller to update pixels in the video buffer. The routine is
     similar in some ways to the routine for the CGA's 640-by-200 2-color
     mode, because each byte of the video buffer represents eight pixels.
     Of course, the code is complicated by the need to program the Graphics
     Controller to handle the foreground and background pixel values.

     The routine writes each row of pixels in the character by latching the
     bit planes, updating the foreground pixels, updating the background
     pixels, and then writing the latches back to the bit planes. The
     Graphics Controller cannot conveniently update both foreground and
     background pixels at the same time, so the routine must perform these
     operations separately.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-6.  A software character generator for native EGA and VGA
     graphics modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


InColor Card

     The technique for storing characters in the video buffer on the
     Hercules InColor Card, shown in Listing 9-7, is different from that
     on the EGA or VGA because you can use the InColor Card's Read/Write
     Color register (1AH) and write mode 0 to update both foreground and
     background pixel values in one operation. Thus, the actual process of
     updating the bit planes collapses into relatively few machine
     instructions.

     However, the InColor Card cannot perform pixel AND, OR, or XOR
     operations in hardware. To do this, you must write additional
     subroutines that use the Plane Mask register to map logical operations
     onto the bit planes (see Chapter 5).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 9-7.  A software character generator for Hercules InColor
     graphics modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



                   10  Alphanumeric Character Sets


                     Character Definition Tables
              Alphanumeric Character Definitions in ROM
              Alphanumeric Character Definitions in RAM

                  Updating Character Generator RAM
              EGA and VGA ş HGC+ ş InColor Card ş MCGA

                   Using RAM-based Character Sets
                        ASCII Character Sets
                       Extended Character Sets
        Compatibility Problems with Extended Character Codes

               Changing the Displayed Character Matrix
              EGA ş VGA ş MCGA ş HGC+ and InColor Card

               Graphics Windows in Alphanumeric Modes
             HGC+ and InColor Card ş EGA and VGA ş MCGA



     One of the easiest ways to speed up a program's video interface is to
     use an alphanumeric video mode. To gain this speed advantage, however,
     you must accept the limitations of the video subsystem's alphanumeric
     character generator. 

     On the original MDA and CGA, the only characters you could display in
     alphanumeric mode were those defined in a table located in ROM on the
     adapter. The hardware character generator on these adapters was not
     designed to use a character definition table located in RAM. However,
     the EGA, the MCGA, the VGA, the HGC+, and the InColor Card can all
     display alphanumeric characters defined in RAM.

     This chapter shows you how to exploit RAM-based alphanumeric character
     sets on these subsystems. It describes how to format character
     definition tables and where to place them in RAM to be used in
     alphanumeric modes. It discusses the pros and cons of using extended
     character sets that contain more than the usual 256 ASCII characters.
     The chapter concludes with techniques for displaying true graphics
     images in an alphanumeric video mode.


Character Definition Tables


     Like the software graphics character generators described in Chapter
     9, the hardware alphanumeric character generator in all IBM video
     subsystems references a memory-resident character definition table
     that contains bit-pattern representations of the pixels in each
     displayable character. Unlike the graphics-mode tables, whose location
     in memory may vary, the alphanumeric tables must lie in a
     predesignated portion of memory to allow the alphanumeric character
     generator to access them.


Alphanumeric Character Definitions in ROM

     The MDA, the CGA, and the Hercules adapters have an alphanumeric
     character definition table located in ROM that is not within the CPU's
     address space. Only the character generator hardware can access it.
     The character set that these adapters display in alphanumeric modes is
     therefore not controlled by software.

     On the EGA, the MCGA, and the VGA, the alphanumeric character
     generator uses a table of bit patterns stored in RAM rather than in
     dedicated ROM. The video ROM BIOS contains tables with which it

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     initializes character generator RAM whenever it establishes an
     alphanumeric video mode. Because these video subsystems can set up
     alphanumeric modes with different vertical resolutions, the sizes of
     the default alphanumeric characters vary (see Figure 10-1).


     200-Line Modes
     The CGA's 200-line alphanumeric modes use an 8-by-8 character matrix.
     In  80-by-25 alphanumeric mode, the screen is thus 640 pixels wide; in
     40-by-25 alphanumeric mode, the screen is 320 pixels wide. Although
     the CGA uses the same character set and font in its alphanumeric and
     graphics modes, the character definitions for alphanumeric modes
     reside in dedicated ROM, accessible only to the hardware character
     generator. (As described in Chapter 9, the graphics-mode definitions
     are found in the ROM BIOS and in a table in RAM addressed by the
     vector for interrupt 1FH.)


                                    Character Matrix
Adapter      Video Mode             (width by height in pixels)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA, HGC     Monochrome             9-by-14
CGA          40-by-25 16-color      8-by-8
             80-by-25 16-color      8-by-8
EGA          80-by-25 16-color      8-by-8  (200-line resolution)
                                    8-by-14 (350-line resolution)
             80-by-25 monochrome    9-by-14
MCGA         40-by-25 16-color      8-by-16
             80-by-25 16-color      8-by-16
VGA          40-by-25 16-color      8-by-8  (200-line resolution)
                                    8-by-14 (350-line resolution)
                                    9-by-16 (400-line resolution)
             80-by-25 16-color      8-by-8  (200-line resolution)
                                    8-by-14 (350-line resolution)
                                    9-by-16 (400-line resolution)
             80-by-25 monochrome    9-by-14 (350-line resolution)
                                    9-by-16 (400-line resolution)
HGC+         80-by-25 monochrome    9-by-14
InColor Card 80-by-25 16-color      9-by-14
     Figure 10-1.  The default alphanumeric character matrix in various
     video modes.


       ÉÍÍÍ»     The CGA comes with two tables of 8-by-8 characters in the 
       º T º     alphanumeric character generator's ROM. A jumper on the 
       º I º     adapter selects which table the alphanumeric character 
       º P º     generator uses. By default, jumper P3 on the CGA is not 
       ÈÍÍÍ¼     connected, and the usual "double-dot" 8-by-8 characters 
                 are displayed. If you connect jumper P3, the CGA's 
                 alphanumeric character generator uses a "single-dot" font 
                 (see Figure 10-2). The "single-dot" characters appear 
                 sharper on some monitors because their vertical strokes 
                 are only one pixel wide.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 10-2 is found on page 299      º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 10-2.  Double-dot and single-dot alphanumeric character sets on
     the CGA.


     350-Line Modes
     In 350-line alphanumeric modes on the MDA and the Hercules adapters,
     the characters are defined in an 8-by-14 matrix. Again, the character
     definition table resides in ROM outside the CPU address space that is
     dedicated to the hardware character generator. Because the horizontal
     resolution is 720 pixels on these adapters, each 8-by-14 character
     actually is displayed in a matrix 9 pixels wide. Thus, each row on the
     screen contains 720/9, or 80, characters.

     If characters are defined in ROM in an 8-by-14 matrix but displayed in
     a 9-by-14 matrix, where does the extra pixel come from? The hardware
     character generator in the MDA, the Hercules cards, the EGA, and the
     VGA (in monochrome mode) adds an extra pixel to the right of each row
     of eight pixels in each character. For the block graphics characters
     (ASCII 0C0H through 0DFH), the value of the rightmost pixel is
     replicated in each row. For all remaining character codes, the extra
     pixel is displayed with the character's background attribute.

     Since the ninth (rightmost) pixel in block graphics characters is a
     copy of the eighth, these characters abut and can be used to draw
     horizontal lines. All other displayable characters are separated from
     each other by that ninth pixel. The resulting display appears less
     crowded than it would be without the extra space.

       ÉÍÍÍ»     With the EGA and the VGA, you can control whether or not 
       º T º     the alphanumeric character generator replicates the eighth 
       º I º     pixel of block graphics characters. When bit 2 of the 
       º P º     Attribute Controller's Mode Control register (10H) is set 
       ÈÍÍÍ¼     to 1, the ninth pixel is the same as the eighth. When bit 
                 2 is set to 0, the ninth pixel is a background pixel.


     400-Line Modes
     The default alphanumeric modes of both the MCGA and the VGA have 400-
     line vertical resolution. The characters used in these modes are
     defined in an 8-by-16 matrix. On the VGA, the 8-by-16 characters are
     displayed in a 9-by-16 matrix, just as on an MDA or an EGA with a
     monochrome display.


Alphanumeric Character Definitions in RAM

     The EGA, the VGA, the MCGA, the HGC+, and the InColor Card all have
     alphanumeric character generators that use character definition tables
     located in predesignated areas of RAM. In all these subsystems, this
     RAM lies within the address space of the video buffer. If you know how
     character generator RAM is mapped, you can write programs that read or
     update the alphanumeric character definition tables and thereby change
     the displayed alphanumeric character set.


     EGA and VGA
     In alphanumeric modes on the EGA and the VGA, the video buffer is
     organized as four parallel memory maps, just as in graphics modes. In
     alphanumeric modes, however, only maps 0 and 1 contain displayable
     data (see Figure 10-3). Even-numbered bytes (character codes) in the
     CPU's address space are located in map 0, and odd-numbered bytes
     (attribute bytes) are located in map 1. This mapping is invisible to
     the CPU; the CRTC internally translates odd addresses to offsets into
     map 1 and even addresses into references to map 0.


                           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                           ³                       ³
                           ³                       ³
                       ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³
                       ³ Character definitions ³   ³
                       ³                       ³   ³
                   ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³   ³
                   ³    Attribute bytes    ³   ³   ³
                   ³                       ³   ³   ³
               ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³   ³   ³
               ³    Character codes    ³   ³   ³   ³
               ³                       ³   ³   ÃÄÄÄÙ Map 3
               ³                       ³   ³   ³
               ³                       ³   ³   ³
               ³                       ³   ÃÄÄÄÙ Map 2
               ³                       ³   ³
               ³                       ³   ³
               ³                       ÃÄÄÄÙ Map 1
     B800:0000 ³                       ³
        or     ³                       ³
     B000:0000 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ Map 0    

     Figure 10-3.  Video RAM layout in EGA and VGA alphanumeric modes.


     The alphanumeric character generator uses a set of 256-character
     tables stored in map 2. The EGA supports four such tables (see Figure
     10-4); the VGA supports eight (see Figure 10-5). Each table consists
     of 256 32-byte bit patterns, so the maximum height of the character
     matrix is 32 scan lines. When the displayed character matrix contains
     fewer than 32 lines, the character generator ignores the extra bytes
     in each character definition.

     On the EGA, each of the four alphanumeric character definition tables
     starts at a 16 KB boundary. Since only 8 KB (256 characters * 32 bytes
     per character) are used, 8 KB of unused RAM follows each table. On the
     VGA, these unused areas in map 2 can contain additional character
     definitions. Of course, in writing an application that must run on
     both the EGA and the VGA, you should avoid using these extra tables
     because the EGA does not support them.

       ÉÍÍÍ»     On the IBM EGA, which may be equipped with less than 256 
       º T º     KB of video RAM, the number of character definition tables 
       º I º     you can load into video RAM depends on the amount of RAM 
       º P º     installed on the card. For example, without IBM's Graphics 
       ÈÍÍÍ¼     Memory Expansion Card, an IBM EGA has only 64 KB of video 
                 RAM, so each video memory map in alphanumeric modes 
                 contains only 16 KB, and only one character definition 
                 table will fit in map 2.


                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³          (Unused)           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             C000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³          (Unused)           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
     Offset  8000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³          (Unused)           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             4000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³          (Unused)           ³
                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             0000H ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 10-4.  Character generator RAM in EGA video memory map 2.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³  256 character definitions  ³
             E000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             C000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             A000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
     Offset  8000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             6000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             4000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             2000H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                   ³  256 character definitions  ³
             0000H ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 10-5.  Character generator RAM in VGA video memory map 2.


     HGC+
     Character generator RAM on the HGC+ starts at B000:4000 and extends to
     the end of available video RAM at B000:FFFF (see Figure 10-6). You can
     fill this entire 48 KB area with character definitions. Each character
     definition is 16 bytes long, so a table that defines 256 characters
     occupies 4 KB. Thus, this RAM can hold 3072 character definitions.


     B000:FFFF ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
               ³                                ³
               ³      Character definitions     ³
               ³                                ³
               ³                                ³
     B000:4000 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
               ³ Character codes and attributes ³
     B000:0000 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 10-6.  Video RAM layout in alphanumeric modes on the HGC+.


       ÉÍÍÍ»     If the HGC+ is configured so that video RAM above
       º T º     B000:8000 is masked out of the CPU address space (that is,
       º I º     bit 1 of the Configuration Switch at 3BFH is set to 0),
       º P º     then only the 16 KB of RAM between B000:4000 and B000:7FFF
       ÈÍÍÍ¼     can be used for character definitions.


     InColor Card
     Character generator RAM occupies the same range of addresses on the
     InColor Card as on the HGC+, that is, B000:4000 through B000:FFFF.
     Also, each InColor character definition is 16 bytes long. Unlike the
     HGC+, however, the 16-color InColor Card uses all four bit planes in
     this range of addresses for character definitions (see Figure 10-7).

     Because of this, you can control the value of each pixel in each
     character you define. You can also program the InColor Card so that
     different bit planes define different characters; when the characters
     are displayed, their attribute bytes select which bit plane is used.
     By loading each of the four bit planes with different character
     definitions, you can maintain as many as 12,288 (3072 x 4) character
     definitions in RAM. Or, to preserve compatibility with the HGC+, you
     can load all four bit planes with the same bit patterns.

       ÉÍÍÍ»     In using both the EGA and the Hercules cards, be careful 
       º T º     in changing from an alphanumeric mode that uses a RAM-
       º I º     based character definition table to a graphics mode. The 
       º P º     same RAM that contains pixel data in graphics modes is 
       ÈÍÍÍ¼     used to store character definitions in alphanumeric modes. 
                 You can corrupt or erase your character definition tables 
                 by updating the video buffer in a graphics mode and then 
                 returning to an alphanumeric mode.


     MCGA
     Unlike the EGA and VGA, the MCGA has no parallel memory maps in which
     to store character definitions. Instead, alphanumeric character
     definitions are maintained in the 32 KB of video RAM between A000:0000
     and A000:7FFF. You can store as many as four 8 KB character definition
     tables at A000:0000, A000:2000, A000:4000, and A000:6000 (see Figure
     10-8).


                           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                           ³                       ³
                           ³ Character definitions ³
                       ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³
                       ³                       ³   ³
                       ³ Character definitions ³   ³
                   ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÃÄÄÄ´
                   ³                       ³   ³   ³
                   ³ Character definitions ³   ³   ³
               ÚÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ÃÄÄÄ´   ³
               ³                       ³   ³   ÃÄÄÄÙ Bit plane 3
               ³ Character definitions ³   ³   ³
               ³                       ÃÄÄÄ´   ³
               ³                       ³   ÃÄÄÄÙ Bit plane 2
               ³                       ³   ³
     B800:4000 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³   ³
               ³                       ÃÄÄÄÙ Bit plane 1
               ³    Character codes    ³
               ³    and attributes     ³
     B000:0000 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ Bit plane 0

     Figure 10-7.  Video RAM layout in alphanumeric modes on the Hercules
     InColor Card. Character definitions start at B000:4000 in all four bit
     planes.


                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³                                ³
                ³ Character codes and attributes ³
                ³                                ³
       A000:8000³                                ³
     (B800:0000)ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³    256 character definitions   ³ 30H
       A000:6000ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³    256 character definitions   ³ 20H
       A000:4000ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³    256 character definitions   ³ 10H
       A000:2000ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´
                ³    256 character definitions   ³ 00H
       A000:0000ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ±±±
                                                    ³
                           Value in Character Font Pointer register

     Figure 10-8.  Layout of video RAM in MCGA alphanumeric modes.


     The format of the MCGA's character definition tables is very different
     from that of any other tables discussed thus far. Each 8 KB table is
     divided into 16 512-byte lists of character codes and bit patterns
     (see Figure 10-9). Each list corresponds to one scan line of the
     characters being defined; the first list represents the bit patterns
     in the topmost scan line of each character, the second list
     corresponds to the second scan line, and so on (see Figure 10-10).
     Since there are 16 lists, the maximum height of a character is 16
     lines.


           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 0123456789ABCDEF
A000:0400 00 00 01 7E 02 7E 03 00 04 00 05 00 06 00 07 00 ...~.~..........
A000:0410 08 FF 09 00 0A FF 0B IE 0C 3C 0D 3F 0E 7F 0F 00 .........<.?....
A000:0420 10 C0 11 06 12 18 13 66 14 7F 15 C6 16 00 17 18 .......f........
A000:0430 18 18 19 18 1A 00 1B 00 1C 00 1D 00 1E 00 1F 00 ................
A000:0440 20 00 21 18 22 66 23 00 24 7C 25 00 26 38 27 30  .!."F#.$|%.&8'0
A000:0450 28 0C 29 30 2A 00 2B 00 2C 00 2D 00 2E 00 2F 00 (.)0*.+.,.-.../.
A000:0460 30 7C 31 18 32 7C 33 7C 34 0C 35 FE 36 38 37 FE 0|1.2|3|4.5.687.
A000:0470 38 7C 39 7C 3A 00 3B 00 3C 00 3D 00 3E 00 3F 7C 8|9|:.;.<.=.>.?|
A000:0480 40 00 41 10 42 FC 43 3C 44 F8 45 FE 46 FE 47 3C @.A.B.C<D.E.F.G<
A000:0490 48 C6 49 3C 4A 1E 4B E6 4C F0 4D C6 4E C6 4F 38 H.I<J.K.L.M.N.O8
A000:04A0 50 FC 51 7C 52 FC 53 7C 54 7E 55 C6 56 C6 57 C6 P.Q|R.S|T~U.V.W.
A000:04B0 58 C6 59 66 5A FE 5B 3C 5C 00 5D 3C 5E 6C 5F 00 X.YfZ.{<\.}<^1_.
A000:04C0 60 18 61 00 62 E0 63 00 64 1C 65 00 66 38 67 00 `.a.b.c.d.e.f8g.
A000:04D0 68 E0 69 18 6A 06 6B E0 6C 38 6D 00 6E 00 6F 00 h.i.j.k.l9m.n.o.
A000:04E0 70 00 71 00 72 00 73 00 74 10 75 00 76 00 77 00 p.q.r.s.t.u.v.w.
A000:04F0 78 00 79 00 7A 00 7B 0E 7C 18 7D 70 7E 76 7F 00 x.y.z.{.|.}p~v..
A000:0500 80 3C 81 CC 82 18 83 38 84 CC 85 30 86 6C 87 00 .<.....8...0.1..
A000:0510 88 38 89 CC 8A 30 8B 66 8C 3C 8D 30 8E C6 8F 38 .8...0.f.<.0...8
A000:0520 90 60 91 00 92 3E 93 38 94 C6 95 30 96 78 97 30 .`...>.8...0.X.0
A000:0530 98 C6 99 C6 9A C6 9B 18 9C 6C 9D 66 9E CC 9F 1B .........l.f....
A000:0540 A0 30 A1 18 A2 30 A3 30 A4 76 A5 00 A6 6C A7 6C .0...0.0.v...l.l
A000:0550 A8 30 A9 00 AA 00 AB C0 AC C0 AD 18 AE 00 AF 00 .0..............

     Figure 10-9.  One of 16 lists of character codes and bit patterns in
     MCGA character generator RAM. This table defines the bit patterns for
     the third scan line of each character. Character codes are in the
     even-numbered bytes. The odd-numbered bytes contain the corresponding
     bit patterns.


           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F 0123456789ABCDEF
A000:0000 00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 ................
A000:0010 08 FF 09 00 0A FF 0B 00 0C 00 0D 00 0E 00 0F 00 ................

A000:0200 00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00 ................
A000:0210 08 FF 09 00 0A FF 0B 00 0C 00 0D 00 0E 00 0F 00 ................

A000:0400 00 00 01 7E 02 7E 03 00 04 00 05 00 06 00 07 00 ...~ ~..........
A000:0410 08 FF 09 00 0A FF 0B 1E 0C 3C 0D 3F 0E 7F 0F 00 .........<.?....

A000:0600 00 00 01 81 02 FF 03 00 04 00 05 18 06 18 07 00 ................
A000:0610 08 FF 09 00 0A FF 0B 0E 0C 66 0D 33 0E 63 0F 18 ................

A000:0800 00 00 01 A5 02 DB 03 6C 04 10 05 3C 06 3C 07 00 .......l...<.<..
A000:0810 08 FF 09 00 0A FF 0B 1A 0C 66 0D 3F 0E 7F 0F 18 .........f.?....

A000:0A00 00 00 01 81 02 FF 03 FE 04 38 05 3C 06 7E 07 00 .........8.<.~..
A000:0A10 08 FF 09 3C 0A C3 0B 32 0C 66 0D 30 0E 63 0F DB ...<...2.f.0.c..

A000:0C00 00 00 01 81 02 FF 03 FE 04 7C 05 E7 06 FF 07 18 .........|......
A000:0C10 08 E7 09 66 0A 99 0B 78 0C 66 0D 30 0E 63 0F 3C ...f...x.f.0.c.<

A000:0E00 00 00 01 BD 02 C3 03 FE 04 FE 05 E7 06 FF 07 3C ...............<
A000:0E10 08 C3 09 42 0A BD 0B CC 0C 3C 0D 30 0E 63 0F E7 ...B.....<.0.c..

A000:1000 00 00 01 99 02 E7 03 FE 04 7C 05 E7 06 7E 07 3C .........|...~.<
A000:1010 08 C3 09 42 0A BD 0B CC 0C 18 0D 30 OE 63 0F 3C ...B.......0.c.<

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

A000:1200 00 00 01 81 02 FF 03 7C 04 38 05 18 06 18 07 18 .......|.8......
A000:1210 08 E7 09 66 0A 99 0B CC 0C 7E 0D 70 0E 67 0F DB ...f.....~.p.g..

A000:1400 00 00 01 81 02 FF 03 38 04 10 05 18 06 18 07 00 .......8........
A000:1410 08 FF 09 3C 0A C3 0B CC 0C 18 0D F0 0E E7 0F 18 ...<............

A000:1600 00 00 01 7E 02 7E 03 10 04 00 05 3C 06 3C 07 00 ...~.~.....<.<..
A000:1610 08 FF 09 00 0A FF 0B 78 0C 18 0D E0 0E E6 0F 18 .......x........

     Figure 10-10.  MCGA character definitions for the first 12 scan lines
     of the first 16 characters. The top scan line for each character is
     defined starting at A000:0000, the second scan line starting at
     A000:2000, and so on. (Only the first 32 bytes of each 512-byte list
     are shown.)


Updating Character Generator RAM


     After you create a table of character definitions (discussed in
     Chapter 9), you must make the table accessible to the hardware
     character generator by properly locating it in the video buffer. One
     way to do this is to create the table in RAM (outside the video
     buffer) and then copy it to character generator RAM. You can also read
     the table directly from a disk file into character generator RAM.
     Either technique works on any of the video subsystems discussed here.


EGA and VGA

     To copy a character definition table into video memory map 2, you must
     program both the Sequencer's Memory Mode register and its Map Mask
     register, as well as the Graphics Controller's Mode and Miscellaneous
     registers, to make memory map 2 directly addressable. You can then
     copy character definitions to any of the available table locations in
     map 2. After you update map 2, restore the Sequencer and Graphics
     Controller registers to values appropriate for the alphanumeric video
     mode you are using.

     Listing 10-1a demonstrates how the Sequencer and Graphics Controller
     are programmed on both the EGA and the VGA to make character generator
     RAM in map 2 accessible. Listing 10-1b is the converse routine; it
     restores the Sequencer and Graphics Controller registers to their
     alphanumeric mode default values. You can use the routines in Listings
     10-1a and 10-1b in a program that copies character definitions
     directly from a file into character generator RAM (as shown in
     Listings 10-2a and 10-2b).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-1a.  Using character generator RAM on the EGA and
     VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-1b.  Restoring character generator RAM on the EGA and
     VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-2a.  Loading character definitions on an EGA or
     VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-2b.  Calling CGenRead1 from a C program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     A faster and more portable way to load character definitions into RAM
     is to use INT 10H function 11H with AL = 0 (see Listings 10-3a and 10-
     3b). When you use the INT 10H function, you can selectively update any
     portion of a table in map 2 by choosing appropriate values for DX (the
     character offset into the table) and CX (the number of character
     definitions to update). To use this video BIOS function, you must
     first store the character definition table in an intermediate buffer.
     This technique consumes more memory than reading character definitions
     directly from disk, but it results in faster code.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-3a.  Using the BIOS to load character definitions.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-3b.  Calling CGenRead2 from a C
     program.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The INT 10H function 11H services can also update character generator
     RAM from the character tables in the ROM BIOS. To use one of the ROM
     BIOS character definition tables, call INT 10H function 11H with AL =
     1 (for 8-by-14 character definitions) or AL = 2 (for 8-by-8
     definitions). (See Listing 10-4.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 10-4.  Using a ROM BIOS character definition table.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


HGC+

     Moving a character definition table into RAM is easier on the HGC+,
     because memory addressing is simpler. Character generator RAM is
     mapped linearly, starting at B000:4000. Since each 256-character table
     occupies 4 KB (256 x 16), subsequent 256-character tables start at
     B000:5000, B000:6000, and so on.

     Because HGC+ memory has no bit planes, you can access character
     generator RAM as easily as any other system RAM. You can, for example,
     use a single REP MOVSB instruction to move bit patterns into character
     generator RAM  from elsewhere in system RAM, or you can read a
     character definition table directly into RAM from a disk file. For
     example, you can modify Listing 10-2a to read a file directly into
     HGC+ character generator RAM by changing the  values of CGenRAMSeg to
     B000H, CGenStartOffset to 4000H, and CGenDefSize to 16.


InColor Card

     Although the InColor Card uses all four bit planes to store character
     definitions, you can use virtually the same routine to copy bit
     patterns into its character generator RAM that you use on the HGC+.
     The only difference is that you can select which of the four bit
     planes to update. Do this by setting bits 4 through 7  of the Plane
     Mask register (18H) to write-protect one or more of the bit planes.
     For compatibility with the HGC+, set these four bits to 0 so that all
     four bit planes contain the same bit patterns.


MCGA

     As on the Hercules adapters, character generator RAM on the MCGA is
     mapped linearly in the video buffer. Thus, you can update MCGA
     character definitions simply by writing the bit patterns in the
     appropriate format in the character definition tables.

     If you update the MCGA character definition tables directly, however,
     your program must store bit patterns and character codes in the format
     expected by the MCGA character generator. It is usually better to use
     INT 10H function 11H to copy character definitions into MCGA character
     generator RAM. This video BIOS function translates character
     definition tables from the linear format used on the EGA and VGA into
     the formatted lists used on the MCGA.

     The MCGA is different from the other video subsystems discussed here
     in that its alphanumeric character generator does not fetch bit
     patterns from the tables at A000:0000 as it generates characters.
     Instead, the character generator uses two internal character
     definition tables, called font pages. To display the characters from
     one of the four tables in video RAM, you must load the table into one
     of the character generator's font pages. Listing 10-5 shows how this
     is done.

