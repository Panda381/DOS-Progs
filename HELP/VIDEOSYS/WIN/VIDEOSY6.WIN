

---------------------------------------------------------------------------
Listing 9-7.  A software character generator for Hercules InColor
              graphics modes.
---------------------------------------------------------------------------

                TITLE   'Listing 9-7'
                NAME    DisplayCharInC
                PAGE    55,132

;
; Name:         DisplayCharInC
;
; Function:     Display a character in InColor 720x348 16-color mode
;
; Caller:       Microsoft C:
;
;                       void DisplayCharInC(c,x,y,fgd,bkgd);
;

;                       int c;                  /* character code */
;
;                       int x,y;                /* upper left pixel */
;
;                       int fgd,bkgd;           /* foreground and */
;                                               /*  background pixel */
;                                               /*  values */
;

ARGc            EQU     word ptr [bp+4] ; stack frame addressing
ARGx            EQU     word ptr [bp+6]
ARGy            EQU     word ptr [bp+8]
ARGfgd          EQU     byte ptr [bp+10]
ARGbkgd         EQU     byte ptr [bp+12]

VARmask         EQU     word ptr [bp-8]
VAR9bits        EQU     byte ptr [bp-10]

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddrHGC:near

                PUBLIC  _DisplayCharInC
_DisplayCharInC PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,4            ; stack space for local variables
                push    di
                push    si
                push    ds

; calculate first pixel address

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddrHGC    ; ES:BX -> buffer
                                        ; CL := # bits to shift left to
                                        ;        mask pixel
                xor     cl,7            ; CL := # bits to rotate right

                push    es              ; preserve video buffer segment
                mov     si,bx           ; DI := video buffer offset

; set up flag for 8-bit or 9-bit characters

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;        Display Data area

                mov     ax,0FF00h       ; AX := 8-bit mask
                mov     VAR9bits,0      ; zero this flag

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

                cmp     byte ptr ds:[4Ah],90    ; does CRT_COLS = 90?
                je      L01             ; jump if characters are 8
                                        ;  pixels wide

                mov     ah,7Fh          ; AX := 9-bit mask
                cmp     ARGc,0C0h
                jb      L01             ; jump if character code ...

                cmp     ARGc,0DFh
                ja      L01             ; ... outside of range 0C0-0DFh

                inc     VAR9bits        ; set flag to extend to 9 bits

L01:            ror     ax,cl           ; AX := bit mask in proper position
                mov     VARmask,ax

; set up character definition table addressing

                mov     ax,40h
                mov     ds,ax           ; DS := segment of BIOS Video
                                        ;        Display Data area
                mov     ch,ds:[85h]     ; CH := POINTS (pixel rows in 
                                        ;        character)

                xor     ax,ax
                mov     ds,ax           ; DS := absolute zero

                mov     ax,ARGc         ; AL := character code
                cmp     al,80h
                jae     L02

                mov     bx,43h*4        ; DS:BX -> int 43h vector if
                                        ;  char < 80h
                jmp     short L03

L02:            mov     bx,1Fh*4        ; DS:BX -> int 1Fh vector if char 
                                        ;  >= 80h
                sub     al,80h          ; put character code in range of 
                                        ;  table 

L03:            les     di,ds:[bx]      ; ES:DI -> start of character table
                mul     ch              ; AX := offset into char def table
                                        ;        (POINTS * char code)
                add     di,ax           ; DI := addr of char def

                pop     ds              ; DS:SI -> video buffer

; set up control registers

                mov     dx,3B4h         ; control register I/O port

                push    cx              ; preserve CX
                mov     ah,ARGbkgd      ; AH := background pixel value
                mov     cl,4
                shl     ah,cl           ; AH bits 4-7 := background pixel 
                                        ;                 value
                or      ah,ARGfgd       ; AH bits 0-3 := foreground pixel 
                                        ;                 value
                pop     cx              ; restore CX

                mov     al,1Ah          ; AL := Read/Write Color reg number
                out     dx,ax           ; set Read/Write Color value

; mask and set pixels in the video buffer

L20:            xor     bh,bh
                mov     bl,es:[di]      ; BX := bit pattern for next 
                                        ;        pixel row

                inc     di              ; increment pointer to char def 
                                        ;  table
                cmp     VAR9bits,0

                je      L21             ; jump if character is 8 pixels 
                                        ;  wide

                ror     bx,1            ; copy lo-order bit of BX into ...
                rcl     bl,1            ;  hi-order bit

L21:            ror     bx,cl           ; rotate pixels into position

                mov     ax,5F19h        ; AH bit 6 := 1 (mask polarity)
                                        ; AH bits 4-5 := 01b (write mode 1)
                                        ; AH bits 0-3 := 1111b (don't care 
                                           ;                 bits)
                                        ; AL := 19h (Read/Write Control 
                                        ;        reg)
                out     dx,ax           ; set up Read/Write Control reg

                or      [si],bl         ; update foreground pixels
                or      [si+1],bh

                mov     ah,6Fh          ; set up write mode 2
                out     dx,ax

                or      bx,VARmask      ; BX := background pixel bit 
                                        ;        pattern
                or      [si],bl         ; update background pixels
                or      [si+1],bh

                add     si,2000h        ; increment to next portion of 
                                        ;  interleave
                jns     L22

                add     si,90-8000h     ; increment to first portion of 
                                        ;  interleave

L22:            dec     ch
                jnz     L20

; restore default InColor register values

                mov     ax,4019h        ; default Read/Write Control reg
                out     dx,ax

                mov     ax,071Ah        ; default Read/Write Color reg
                out     dx,ax

                pop     ds              ; restore caller registers and 
                                        ;  return
                pop     si
                pop     di
                mov     sp,bp
                pop     bp
                ret

_DisplayCharInC ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 10-1a.  Using character generator RAM on the EGA and VGA.
---------------------------------------------------------------------------

                TITLE   'Listing 10-1a'
                NAME    CGenModeSet
                PAGE    55,132

;
; Name:         CGenModeSet
;
;               Direct access to EGA and VGA alpha character generator RAM
;
; Caller:       Microsoft C:
;
;                       void CGenModeSet();
;

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _CGenModeSet
_CGenModeSet    PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si

; Program the Sequencer

                cli                     ; disable interrupts
                mov     dx,3C4h         ; Sequencer port address
                mov     si,offset DGROUP:SeqParms
                mov     cx,4

L01:            lodsw                   ; AH := value for Sequencer 
                                        ;        register
                                        ; AL := register number
                out     dx,ax           ; program the register
                loop    L01
                sti                     ; enable interrupts

; Program the Graphics Controller

                mov     dl,0CEh         ; DX := 3CEH (Graphics Controller 
                                        ;             port address)
                mov     si,offset DGROUP:GCParms
                mov     cx,3

L02:            lodsw                   ; program the Graphics Controller
                out     dx,ax
                loop    L02

                pop     si
                pop     bp
                ret

_CGenModeSet    ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

; Format of the parameters is:  Lo-order byte:  Register number
;                               Hi-order byte:  Value for reg

SeqParms        DW      0100h           ; synchronous reset
                DW      0402h           ; CPU writes only to map 2
                DW      0704h           ; sequential addressing
                DW      0300h           ; clear synchronous reset

GCParms         DW      0204h           ; select map 2 for CPU reads
                DW      0005h           ; disable odd-even addressing
                DW      0006h           ; map starts at A000:0000

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 10-1b.  Restoring character generator RAM on the EGA and VGA.
---------------------------------------------------------------------------

                TITLE   'Listing 10-1b'
                NAME    CGenModeClear
                PAGE    55,132
;
; Name:         CGenModeClear
;
;               Restore EGA or VGA alphanumeric mode after accessing
;                character generator RAM
;
; Caller:       Microsoft C:
;
;                       void CGenModeClear();
;

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _CGenModeClear
_CGenModeClear  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si

; Program the Sequencer

                cli                     ; disable interrupts
                mov     dx,3C4h         ; Sequencer port address
                mov     si,offset DGROUP:SeqParms
                mov     cx,4

L01:            lodsw                   ; AH := value for Sequencer 
                                                 register
                                        ; AL := register number
                out     dx,ax           ; program the register
                loop    L01
                sti                     ; enable interrupts

; Program the Graphics Controller

                mov     dl,0CEh         ; DX := 3CEH (Graphics Controller 
                                        ;             port address)
                mov     si,offset DGROUP:GCParms
                mov     cx,3

L02:            lodsw                   ; program the Graphics Controller
                out     dx,ax
                loop    L02

                mov     ah,0Fh          ; AH := INT 10H function number
                int     10h             ; get video mode
                cmp     al,7
                jne     L03             ; jump if not monochrome mode

                mov     ax,0806h        ; program Graphics Controller
                out     dx,ax           ;  to start map at B000:0000

L03:            pop     si
                pop     bp
                ret

_CGenModeClear  ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

; Format of the parameters is:  Lo-order byte:  Register number
;                               Hi-order byte:  Value for reg

SeqParms        DW      0100h           ; synchronous reset
                DW      0302h           ; CPU writes to maps 0 and 1
                DW      0304h           ; odd-even addressing
                DW      0300h           ; clear synchronous reset

GCParms         DW      0004h           ; select map 0 for CPU reads
                DW      1005h           ; enable odd-even addressing
                DW      0E06h           ; map starts at B800:0000

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 10-2a.  Loading character definitions on an EGA or VGA.
---------------------------------------------------------------------------

                TITLE   'Listing 10-2a'
                NAME    CGenRead1
                PAGE    55,132

;
; Name:         CGenRead1
;
;               Read 256 character definitions into EGA or VGA character 
;                RAM
;
; Caller:       Microsoft C:
;
;                       void CGenRead1(f,p);
;
;                       int     f;     /* file handle */
;                       int     p;     /* bytes per character definition */
;

ARGf            EQU     [bp+4]
ARGp            EQU     [bp+6]

CGenRAMSeg      EQU     0A000h         ; start of character generator RAM
CGenRAMOffset   EQU     0
CGenDefSize     EQU     32             ; size in bytes of one character def

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _CGenRead1

_CGenRead1      PROC    near

                push    bp             ; preserve registers
                mov     bp,sp
                push    ds
                push    si
                push    di

; zero character definition RAM

                mov     di,CGenRAMSeg
                mov     es,di          ; ES := char gen RAM segment
                mov     di,CGenRAMOffset

                mov     cx,256*CGenDefSize/2    ; CX := number of words to 
                                                ;        zero
                xor     ax,ax
                rep     stosw

; load character definitions from file

                mov     cx,256         ; assume 256 character defs in the 
                                       ;  file

                mov     bx,ARGf        ; BX := file handle
                mov     si,ARGp        ; CX := bytes per character 
                                       ;        definition
                push    es
                pop     ds
                mov     dx,CGenRAMOffset  ; DS:DX -> start of character gen 
                                          ;  RAM

L01:            xchg    cx,si          ; CX := number of bytes to read
                                       ; SI := loop counter
                mov     ah,3Fh         ; AH := INT 21H function number
                int     21h
                add     dx,CGenDefSize ; DS:DX -> next character def in RAM
                xchg    cx,si          ; CX := loop counter
                                       ; SI := number of bytes to read
                loop    L01

                pop     di             ; restore registers and exit
                pop     si
                pop     ds
                pop     bp
                ret

_CGenRead1      ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
Listing 10-2b.  Calling CGenRead1 from a C program.
---------------------------------------------------------------------------

/* Listing 10-2b */

#include        <fcntl.h>
#include        <stdio.h>

main(argc,argv)
int     argc;
char    **argv;
{
        int     i;
        int     FileHandle;
        int     Points;                /* bytes per character definition */
        long    lseek();
        long    FileSize;

        if (argc != 2)                 /* verify filename */
        {
          printf( "\nNo filename specified\n" );
          exit( 1 );
        }

        FileHandle = open( argv[1], O_RDONLY );         /* open the file */

        if ( FileHandle == -1 )
        {
          printf( "\nCan't open '%s'\n", argv[1] );
          exit( 2 );
        }

        CGenModeSet();       /* make character generator RAM addressable */

        FileSize = lseek( FileHandle, 0L, SEEK_END );   /* get file size */
        Points = FileSize / 256;             /* determine character size */

        lseek( FileHandle, 0L, SEEK_SET );   /* start of file */

        CGenRead1( FileHandle, Points );

        CGenModeClear();     /* restore previous alphanumeric mode */
}



---------------------------------------------------------------------------
Listing 10-3a.  Using the BIOS to load character definitions.
---------------------------------------------------------------------------

                TITLE   'Listing 10-3a'
                NAME    CGenRead2
                PAGE    55,132
;
; Name:         CGenRead2
;
;               Use video BIOS to read 256 character definitions into EGA 
;                or VGA character RAM
;
; Caller:       Microsoft C:
;
;                       void CGenRead2(f);
;
;                       int     f;      /* file handle */
;

ARGf            EQU     [bp+4]

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _CGenRead2
_CGenRead2      PROC    near

                push    bp              ; preserve registers
                mov     bp,sp

; load character definitions from file

                mov     cx,256*32       ; assume 256 32-byte character defs
                                        ;  in the file
                mov     bx,ARGf         ; BX := file handle
                mov     dx,offset DGROUP:CharBuf  ; DS:DX -> start of 
                                                  ;  buffer

                mov     ah,3Fh          ; AH := INT 21H function number
                int     21h             ; read the file
                                        ; AX := number of bytes read

; call video BIOS to load character generator RAM

                push    ds
                pop     es
                mov     bp,offset DGROUP:CharBuf  ; ES:BP -> character defs
                mov     bl,0            ; BL := block of char gen RAM 
                                        ;        to load
                mov     bh,ah           ; AH := bytes per character
                                        ;        (number of bytes read) 
                                        ;        / 256
                mov     cx,256          ; number of character defs to store
                xor     dx,dx           ; first character number
                mov     ax,1100h        ; AH := 11H (INT 10H function 
                                        ;            number)
                                        ; AL := 0 (subfunction number)
                int     10h

                pop     bp              ; restore BP and exit
                ret

_CGenRead2      ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

CharBuf         DB      256*32 dup(?)

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 10-3b.  Calling CGenRead2 from a C program.
---------------------------------------------------------------------------

/* Listing 10-3b */

#include        <fcntl.h>

main(argc,argv)
int     argc;
char    **argv;
{
        int     i;
        int     FileHandle;


        if (argc != 2)                                /* verify filename */
        {
          printf( "\nNo filename specified\n" );
          exit( 1 );
        }

        FileHandle = open( argv[1], O_RDONLY );       /* open the file */

        if ( FileHandle == -1 )
        {
          printf( "\nCan't open '%s'\n", argv[1] );
          exit( 2 );
        }


        CGenRead2( FileHandle );    /* call video BIOS to load file into */
                                    /*  character generator RAM */
}



---------------------------------------------------------------------------
Listing 10-4.  Using a ROM BIOS character definition table.
---------------------------------------------------------------------------

        mov     ax,1102h        ; AH := INT 10H function number
                                ; AL := 02h (load ROM BIOS 8x8 characters)
        mov     bl,0            ; BL := character generator RAM bank
        int     10h             ; load alphanumeric character set



---------------------------------------------------------------------------
Listing 10-5.  Loading font pages on an MCGA.
---------------------------------------------------------------------------

                TITLE   'Listing 10-5'
                NAME    SetFontPages
                PAGE    55,132

;
; Name:         SetFontPages
;
;               Update MCGA Font Pages
;
; Caller:       Microsoft C:
;
;                       void SetFontPages(n0,n1);
;
;                       int     n0,n1;  /* font page values */
;

ARGn0           EQU     [bp+4]
ARGn1           EQU     [bp+6]

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _SetFontPages

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
_SetFontPages   PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp

                mov     ax,1103h        ; AH := INT 10H function number
                                        ; AL := 3 (Set Block Specifier)
                mov     bl,ARGn1        ; BL := value for bits 2-3
                shl     bl,1
                shl     bl,1            ; BL bits 2-3 := n1
                or      bl,ARGn0        ; BL bits 0-1 := n0
                int     10h             ; load font pages

                pop     bp
                ret

_SetFontPages   ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 10-6.  Configuring an HGC+ or InColor Card for updating
               character generator RAM.
---------------------------------------------------------------------------

        mov     dx,3B4h
        mov     ax,0114h        ; AH bit 0 := 1 (enable RAM character
                                ;                 generator)
                                ; AL := 14h (xMode register number)
        out     dx,ax

        mov     dl,0BFh         ; DX := 3BFh (Config Switch register)
        mov     al,1            ; AL bit 0 := 1 (make RAM at B000:4000
                                ;                 addressable)
        out     dx,al

        .
        .                       ; (update character generator RAM)
        .

        mov     dx,3BFh         ; DX := 3BFh (Config Switch register)
        mov     al,0            ; AL bit 0 := 0 (exclude RAM at
                                ;                B000:4000 from memory map)
        out     dx,al



---------------------------------------------------------------------------
Listing 10-7.  Programming the Sequencer Character Map Select register
               on the EGA and VGA.
---------------------------------------------------------------------------

; using the video BIOS

        mov     ax,1103h        ; AH := INT 10H function number
                                ; AL := 3
        mov     bl,CharMapValue ; BL := value for Character Map Select 
                                ;        register
        int     10h


; programming the register directly

        mov     dx,3C4h         ; DX := Sequencer I/O port
        mov     ax,100h         ; AH bit 1 := 0 (synchronous reset)
                                ; AL := 0 (Sequencer Reset register number)
        cli                     ; disable interrupts
        out     dx,ax           ; reset Sequencer

        mov     ah,CharMapValue ; AH := value for Character Map Select 
                                ;        register
        mov     al,3            ; AL := 3 (Char Map Select register number)
        out     dx,ax           ; update this register

        mov     ax,300h         ; AH bit 1 := 1 (clear synchronous reset)
                                ; AL := 0 (Reset register number)
        out     dx,ax           ; clear the reset
        sti                     ; enable interrupts



---------------------------------------------------------------------------
Listing 10-8.  Zeroing bit 3 of the Color Plane Enable register. This
               causes bit 3 of a character's attribute byte to have no
               effect on its displayed attribute.
---------------------------------------------------------------------------

mov     ax,1000h                ; AH := 10H (INT 10H function number)
                                ; AL := 0 (set specified register)
mov     bx,0712h                ; BH := 0111b (Color Plane Enable value)
                                ; BL := 12H (Color Plane Enable reg number)
int     10h                     ; update Color Plane Enable register



---------------------------------------------------------------------------
Listing 10-9.  Establishing an 80-by-43 alphanumeric mode on an EGA.
---------------------------------------------------------------------------

; establish 80x25 alphanumeric mode (350-line vertical resolution)

        mov     ax,3            ; AH := 0 (INT 10H function number)
        int     10h             ; AL := 3 (80x25 16-color mode)

; load video BIOS 8x8 characters into alphanumeric character generator 

        mov     ax,1112h        ; AH := INT 10H function number
                                ; AL := 8x8 character set load
        mov     bl,0            ; BL := block to load
        int     10h             ; load 8x8 characters into RAM

; set cursor position in character matrix

        mov     ax,40h
        mov     es,ax           ; ES -> video BIOS data area
        mov     dx,es:[63h]     ; DX := CRTC address port from 0040:0063
                                ;        (3B4H or 3D4H)
        mov     ax,060Ah        ; AH := 6 (Cursor Start value)
                                ; AL := 0AH (Cursor Start reg number)
        out     dx,ax           ; update CRTC Cursor Start register

        mov     ax,000Bh        ; AH := 0 (Cursor End value)
                                ; AL := 0BH (Cursor End reg number)
        out     dx,ax           ; update CRTC Cursor End register

; use alternate video BIOS print screen routine

        mov     ah,12h          ; AH := INT 10H function number
        mov     bl,20h          ; BL := subfunction number
        int     10h             ; update INT 5 vector (print screen)



---------------------------------------------------------------------------
Listing 10-10.  Establishing an 80-by-50 alphanumeric mode on a VGA.
---------------------------------------------------------------------------

; establish 80x25 alphanumeric mode with 400-line vertical resolution

        mov     ax,1202h                ; AH := 12h (INT 10H function 
                                        ;             number)
                                        ; AL := 2 (select 400 scan lines)
        mov     bl,30h                  ; subfunction number
        int     10h

        mov     ax,3                    ; AH := 0 (INT 10H function number)
        int     10h                     ; AL := 3 (80x25 16-color mode)

; load video BIOS 8x8 characters into alphanumeric character generator

        mov     ax,1112h                ; AH := INT 10H function number
                                        ; AL := 8x8 character set load
        mov     bl,0                    ; BL := block to load
        int     10h                     ; load 8x8 characters into RAM



---------------------------------------------------------------------------
Listing 10-11.  Establishing an 80-by-40 alphanumeric mode on an MCGA.
---------------------------------------------------------------------------

; establish 80x25 alphanumeric mode

        mov     ax,3            ; AH := 0 (INT 10H function number)
                                ; AL := 3 (80x25 16-color mode)
        int     10h

; zero the bit patterns in character generator RAM

        mov     di,0A000h
        mov     es,di
        xor     di,di           ; ES:DI -> character generator RAM
        xor     ax,ax           ; AH := 0 (bit pattern)
                                ; AL := 0 (initial character code)
        mov     cx,256*16       ; CX := number of words

L01:    stosw                   ; store character code and zero
        inc     al              ; AL := next character code
        loop    L01

; load video BIOS 8x8 characters into alphanumeric character generator

        mov     ax,1102h        ; AH := INT 10H function number
                                ; AL := 8x8 character set load
        mov     bl,0            ; BL := block to load
        int     10h             ; load 8x8 characters into RAM

        mov     ax,1103h        ; AH := INT 10H function number
                                ; AL := character generator load
        mov     bl,0            ; BL := blocks to load
        int     10h             ; load characters into character generator

; program CRT Controller to display 8x10 characters

        mov     dx,3D4h         ; DX := MCGA I/O port address
        mov     ax,409h         ; AL := 9 (register number)

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                                ; AH := 4 (value for register)
        out     dx,ax           ; update Scan Lines register

        mov     al,0Ah          ; AL := 0AH (register number)
        out     dx,ax           ; update Cursor Start register

        mov     al,0Bh          ; AL := 0BH (register number)
        out     dx,ax           ; update Cursor End register

; update status variables in video BIOS data segment 

        mov     ax,40h
        mov     ds,ax           ; DS -> video BIOS data segment

        mov     word ptr ds:[4Ch],80*40*2 ; update CRT_LEN in BIOS data 
                                          ;  area
        mov     byte ptr ds:[84h],40-1  ; update ROWS
        mov     word ptr ds:[85h],10    ; update POINTS



---------------------------------------------------------------------------
Listing 10-12.  Programming the EGA alphanumeric character size.
---------------------------------------------------------------------------

                TITLE   'Listing 10-12'
                NAME    AlphaModeSet
                PAGE    55,132

;
; Name:         AlphaModeSet
;
;               Program the CRTC in 80-column EGA alphanumeric modes
;
; Caller:       Microsoft C:
;
;                       void AlphaModeSet(w,h,c);
;
;                       int     w;      /* width of character matrix */
;                       int     h;      /* height of character matrix */
;                       int     c;      /* character code size */
;

ARGw            EQU     byte ptr [bp+4]        ; must be 8 or 9 pixels wide
ARGh            EQU     byte ptr [bp+6]        ; must be 2-32 pixels high
ARGc            EQU     byte ptr [bp+8]        ; must be 8 or 9 bits

CRT_MODE        EQU     49h             ; addresses in video BIOS data area
CRT_COLS        EQU     4Ah
ADDR_6845       EQU     63h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _AlphaModeSet
_AlphaModeSet   PROC    near

                push    bp             ; preserve caller registers
                mov     bp,sp
                push    si

; Program the CRTC

                mov     bx,40h
                mov     es,bx          ; ES := video BIOS data segment

                mov     bl,ARGw        ; BL := character width
                mov     bh,ARGh        ; BH := character height
                call    SetCRTC

; Program the Sequencer and Attribute Controller for 8 or 9 dots per
;  character

                mov     dx,3C4h
                mov     ax,0100h       ; AH bit 1 := 0 (synchronous reset)
                                       ; AL := 0 (Reset register number)
                cli                    ; disable interrupts
                out     dx,ax          ; Sequencer synchronous reset

                mov     bx,1           ; BH,BL := values for 8-wide chars:
                                       ;  BH := 0 (value for Horiz Pel Pan)
                                       ;  BL := 1 (value for Clocking Mode)
                cmp     ARGw,8
                je      L01            ; jump if 8-wide characters
                mov     bx,0800h       ; BH,BL := values for 9-wide 
                                       ;           characters

L01:            mov     ah,bl          ; AH := value for Clocking Mode reg
                mov     al,1           ; AL := Clocking Mode reg number
                out     dx,ax          ; program the Sequencer

                mov     ax,0300h       ; AH := 3 (disable reset)
                                       ; AL := 0 (Sequencer register 
                                       ;           number)
                out     dx,ax          ; disable Sequencer reset
                sti                    ; enable interrupts

                mov     bl,13h         ; BL := Horizontal Pel Pan reg 
                                       ;        number
                mov     ax,1000h       ; AH := 10H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (set specified register)
                int     10h            ; program Attribute Controller

; Program the Attribute Controller for 8- or 9-bit character codes

                mov     ax,1000h       ; AH := 10H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (set specified register)
                mov     bx,0F12h       ; BH := 0FH (Color Plane Enable 
                                       ;             value)
                                       ; BL := 12H (Color Plane Enable 
                                       ;             reg #)
                cmp     ARGc,8
                je      L02            ; jump if 8-bit character codes

                mov     bh,7           ; BH bit 3 := 0 (ignore bit 3 of all
                                       ;                 attributes)
L02:            int     10h            ; update Color Plane Enable register

; update video BIOS data area

                cmp     byte ptr es:[CRT_MODE],7
                jne     L03            ; jump if not monochrome mode

                mov     ax,720         ; AX := displayed pixels per row
                div     ARGw           ; AL := displayed character columns
                mov     es:[CRT_COLS],al

L03:            pop     si
                pop     bp
                ret

_AlphaModeSet   ENDP


SetCRTC         PROC    near           ; Caller:      BH = character height
                                       ;              BL = character width
                push    dx
                mov     dx,es:[ADDR_6845]  ; CRTC I/O port

; establish CRTC vertical timing and cursor position in character matrix

                push    bx             ; preserve height and width
                mov     ax,1110h       ; AH := 11H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (user alpha load)
                xor     cx,cx          ; CX := 0 (store no characters)
                int     10h            ; call BIOS to program CRTC for
                                       ;  height of characters

                pop     ax             ; AH := character height
                push    ax             ; preserve height and width
                sub     ah,2           ; AH := starting scan line for 
                                       ;        cursor
                mov     al,0Ah         ; AL := 0AH (Cursor Start reg 
                                       ;             number)
                out     dx,ax          ; update CRTC Cursor Start register

                mov     ax,000Bh       ; AH := 0 (Cursor End value)
                                       ; AL := 0BH (Cursor End reg number)
                out     dx,ax          ; update CRTC Cursor End register

; establish CRTC horizontal timing

                pop     bx             ; BX := character height and width
                cmp     byte ptr es:[CRT_MODE],7

                jne     L10            ; exit if not monochrome mode

                xor     bh,bh          ; BX := character width
                sub     bl,8           ; BX := 0 or 1
                neg     bx             ; BX := 0 or 0FFFFH
                and     bx,14          ; BX := 0 or 14 (offset into table)
                mov     si,bx          ; SI := offset into table

                add     si,offset DGROUP:HorizParms   ; DS:SI -> parameters
                call    UpdateCRTC

L10:            pop     dx
                ret

SetCRTC         ENDP


UpdateCRTC      PROC    near           ; Caller:     DX = CRTC address port
                                       ;             DS:SI -> parameters
                                       ; Destroys:   AX,CX

                mov     cx,7           ; CX := number of registers to 
                                       ;        update

L20:            lodsw                  ; AH := data for CRTC register in AL
                out     dx,ax          ; update the register
                loop    L20

                ret


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
UpdateCRTC      ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

HorizParms      DW      6C00h,5901h,6002h,2403h,5B04h,6A05h,2D13h  ; 8-wide
                DW      6000h,4F01h,5602h,3A03h,5104h,6005h,2813h  ; 9-wide

_DATA           ENDS
                END



---------------------------------------------------------------------------
Listing 10-13.  Programming the VGA alphanumeric character size.
---------------------------------------------------------------------------

                TITLE   'Listing 10-13'
                NAME    AlphaModeSet
                PAGE    55,132

;
; Name:         AlphaModeSet
;
;               Program the CRTC in 80-column VGA alphanumeric modes
;
; Caller:       Microsoft C:
;
;                       void AlphaModeSet(w,h,c);
;
;                       int     w;      /* width of character matrix */
;                       int     h;      /* height of character matrix */
;                       int     c;      /* character code size */
;

ARGw            EQU     byte ptr [bp+4]        ; must be 8 or 9 pixels wide
ARGh            EQU     byte ptr [bp+6]        ; must be 2-32 pixels high
ARGc            EQU     byte ptr [bp+8]        ; must be 8 or 9 bits

CRT_COLS        EQU     4Ah            ; addresses in video BIOS data area
ADDR_6845       EQU     63h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _AlphaModeSet
_AlphaModeSet   PROC    near

                push    bp             ; preserve caller registers
                mov     bp,sp
                push    si

; Program the CRTC

                mov     bx,40h
                mov     es,bx          ; ES := video BIOS data segment

                mov     bl,ARGw        ; BL := character width
                mov     bh,ARGh        ; BH := character height
                call    SetCRTC

; Program the Sequencer and Attribute Controller for 8 or 9 dots per
;  character

                mov     dx,3C4h
                mov     ax,0100h       ; AH bit 1 := 0 (synchronous reset)
                                       ; AL := 0 (Reset register number)
                cli                    ; disable interrupts
                out     dx,ax          ; Sequencer synchronous reset

                mov     bx,1           ; BH,BL := values for 8-wide chars:
                                       ;  BH := 0 (value for Horiz Pel Pan)
                                       ;  BL := 1 (value for Clocking Mode)
                cmp     ARGw,8
                je      L01            ; jump if 8-wide characters

                mov     bx,0800h       ; BH,BL := values for 9-wide 
                                       ;           characters

L01:            mov     ah,bl          ; AH := value for Clocking Mode reg
                mov     al,1           ; AL := Clocking Mode reg number
                out     dx,ax          ; program the Sequencer

                mov     ax,0300h       ; AH := 3 (disable reset)
                                       ; AL := 0 (Sequencer register 
                                       ;           number)
                out     dx,ax          ; disable Sequencer reset
                sti                    ; enable interrupts

                mov     bl,13h         ; BL := Horizontal Pel Pan reg 
                                       ;        number
                mov     ax,1000h       ; AH := 10H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (set specified register)
                int     10h            ; program Attribute Controller

; Program the Attribute Controller for 8- or 9-bit character codes

                mov     ax,1000h       ; AH := 10H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (set specified register)
                mov     bx,0F12h       ; BH := 0FH (Color Plane Enable 
                                       ;             value)
                                       ; BL := 12H (Color Plane Enable 
                                       ;             reg #)
                cmp     ARGc,8
                je      L02            ; jump if 8-bit character codes

                mov     bh,7           ; BH bit 3 := 0 (ignore bit 3 of all
                                       ;                 attributes)
L02:            int     10h            ; update Color Plane Enable register

; update video BIOS data area

                mov     ax,720         ; AX := displayed pixels per row
                div     ARGw           ; AL := displayed character columns
                mov     es:[CRT_COLS],al

                pop     si
                pop     bp
                ret

_AlphaModeSet   ENDP


SetCRTC         PROC    near           ; Caller:      BH = character height
                                       ;              BL = character width
                push    dx
                mov     dx,es:[ADDR_6845]  ; CRTC I/O port

; establish CRTC vertical timing and cursor position in character matrix

                push    bx             ; preserve char height and width 
                mov     ax,1110h       ; AH := 11H (INT 10H function 
                                       ;             number)
                                       ; AL := 0 (user alpha load)
                xor     cx,cx          ; CX := 0 (store no characters)
                int     10h            ; call BIOS to program CRTC
                pop     bx

; enable I/O writes to CRTC registers

                mov     al,11h         ; AL := Vertical Retrace End reg 
                                       ;        number
                out     dx,al
                inc     dx
                in      al,dx          ; AL := current value of this 
                                       ;        register
                dec     dx

                mov     ah,al          ; AH := current value
                mov     al,11h         ; AL := register number
                push    ax             ; save on stack

                and     ah,01111111b   ; zero bit 7
                out     dx,ax          ; update this register

; establish CRTC horizontal timing

                xor     bh,bh          ; BX := character width
                sub     bl,8           ; BX := 0 or 1
                neg     bx             ; BX := 0 or 0FFFFH
                and     bx,14          ; BX := 0 or 14 (offset into table)
                mov     si,bx          ; SI := offset into table

                add     si,offset DGROUP:HorizParms   ; DS:SI -> parameters
                call    UpdateCRTC

; write-protect CRTC registers

                pop     ax             ; AX := previous VR End register 
                                       ;        data
                out     dx,ax          ; restore this register

                pop     dx
                ret

SetCRTC         ENDP


UpdateCRTC      PROC    near           ; Caller:     DX = CRTC address port
                                       ;             DS:SI -> parameters
                                       ; Destroys:   AX,CX

                mov     cx,7           ; CX := number of registers to 
                                       ;        update
                
L10:            lodsw                  ; AH := data for CRTC register in AL
                out     dx,ax          ; update the register
                loop    L10

                ret

UpdateCRTC      ENDP

_TEXT           ENDS

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


_DATA           SEGMENT word public 'DATA'

HorizParms      DW      6A00h,5901h,5A02h,8D03h,6304h,8805h,2D13h  ; 8-wide
                DW      5F00h,4F01h,5002h,8203h,5504h,8105h,2813h  ; 9-wide

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 10-14.  Programming the alphanumeric character size on
                the HGC+ and InColor Card.
---------------------------------------------------------------------------

                TITLE   'Listing 10-14'
                NAME    AlphaModeSet
                PAGE    55,132

;
; Name:         AlphaModeSet
;
; Function:     Program the CRTC in alphanumeric modes on HGC+ or InColor 
;                Card
;
; Caller:       Microsoft C:
;
;                       void AlphaModeSet(w,h,c);
;
;                       int     w;      /* width of character matrix */
;                       int     h;      /* height of character matrix */
;                       int     c;      /* character code size */
;

ARGw            EQU     byte ptr [bp+4]        ; must be 8 or 9 pixels wide
ARGh            EQU     byte ptr [bp+6]        ; must be 4-16 pixels high
ARGc            EQU     byte ptr [bp+8]        ; must be 8 or 12 bits

CRT_COLS        EQU     4Ah
CRT_LEN         EQU     4Ch
CRT_MODE_SET    EQU     65h
ROWS            EQU     84h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _AlphaModeSet
_AlphaModeSet   PROC    near

                push    bp             ; preserve caller registers
                mov     bp,sp
                push    ds
                push    si

; Set Configuration Switch to bring RAM starting at B000:4000 into 
;  memory map

                mov     dx,3BFh        ; DX := Configuration Switch port
                mov     al,1           ; AL bit 1 := 0 (exclude 2nd 32K of
                                       ;                 video buffer)
                                       ; AL bit 0 := 1 (make RAM at 
                out     dx,ax          ;             B000:4000 addressable)

; Blank the screen to avoid interference during CRTC programming

                mov     dx,3B8h        ; DX := CRTC Mode Control Register 
                                       ;        port
                xor     al,al          ; AL bit 3 := 0 (disable video 
                                       ;                signal)
                out     dx,al          ; blank the screen

; Program the CRTC

                mov     bh,ARGw        ; BH := character width
                mov     bl,ARGh        ; BL := character height
                call    SetHercCRTC

; Set the xModeReg

                mov     dx,3B4h        ; DX := CRTC address port
                mov     ax,114h        ; AH bit 0 := 1 (enable RAM-based
                                       ;              character generator)
                                       ; AL := 14h (xModeReg number)
                cmp     ARGw,9
                je      L01            ; jump if 9-wide characters

                or      ah,2           ; AH bit 1 := 1 (8-wide characters)

L01:            cmp     ARGc,8
                je      L02            ; jump if 8-bit character codes

                or      ah,4           ; AH bit 2 := 1 (12-bit character 
                                       ;                 codes)

L02:            out     dx,ax          ; update the register

; update video BIOS data area

                mov     ax,40h
                mov     ds,ax          ; DS := video BIOS data segment

                mov     ax,720         ; AX := displayed pixels per row
                div     ARGw           ; AL := displayed character columns
                mov     ds:[CRT_COLS],al

                mov     ax,350         ; AX := number of displayed scan 
                                       ;        lines
                div     ARGh           ; AL := displayed character rows
                dec     al             ; AL := (character rows) - 1
                mov     ds:[ROWS],al

                inc     al
                mul     byte ptr ds:[CRT_COLS]
                shl     ax,1           ; AX := rows * columns * 2
                mov     ds:[CRT_LEN],ax

; re-enable display and exit

                mov     dx,3B8h        ; DX := CRT Mode Control port
                mov     al,ds:[CRT_MODE_SET]    ; restore previous value
                out     dx,al

                pop     si
                pop     ds
                pop     bp
                ret

_AlphaModeSet   ENDP


SetHercCRTC     PROC    near           ; Caller:     BH = character width
                                       ;             BL = character height

                push    dx
                mov     dx,3B4h        ; DX := CRTC Address Reg port 3B4h

; establish cursor position in character matrix

                mov     ah,bl
                dec     ah             ; AH := value for Max Scan Line reg
                mov     al,9           ; AL := Max Scan Line register 
                                       ;        number
                out     dx,ax

                mov     al,0Bh         ; AL := Cursor End reg number
                out     dx,ax          ; set cursor to end on last line of
                                       ;  character matrix

                sub     ax,101h        ; AH := second-to-last line
                                       ; AL := 0AH (Cursor Start reg 
                                       ;             number)
                out     dx,ax          ; set cursor to start on second-to-
                                       ;  last line

; compute offsets into parameter tables

                sub     bx,0804h       ; BH := 0 or 1
                                       ; BL := 0 through 12
                add     bx,bx
                add     bx,bx          ; BH := 0 or 4
                                       ; BL := 0 through 48
; establish CRTC horizontal timing

                push    bx             ; preserve BX
                mov     bl,bh
                xor     bh,bh          ; BX := 0 or 4
                add     bx,offset DGROUP:HorizParms   ; DS:BX -> parameters

                mov     al,0           ; AL := first CRTC reg to update
                call    UpdateCRTC

; establish vertical timing

                pop     bx
                xor     bh,bh          ; BX := 0 through 48
                add     bx,offset DGROUP:VertParms    ; DS:BX -> parameters

                mov     al,4           ; AL := first CRTC reg to update
                call    UpdateCRTC

                pop     dx             ; restore DX
                ret

SetHercCRTC     ENDP

UpdateCRTC      PROC    near           ; Caller:     AL = first reg number
                                       ;             DX = CRTC address port
                                       ;             DS:BX -> parameters
                                       ; Destroys:   AX,CX

                mov     cx,4           ; CX := number of registers to 
                                       ;        update
                
L10:            mov     ah,[bx]        ; AH := data for CRTC register in AL
                out     dx,ax          ; update the register

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                inc     ax             ; AL := next register number

                inc     bx             ; DS:BX -> next value in table
                loop    L10
                ret

UpdateCRTC      ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

HorizParms      DB      6Dh,5Ah,5Ch,0Fh         ; 8 pixels wide
                DB      61h,50h,52h,0Fh         ; 9 pixels wide


VertParms       DB      5Ch,02h,58h,59h         ; 4 scan lines high
                DB      4Ah,00h,46h,46h         ; 5
                DB      3Dh,04h,3Ah,3Bh         ; 6
                DB      34h,06h,32h,33h         ; 7
                DB      2Dh,02h,2Bh,2Ch         ; 8
                DB      28h,01h,26h,27h         ; 9
                DB      24h,00h,23h,23h         ; 10
                DB      20h,07h,1Fh,20h         ; 11
                DB      1Dh,0Ah,1Dh,1Dh         ; 12
                DB      1Bh,06h,1Ah,1Bh         ; 13
                DB      19h,06h,19h,19h         ; 14
                DB      17h,0Ah,17h,17h         ; 15
                DB      16h,02h,15h,16h         ; 16

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 10-15.  Creating a tiled graphics window on the EGA or VGA.
---------------------------------------------------------------------------

/* Listing 10-15 */

#define Points          14      /* displayed scan lines per character */
#define StartCharCode   0x80    /* first character code in "window" */
#define CGenDefSize     32      /* (use 16 for Hercules) */


char far *CRT_MODE = 0x00400049;        /* BIOS video mode number */
int  far *CRT_COLS = 0x0040004A;        /* characters per row */

char far *VideoBuffer;                  /* pointer to video buffer */
char far *CharDefTable = 0xA0000000;    /* pointer to char def RAM */
                                        /* (use 0xB0004000 for Hercules) */
main()
{
        int     i;
        int     CharCode;
        int     CharOffset;

        int     CharScanLine;
        int     CharDefOffset;
        int     Row,Column;

        /* establish alphanumeric mode */

        if (*CRT_MODE == 7)             /* set video buffer pointer */
          VideoBuffer = 0xB0000000;
        else
          VideoBuffer = 0xB8000000;

        AlphaModeSet( 8, Points, 8 );

        /* establish a tiled graphics window in the upper left corner */

        CharCode = StartCharCode;

        for ( Row = 0; Row < 4; Row++ )
          for ( Column = 0; Column < 32; Column++ )
          {
            CharOffset = (Row*(*CRT_COLS) + Column) * 2;
            VideoBuffer[CharOffset] = CharCode++;
          }             

        /* clear the window */

        CGenModeSet();       /* make character generator RAM addressable */

        for (CharCode = StartCharCode; CharCode < 256; CharCode++ )
          for ( CharScanLine = 0; CharScanLine < Points; CharScanLine++ )
          {
            CharDefOffset = CharCode * CGenDefSize + CharScanLine;
            CharDefTable[CharDefOffset] = 0;
          }

        /* draw a few lines */

        for ( i = 0; i < 256; i++ )         /* horizontal lines */
        {
          SetPixel( i, 0 );
          SetPixel( i, 4*Points-1 );
        }

        for ( i = 0; i < 4*Points-1; i++ )  /* vertical lines */
        {
          SetPixel( 0, i );
          SetPixel( 255, i );
        }

        for( i = 0; i < Points*4; i++ )     /* diagonal lines */
        {
          SetPixel( i, i );
          SetPixel( 255-i, i );
        }

        CGenModeClear();                /* restore alphanumeric mode */
}

SetPixel( x, y )
int     x,y;            /* pixel coordinates */
{
        int     CharCode;
        int     CharScanLine;
        int     BitMask;
        int     CharDefOffset;

        CharCode = StartCharCode + (y/Points)*32 + x/8;
        CharScanLine = y % Points;            /* y MOD Points */
        BitMask = 0x80 >> (x % 8);            /* 10000000b SHR (x MOD 8) */

        CharDefOffset = CharCode*CGenDefSize + CharScanLine;
        CharDefTable[CharDefOffset] |= BitMask; /* OR the pixel */
}



---------------------------------------------------------------------------
Listing 10-16.  A routine to set pixels in a tiled graphics window on
                the MCGA.
---------------------------------------------------------------------------

SetPixel( x, y )
int     x,y;            /* pixel coordinates */
{
        int     CharCode;
        int     CharScanLine;
        int     BitMask;
        int     CharDefOffset;

        /* the window is 32 characters across */
        CharCode = StartCharCode + (y/Points)*32 + x/8;

        CharScanLine = y % Points;            /* y MOD Points */
        BitMask = 0x80 >> (x % 8);            /* 10000000b SHR (x MOD 8) */

        CharDefOffset = CharCode*2 + CharScanLine*512 + 1;
        CharDefTable[CharDefOffset] |= BitMask; /* OR the pixel */
}



---------------------------------------------------------------------------
Listing 11-1.  A routine to copy a block of pixels from the CGA video
               buffer to system RAM.
---------------------------------------------------------------------------

                TITLE   'Listing 11-1'
                NAME    GetBitBlock06
                PAGE    55,132

;
; Name:         GetBitBlock06
;
; Function:     Copy bit block from video buffer to system RAM
;                in 640x200 2-color mode
;
; Caller:       Microsoft C:
;
;                       int GetBitBlock06(x0,y0,x1,y1,buf);
;
;                            int x0,y0;    /* upper left corner of bit */
;                                          /*  block */
;                            int x1,y1;       /* lower right corner */
;                            char far *buf;   /* buffer */
;
; Notes:        Returns size of bit block in system RAM.

ARGx0           EQU     word ptr [bp+4]
ARGy0           EQU     word ptr [bp+6]
ARGx1           EQU     word ptr [bp+8]
ARGy1           EQU     word ptr [bp+10]
ADDRbuf         EQU              [bp+12]

VARPixelRows    EQU     word ptr [bp-2]
VARPixelRowLen  EQU     word ptr [bp-4]
VARincr         EQU     word ptr [bp-6]

ByteOffsetShift EQU     3               ; reflects number of pixels per
                                        ;  byte


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr06:near

                PUBLIC  _GetBitBlock06
_GetBitBlock06  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,6            ; establish stack frame
                push    ds
                push    si
                push    di

; compute dimensions of bit block

                mov     ax,ARGx1
                sub     ax,ARGx0

                mov     cx,0FF07h       ; CH := unshifted bit mask
                                        ; CL := AND mask for AL
                and     cl,al           ; CL := number of pixels in last
                                        ;        byte of row
                xor     cl,7            ; CL := number of bits to shift
                shl     ch,cl           ; CH := bit mask for last byte of
                                        ;        row
                mov     cl,ch
                push    cx              ; save on stack

                mov     cl,ByteOffsetShift
                shr     ax,cl
                inc     ax              ; AX := number of bytes per row
                push    ax              ; save on stack

                mov     ax,ARGy1
                sub     ax,ARGy0
                inc     ax              ; AX := number of pixel rows
                push    ax              ; save on stack

; establish addressing

                mov     ax,ARGy0
                mov     bx,ARGx0
                call    PixelAddr06     ; ES:BX -> x0,y0 in video buffer
                xor     cl,7            ; CL := number of bits to shift
                                        ;        left
                push    es
                pop     ds
                mov     si,bx           ; DS:SI -> video buffer

                mov     bx,2000h        ; BX := increment from 1st to 2nd
                                        ;        interleave in CGA video
                                        ;        buffer
                test    si,2000h
                jz      L01             ; jump if x0,y0 is in 1st
                                        ;  interleave

                mov     bx,80-2000h     ; increment from 2nd to 1st
                                        ;  interleave

L01:            mov     VARincr,bx      ; initialize this variable

                les     di,ADDRbuf      ; ES:DI -> buffer in system RAM

; build 5-byte bit block header

                pop     ax
                mov     VARPixelRows,ax
                stosw                   ; byte 0-1 := number of pixel rows
                pop     ax
                mov     VARPixelRowLen,ax
                stosw                   ; byte 2-3 := bytes per pixel row
                pop     ax
                mov     ch,al           ; CH := bit mask for last byte
                stosb                   ; byte 4 := bit mask for last byte

; copy from video buffer to system RAM

L02:            mov     bx,VARPixelRowLen
                push    si              ; preserve SI at start of pixel row

L03:            lodsw                   ; AL := next byte in video buffer
                                        ; AH := (next byte) + 1
                dec     si              ; DS:SI -> (next byte) + 1
                rol     ax,cl           ; AL := next 4 pixels in row
                stosb                   ; copy to system RAM
                dec     bx              ; loop across row
                jnz     L03

                and     es:[di-1],ch    ; mask last byte of row         
                pop     si              ; DS:SI -> start of row
                add     si,VARincr      ; DS:SI -> start of next row
                xor     VARincr,2000h XOR (80-2000H)  ; update increment

                dec     VARPixelRows
                jnz     L02             ; loop down rows

                mov     ax,di
                sub     ax,ADDRbuf      ; AX := return value (size of bit
                                        ;        block in system RAM)

                pop     di              ; restore registers and exit
                pop     si
                pop     ds
                mov     sp,bp
                pop     bp
                ret

_GetBitBlock06  ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 11-2.  A routine to copy a block of pixels from system RAM to
               the CGA video buffer.
---------------------------------------------------------------------------

                TITLE   'Listing 11-2'
                NAME    StoreBitBlock06
                PAGE    55,132

;
; Name:         StoreBitBlock06
;
; Function:     Copy bit block from video buffer to system RAM
;                in 640x200 2-color mode
;
; Caller:       Microsoft C:
;
;                       void StoreBitBlock06(buf,x,y);
;
;                            char far *buf;   /* buffer */
;                            int x,y;         /* upper left corner of */
;                                             /*  bit block */
;

ADDRbuf         EQU     dword ptr [bp+4]
ARGx            EQU     word ptr [bp+8]
ARGy            EQU     word ptr [bp+10]

VARPixelRows    EQU     word ptr [bp-2]
VARPixelRowLen  EQU     word ptr [bp-4]
VARincr         EQU     word ptr [bp-6]


DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                EXTRN   PixelAddr06:near

                PUBLIC  _StoreBitBlock06
_StoreBitBlock06 PROC   near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,6            ; establish stack frame
                push    ds
                push    si
                push    di

; establish addressing

                mov     ax,ARGy
                mov     bx,ARGx
                call    PixelAddr06     ; ES:BX -> byte offset of x,y
                xor     cl,7            ; CL := number of bits to shift
                                        ;        right

                mov     di,bx           ; ES:DI -> x,y in video buffer
                mov     bx,2000h        ; BX := increment from 1st to 2nd
                                        ;        interleave in CGA video
                                        ;        buffer
                test    di,2000h
                jz      L01             ; jump if x,y is in 1st interleave

                mov     bx,80-2000h     ; increment from 2nd to 1st
                                        ;  interleave

L01:            mov     VARincr,bx      ; initialize this variable

                mov     bx,StoreBitBlockOp  ; BX := subroutine address

                lds     si,ADDRbuf      ; ES:DI -> buffer in system RAM

; obtain dimensions of bit block from header

                lodsw                   ; AX := number of pixel rows
                mov     VARPixelRows,ax
                lodsw                   ; AX := bytes per pixel row
                mov     VARPixelRowLen,ax
                lodsb                   ; AL := bit mask for last byte in
                                        ;        row

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                mov     ch,al

                jmp     bx              ; jump to subroutine

ReplaceBitBlock:
                cmp     cx,0FF00h       ; if mask = 0FFH and bits to 
                                        ;  shift = 0
                jnz     L15             ;  jump if not byte-aligned

; routine for byte-aligned bit blocks

                mov     cx,VARPixelRowLen

L10:            push    di              ; preserve DI and CX
                push    cx
                rep     movsb           ; copy one pixel row into video
                                        ;  buffer
                pop     cx              ; restore DI and CX
                pop     di
                add     di,VARincr      ; ES:DI -> next pixel row in buffer
                xor     VARincr,2000h XOR (80-2000h) ; update increment
                dec     VARPixelRows
                jnz     L10             ; loop down pixel rows

                jmp     Lexit

; routine for all other bit blocks

L15:            not     ch              ; CH := mask for end of row
                mov     dx,0FF00h
                ror     dx,cl           ; DX := rotated mask for each byte

                mov     bx,VARPixelRowLen
                dec     bx              ; BX := bytes per row - 1

L16:            push    di
                test    bx,bx
                jz      L18             ; jump if only one byte per row

                push    bx

L17:            and     es:[di],dx      ; mask next 8 pixels in video
                                        ;  buffer
                lodsb                   ; AL := pixels in bit block
                xor     ah,ah
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                or      es:[di],ax      ; set pixels in video buffer
                inc     di              ; ES:DI -> next byte in bit block
                dec     bx
                jnz     L17

                pop     bx

L18:            mov     al,ch
                mov     ah,0FFh         ; AX := mask for last pixels in row
                ror     ax,cl           ; AX := mask rotated into position
                and     es:[di],ax      ; mask last pixels in video buffer
                lodsb                   ; AL := last byte in row
                xor     ah,ah
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                or      es:[di],ax      ; set pixels in video buffer

                pop     di
                add     di,VARincr      ; ES:DI -> next pixel row in buffer
                xor     VARincr,2000h XOR (80-2000h)
                dec     VARPixelRows
                jnz     L16             ; loop down pixel rows

                jmp     Lexit

XORBitBlock:
                mov     bx,VARPixelRowLen

L20:            push    di
                push    bx

L21:            lodsb                   ; AL := pixels in bit block
                xor     ah,ah
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                xor     es:[di],ax      ; XOR pixels into video buffer
                inc     di              ; ES:DI -> next byte in bit block
                dec     bx
                jnz     L21

                pop     bx
                pop     di
                add     di,VARincr      ; ES:DI -> next pixel row in buffer
                xor     VARincr,2000h XOR (80-2000h)
                dec     VARPixelRows
                jnz     L20             ; loop down pixel rows

                jmp     Lexit

ANDBitBlock:
                not     ch              ; CH := mask for end of row

                mov     bx,VARPixelRowLen
                dec     bx              ; BX := bytes per row - 1

L30:            push    di
                test    bx,bx
                jz      L32             ; jump if only one byte per row

                push    bx

L31:            lodsb                   ; AL := pixels in bit block
                mov     ah,0FFh
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                and     es:[di],ax      ; AND pixels into video buffer
                inc     di              ; ES:DI -> next byte in bit block
                dec     bx
                jnz     L31

                pop     bx

L32:            lodsb                   ; AL := last byte in row
                or      al,ch           ; mask last pixels in row
                mov     ah,0FFh
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                and     es:[di],ax      ; AND pixels into video buffer

                pop     di
                add     di,VARincr      ; ES:DI -> next pixel row in buffer
                xor     VARincr,2000h XOR (80-2000h)
                dec     VARPixelRows
                jnz     L30             ; loop down pixel rows

                jmp     Lexit


ORBitBlock:
                mov     bx,VARPixelRowLen

L40:            push    di
                push    bx

L41:            lodsb                   ; AL := pixels in bit block
                xor     ah,ah
                ror     ax,cl           ; AX := pixels rotated into
                                        ;        position
                or      es:[di],ax      ; OR pixels into video buffer
                inc     di              ; ES:DI -> next byte in bit block
                dec     bx
                jnz     L41

                pop     bx
                pop     di
                add     di,VARincr      ; ES:DI -> next pixel row in buffer
                xor     VARincr,2000h XOR (80-2000h)
                dec     VARPixelRows
                jnz     L40             ; loop down pixel rows


Lexit:          pop     di              ; restore registers and exit
                pop     si
                pop     ds
                mov     sp,bp
                pop     bp
                ret

_StoreBitBlock06 ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

StoreBitBlockOp DW      ReplaceBitBlock ; address of selected subroutine
                                        ;  (replace, XOR, AND, OR)

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 11-3.  A routine to copy a block of pixels from the EGA or VGA
               video buffer to system RAM in native graphics modes.
---------------------------------------------------------------------------

                TITLE   'Listing 11-3'
                NAME    GetBitBlock10
                PAGE    55,132

;
; Name:         GetBitBlock10
;
; Function:     Copy bit block from video buffer to system RAM
;                in native EGA and VGA graphics modes
;
; Caller:       Microsoft C:
;
;                       int GetBitBlock10(x0,y0,x1,y1,buf);
;

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;                            int x0,y0;       /* upper left corner of */
;                                             /*  bit block */
;                            int x1,y1;       /* lower right corner */
;                            char far *buf;   /* buffer */
;
; Notes:        Returns size of bit block in system RAM.
;


ARGx0           EQU     word ptr [bp+4]
ARGy0           EQU     word ptr [bp+6]
ARGx1           EQU     word ptr [bp+8]
ARGy1           EQU     word ptr [bp+10]
ADDRbuf         EQU              [bp+12]

VARPixelRows    EQU     word ptr [bp-2]
VARPixelRowLen  EQU     word ptr [bp-4]

BytesPerRow     EQU     80
ByteOffsetShift EQU     3               ; reflects number of pixels per
                                        ;  byte

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr10:near

                PUBLIC  _GetBitBlock10
_GetBitBlock10  PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,4            ; establish stack frame
                push    ds
                push    si
                push    di

; compute dimensions of bit block

                mov     ax,ARGx1
                sub     ax,ARGx0
                mov     cx,0FF07h       ; CH := unshifted bit mask
                                        ; CL := AND mask for AL
                and     cl,al           ; CL := number of pixels in last
                                        ;        byte of row
                xor     cl,7            ; CL := number of bits to shift
                shl     ch,cl           ; CH := bit mask for last byte of
                                        ;        row
                mov     cl,ch
                push    cx              ; save on stack

                mov     cl,ByteOffsetShift
                shr     ax,cl
                inc     ax              ; AX := number of bytes per row
                push    ax              ; save on stack

                mov     ax,ARGy1
                sub     ax,ARGy0
                inc     ax              ; AX := number of pixel rows
                push    ax              ; save on stack

; establish addressing

                mov     ax,ARGy0
                mov     bx,ARGx0
                call    PixelAddr10     ; ES:BX -> x0,y0 in video buffer
                xor     cl,7            ; CL := number of bits to shift
                                        ;        left
                push    es
                pop     ds
                mov     si,bx           ; DS:SI -> video buffer

                les     di,ADDRbuf      ; ES:DI -> buffer in system RAM

; build 5-byte bit block header

                pop     ax
                mov     VARPixelRows,ax
                stosw                   ; byte 0-1 := number of pixel rows
                pop     ax
                mov     VARPixelRowLen,ax
                stosw                   ; byte 2-3 := bytes per pixel row
                pop     ax
                mov     ch,al           ; CH := bit mask for last byte in
                                        ;        row
                stosb                   ; byte 4 := bit mask for last byte

; set up Graphics Controller

                mov     dx,3CEh         ; DX := Graphics Controller address
                                        ;        port

                mov     ax,0005         ; AH := 0 (read mode 0, write mode
                                        ;           0)
                                        ; AL := 5 (Mode register number)
                out     dx,ax           ; set up read mode 0
 
                mov     ax,0304h        ; AH := 3 (first bit plane to read)
                                        ; AL := 4 (Read Map Select reg
                                        ;           number)

; copy from video buffer to system RAM

L01:            out     dx,ax           ; select next memory map to read
                push    ax              ; preserve memory map number
                push    VARPixelRows    ; preserve number of pixel rows
                push    si              ; preserve offset of x0,y0

L02:            mov     bx,VARPixelRowLen
                push    si              ; preserve SI at start of pixel row

L03:            lodsw                   ; AL := next byte in video buffer
                                        ; AH := (next byte) + 1
                dec     si              ; DS:SI -> (next byte) + 1
                rol     ax,cl           ; AL := next 4 pixels in row
                stosb                   ; copy to system RAM
                dec     bx              ; loop across row
                jnz     L03

                and     es:[di-1],ch    ; mask last byte in row
                pop     si              ; DS:SI -> start of row
                add     si,BytesPerRow  ; DS:SI -> start of next row

                dec     VARPixelRows
                jnz     L02             ; loop down rows

                pop     si              ; DS:SI -> start of bit block
                pop     VARPixelRows    ; restore number of pixel rows
                pop     ax              ; AH := last map read
                                        ; AL := Read Map Select reg number
                dec     ah
                jns     L01             ; loop across bit planes

                mov     ax,di
                sub     ax,ADDRbuf      ; AX := return value (size of bit
                                        ;        block in system RAM)

                pop     di              ; restore registers and exit
                pop     si
                pop     ds
                mov     sp,bp
                pop     bp
                ret

_GetBitBlock10  ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 11-4.  A routine to copy a block of pixels from system RAM to
               the EGA or VGA video buffer in native graphics mode.
---------------------------------------------------------------------------

                TITLE   'Listing 11-4'
                NAME    StoreBitBlock10
                PAGE    55,132

;
; Name:         StoreBitBlock10
;
; Function:     Copy bit block from video buffer to system RAM
;                in native EGA and VGA graphics modes
;
; Caller:       Microsoft C:
;
;                       void StoreBitBlock10(buf,x,y);
;
;                            char far *buf;   /* buffer */
;                            int x,y;         /* upper left corner of */
;                                             /*  bit block */
;


ADDRbuf         EQU     dword ptr [bp+4]
ARGx            EQU     word ptr [bp+8]
ARGy            EQU     word ptr [bp+10]

VARPixelRows    EQU     word ptr [bp-2]
VARPixelRowLen  EQU     word ptr [bp-4]
VARRowCounter   EQU     word ptr [bp-6]
VARStartMask    EQU     word ptr [bp-8]
VAREndMaskL     EQU     word ptr [bp-10]
VAREndMaskR     EQU     word ptr [bp-12]

BytesPerRow     EQU     80              ; logical width of video buffer
ByteOffsetShift EQU     3               ; reflects number of pixels per
                                        ;  byte
RMWbits         EQU     18h             ; selects replace, XOR, AND, or OR

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr10:near

                PUBLIC  _StoreBitBlock10
_StoreBitBlock10 PROC   near

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

                push    bp              ; preserve caller registers
                mov     bp,sp
                sub     sp,12           ; establish stack frame
                push    ds
                push    si
                push    di

; establish addressing

                mov     ax,ARGy
                mov     bx,ARGx
                call    PixelAddr10     ; ES:BX -> byte offset of x,y
                inc     cl
                and     cl,7            ; CL := number of bits to shift
                                        ;        left

                mov     di,bx           ; ES:DI -> x,y in video buffer
                
                lds     si,ADDRbuf      ; ES:DI -> buffer in system RAM

; obtain dimensions of bit block from header

                lodsw                   ; AX := number of pixel rows
                mov     VARPixelRows,ax
                lodsw                   ; AX := bytes per pixel row
                mov     VARPixelRowLen,ax
                lodsb                   ; AL := bit mask for last byte in
                                        ;        row
                mov     ch,al

; set up Graphics Controller

                mov     dx,3CEh         ; DX := Graphics Controller I/O
                                        ;        port

                mov     ah,RMWbits      ; AH := value for Data Rotate/
                mov     al,3            ;        Function Select register
                out     dx,ax           ; update this register

                mov     ax,0805h        ; AH := 8 (read mode 1, write mode
                                        ;           0)
                                        ; AL := 5 (Mode register number)
                out     dx,ax           ; set up read mode 0

                mov     ax,0007         ; AH := 0 (don't care for all maps;
                                        ;           CPU reads always return
                                                    0FFH)
                                        ; AL := 7 (Color Don't Care reg
                                        ;           number)
                out     dx,ax           ; set up Color Don't Care reg

                mov     ax,0FF08h       ; AH := 0FFH (value for Bit Mask
                                        ;              reg)
                out     dx,ax           ; set up Bit Mask reg

                mov     dl,0C4h         ; DX := 3C4H (Sequencer I/O port)
                mov     ax,0802h        ; AH := 1000B (value for Map Mask
                                        ;               reg)
                                        ; AL := 2 (Map Mask register
                                        ;           number)

                cmp     cx,0FF00h       ; if mask <> 0FFH or bits to shift 
                jne     L15             ;  <> 0 jump if not byte-aligned

; routine for byte-aligned bit blocks

                mov     cx,VARPixelRowLen

L10:            out     dx,ax           ; enable one bit plane for writes
                push    ax              ; preserve Map Mask value
                push    di              ; preserve video buffer offset of
                                        ;  x,y
                mov     bx,VARPixelRows

L11:            push    di              ; preserve DI and CX
                push    cx

L12:            lodsb                   ; AL := next byte of pixels
                and     es:[di],al      ; update bit plane
                inc     di
                loop    L12
                pop     cx              ; restore DI and CX
                pop     di
                add     di,BytesPerRow  ; ES:DI -> next pixel row in buffer
                dec     bx
                jnz     L11             ; loop down pixel rows

                pop     di              ; ES:DI -> video buffer offset of
                                        ;  x,y
                pop     ax              ; AH := current Map Mask reg value
                shr     ah,1            ; AH := new Map Mask value
                jnz     L10             ; loop across all bit planes

                jmp     Lexit

; routine for non-aligned bit blocks

L15:            push    ax              ; preserve Map Mask reg values

                mov     bx,0FFh         ; BH := 0 (mask for first byte in
                                        ;           row)
                                        ; BL := 0FFh
                mov     al,ch           ; AL := mask for last byte in pixel
                                        ;        row
                cbw                     ; AH := 0FFh (mask for last-1 byte)

                cmp     VARPixelRowLen,1
                jne     L16             ; jump if more than one byte per
                                        ;  row

                mov     bl,ch
                mov     ah,ch           ; AH := mask for last-1 byte
                xor     al,al           ; AL := 0 (mask for last byte)

L16:            shl     ax,cl           ; shift masks into position
                shl     bx,cl

                mov     bl,al           ; save masks along with ...
                mov     al,8            ; Bit Mask register number
                mov     VAREndMaskL,ax
                mov     ah,bl
                mov     VAREndMaskR,ax
                mov     ah,bh
                mov     VARStartMask,ax

                mov     bx,VARPixelRowLen
                pop     ax              ; restore Map Mask reg values

; set pixels row by row in the bit planes

L17:            out     dx,ax           ; enable one bit plane for writes
                push    ax              ; preserve Map Mask value
                push    di              ; preserve video buffer offset of
                                        ;  x,y
                mov     dl,0CEh         ; DX := 3CEH (Graphics Controller
                                        ;              port)

                mov     ax,VARPixelRows
                mov     VARRowCounter,ax  ; initialize loop counter

; set pixels at start of row in currently enabled bit plane

L18:            push    di              ; preserve offset of start of pixel
                                        ;  row
                push    si              ; preserve offset of row in bit
                                        ;  block
                push    bx              ; preserve bytes per pixel row

                mov     ax,VARStartMask
                out     dx,ax           ; set Bit Mask reg for first byte
                                        ;  of row

                lodsw                   ; AH := 2nd byte of pixels
                                        ; AL := 1st byte of pixels
                dec     si              ; DS:SI -> 2nd byte of pixels
                test    cl,cl
                jnz     L19             ; jump if not left-aligned

                dec     bx              ; BX := bytes per row - 1
                jnz     L20             ; jump if at least 2 bytes per row
                jmp     short L22       ; jump if only one byte per row

L19:            rol     ax,cl           ; AH := left part of 1st byte,
                                        ;        right part of 2nd byte
                                        ; AL := right part of 1st byte,
                                        ;        left part of 2nd byte
                and     es:[di],ah      ; set pixels for left part of first
                                        ;  byte
                inc     di
                dec     bx              ; BX := bytes per row - 2

L20:            push    ax              ; preserve pixels
                mov     ax,0FF08h
                out     dx,ax           ; set Bit Mask reg for succeeding
                                        ;  bytes
                pop     ax

                dec     bx
                jng     L22             ; jump if only 1 or 2 bytes in
                                        ;  pixel row

; set pixels in middle of row

L21:            and     es:[di],al      ; set pixels in right part of
                inc     di              ;  current byte and left part of
                                        ;  next byte

                lodsw                   ; AH := next+1 byte of pixels
                dec     si              ; AL := next byte of pixels
                rol     ax,cl           ; AH := left part of next byte,
                                        ;        right part of next+1 byte
                                        ; AL := right part of next byte,
                                        ;        left part of next+1 byte
                dec     bx
                jnz     L21             ; loop across pixel row

; set pixels at end of row

L22:            mov     bx,ax           ; BH := right part of last byte,

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                                        ;        left part of last-1 byte
                                        ; BL := left part of last byte,
                                        ;        right part of last-1 byte
                mov     ax,VAREndMaskL  ; AH := mask for last-1 byte
                                        ; AL := Bit Mask reg number

                out     dx,ax           ; set Bit Mask register
                and     es:[di],bl      ; set pixels for last-1 byte

                mov     ax,VAREndMaskR  ; mask for last byte in pixel row
                out     dx,ax           ; last byte in pixel row
                and     es:[di+1],bh    ; set pixels for last byte

                pop     bx              ; BX := bytes per pixel row
                pop     si
                add     si,bx           ; DS:SI -> next row in bit block
                pop     di
                add     di,BytesPerRow  ; ES:DI -> next pixel row in buffer
                dec     VARRowCounter
                jnz     L18             ; loop down pixel rows

                pop     di              ; ES:DI -> video buffer offset of
                                        ;  x,y
                pop     ax              ; AX := current Map Mask value
                mov     dl,0C4h         ; DX := 3C4H
                shr     ah,1            ; AH := next Map Mask value
                jnz     L17             ; loop across bit planes

; restore Graphics Controller and Sequencer to their default states

Lexit:          mov     ax,0F02h        ; default Map Mask value
                out     dx,ax

                mov     dl,0CEh         ; DX := 3CEh
                mov     ax,0003         ; default Data Rotate/Function
                                        ;  Select
                out     dx,ax

                mov     ax,0005         ; default Mode value
                out     dx,ax

                mov     ax,0F07h        ; default Color Compare value
                out     dx,ax

                mov     ax,0FF08h       ; default Bit Mask value
                out     dx,ax

                pop     di              ; restore registers and exit
                pop     si
                pop     ds
                mov     sp,bp
                pop     bp
                ret

_StoreBitBlock10 ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 11-5.  XORing a circle into the video buffer.
---------------------------------------------------------------------------

/* Listing 11-5 */

main()
{
        int     xc      = 400;          /* center of circle */
        int     yc      = 125;
        int     a,b;                    /* semimajor and semiminor axes */
        int     n = 12;                 /* pixel value */
        int     i;
        float   ScaleFactor = 1.37;     /* for 640x350 16-color mode */

        for( i=0; i<10; i++ )
          for( a=0; a<100; a++ )
          {
            b = (float) a / ScaleFactor;      /* scale semiminor axis */
            Ellipse( xc, yc, a, b, n );       /* draw a circle */
            Ellipse( xc, yc, a, b, n );       /* draw it again */
          }
}



---------------------------------------------------------------------------
Listing 11-6.  XORing a rectangle into the video buffer.
---------------------------------------------------------------------------

/* Listing 11-6 */

#define Xmax    640

main()
{
        int     x0      = 0;            /* corners of box at 0,0 and */
                                        /*  150,100 */
        int     y0      = 0;
        int     x1      = 150;
        int     y1      = 100;
        int     n = 12;                 /* pixel value */


        while( x1 < Xmax )                      /* slide box right */
          XORBox( x0++, y0, x1++, y1, n );

        while( x0 > 0 )                         /* slide box left */
          XORBox( --x0, y0, --x1, y1, n );
}


XORBox ( x0, y0, x1, y1, n )
int     x0,y0,x1,y1;            /* pixel coordinates of opposite corners */
int     n;                      /* pixel value */
{
        Rectangle( x0, y0, x1, y1, n );         /* draw the box */
        Rectangle( x0, y0, x1, y1, n );         /* erase the box */
}

Rectangle( x0, y0, x1, y1, n )
int     x0,y0,x1,y1;
int     n;
{
        Line( x0, y0, x0, y1, n );
        Line( x0, y0, x1, y0, n );
        Line( x1, y1, x0, y1, n );
        Line( x1, y1, x1, y0, n );
}



---------------------------------------------------------------------------
Listing 11-7.  XORing a line into the video buffer.
---------------------------------------------------------------------------

/* Listing 11-7 */

#define Xmax    640                     /* screen dimensions in */
                                        /*  640x350 mode */
#define Ymax    350

main()
{
        int     x0      = 150;          /* fixed endpoint at 150,100 */
        int     y0      = 100;
        int     x       = 0;            /* moving endpoint at 0,0 */
        int     y       = 0;
        int     n       = 12;           /* pixel value */


        for( ; x<Xmax; x++ )                    /* move right */
          XORLine( x0, y0, x, y, n );

        for( --x; y<Ymax; y++ )                 /* move down */
          XORLine( x0, y0, x, y, n );

        for( --y; x>=0; --x )                   /* move left */
          XORLine( x0, y0, x, y, n );

        for( x++; y>=0; --y )                   /* move up */
          XORLine( x0, y0, x, y, n );
}


XORLine ( x0, y0, x1, y1, n )
int     x0,y0,x1,y1;            /* endpoints */
int     n;                      /* pixel value */
{
        Line( x0, y0, x1, y1, n );            /* the line is onscreen */
        Line( x0, y0, x1, y1, n );            /* the line is erased */
}



---------------------------------------------------------------------------
Listing 11-8.  A program to move a block of pixels using the
               overlapping technique.
---------------------------------------------------------------------------

char far buf[(32/4)*21+5];      /* bit block buffer large enough */
                                /*  to contain a 32- by 21-pixel block */

Line(  1, 10, 21, 10, Fgd );    /* a right-pointing arrowhead */
Line( 21,  0, 31, 10, Fgd );    /*  in a 32- by 21-pixel bit block */
Line( 21, 20, 31, 10, Fgd );
Line( 21,  0, 21, 20, Fgd );

GetBitBlock( 0, 0, 31, 20, buf );       /* copy the bit block to */
                                        /*  system RAM */
for ( i = 0; i < 300; i++ )
  StoreBitBlock( buf, i, 0 );           /* slide rightward */



---------------------------------------------------------------------------
Listing 12-1.  Handling Vertical Interrupts on the EGA and VGA.
---------------------------------------------------------------------------

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

                TITLE   'Listing 12-1'
                NAME    VREGA
                PAGE    55,132

;
; Name:         VREGA
;
; Function:     Vertical Interrupt Service routine for EGA and VGA
;
; Caller:       Microsoft C:
;
;                       int EnableISR0A();      /* returns 0 if */
;                                               /*  installed ok */
;
;                       void DisableISR0A();
;

CRT_MODE        EQU     49h             ; addresses in video BIOS data area
ADDR_6845       EQU     63h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

ISR0A           PROC    far             ; Interrupt handler for INT 0Ah

                push    ax              ; preserve registers
                push    dx
                push    ds

                mov     ax,seg DGROUP
                mov     ds,ax           ; DS -> DGROUP

; determine whether a Vertical Interrupt has occurred

                mov     dx,3C2h         ; DX := I/O port for
                                        ;        Input Status Register Zero
                in      al,dx
                test    al,80h          ; test bit 7 of the Status Reg
                                        ;  value
                jnz     L10             ; jump if vertical interrupt

; not a Vertical Interrupt so chain to previous interrupt handler

                pushf                   ; simulate an INT
                call    ds:PrevISR0A    ;  to the previous INT 0Ah handler
                jmp     short Lexit

; handle a Vertical Interrupt

L10:            mov     dx,Port3x4      ; DX := 3B4h or 3D4h

                in      al,dx           ; AL := value of CRTC address reg
                push    ax              ; preserve this value

                mov     ax,DefaultVREnd ; AH := default value for VR End
                                        ;        reg
                                        ; AL := 11h (register number)
                and     ah,11101111b    ; AH bit 4 := 0 (clear interrupt
                                        ;                 latch)
                out     dx,ax           ; update VR End register
                jmp     $+2             ; wait for CRTC to respond

; send End of Interrupt to Intel 8259A Programmable Interrupt Controller
;  to allow subsequent IRQ2 interrupts to occur

                mov     al,20h          ; 8259A I/O port
                out     20h,al          ; send nonspecific EOI to 8259A
                jmp     $+2             ; wait for PIC to respond
                sti                     ; enable interrupts

; do something useful ...

                inc     word ptr _VRcount       ; increment a counter

; enable CRTC to generate another interrupt

                cli                     ; disable interrupts
                mov     ax,DefaultVREnd ; AH := default value for VR End
                                        ;        reg
                                        ; AL := 11h (register number)
                and     ah,11011111b    ; AH bit 5 := 0 (enable vertical
                                        ;                 int)
                or      ah,00010000b    ; AH bit 4 := 1 (enable int latch)
                out     dx,ax
                jmp     $+2

                pop     ax
                out     dx,al           ; restore previous Address reg
                                        ;  value

Lexit:          pop     ds              ; restore registers and exit
                pop     dx
                pop     ax
                iret


ISR0A           ENDP

;
; EnableISR0A -- enable Vertical Interrupt Handler
;
                PUBLIC  _EnableISR0A
_EnableISR0A    PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si
                push    di

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area

; save default CRTC register values

                mov     dx,es:[ADDR_6845]  ; DX := CRTC Address port
                mov     Port3x4,dx      ; save port address

                mov     ax,1A00h        ; AH := 1AH (INT 10H function
                                        ;             number)
                                        ; AL := 0 (read Display
                                        ;           Combination)
                int     10h             ; AL := 1AH if function 1AH
                                        ;        supported
                                        ; BL := active video subsystem
                cmp     al,1Ah
                jne     L20             ; jump if not a VGA

                cmp     bl,7
                je      L21             ; jump if VGA

                cmp     bl,8
                je      L21             ; jump if VGA

                mov     ax,0FFFFh       ; return 0FFFFh if neither EGA nor
                                        ;  VGA
                jmp     short L23

; get default value for EGA Vertical Retrace End register

L20:            mov     al,es:[CRT_MODE]  ; AL := video BIOS mode number
                mov     bx,offset DGROUP:EGADefaultVals
                xlat                    ; AL := default value for VR End
                                        ;        reg
                jmp     short L22

; get default value for VGA Vertical Retrace End register

L21:            mov     al,VREndReg     ; AL := VR End register number
                out     dx,al
                inc     dx              ; DX := 3B5H or 3D5H
                in      al,dx           ; AL := current value for register

L22:            mov     VREndValue,al   ; save this value

; save old interrupt 0Ah vector

                mov     ax,350Ah        ; AH := 35H (INT 21h function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h             ; ES:BX := previous INT 0AH vector

                mov     word ptr PrevISR0A,bx
                mov     word ptr PrevISR0A+2,es ; save previous vector

; update interrupt 0AH vector with address of this handler

                push    ds              ; preserve DS
                mov     dx,offset ISR0A
                push    cs
                pop     ds              ; DS:DX -> ISR0A
                mov     ax,250Ah        ; AH := 25H (INT 21H function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h             ; update INT 0AH vector
                pop     ds              ; restore DS

; enable IRQ2 by zeroing bit 2 of the 8259A's mask register

                cli                     ; clear interrupts
                mov     dx,21h          ; DX := 8259A mask register
                in      al,dx           ; AL := mask register value
                and     al,11111011b    ; reset bit 2
                out     dx,al

; enable vertical interrupts

                mov     dx,Port3x4      ; DX := 3B4H or 3D4H
                mov     ax,DefaultVREnd

                and     ah,11001111b
                out     dx,ax           ; clear bits 4 and 5 of VR End reg
                jmp     $+2             ; wait for CRTC to respond
                or      ah,00010000b
                out     dx,ax           ; set bit 4
                jmp     $+2
                sti                     ; enable interrupts


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                xor     ax,ax           ; AX := 0 (return value)

L23:            pop     di              ; restore registers and exit
                pop     si
                mov     sp,bp
                pop     bp
                ret

_EnableISR0A    ENDP

;
; DisableISR0A -- disable Vertical Interrupt Handler
;
                PUBLIC  _DisableISR0A
_DisableISR0A   PROC    near


                push    bp
                mov     bp,sp
                push    si
                push    di
                push    ds

; disable vertical interrupts

                cli                     ; disable interrupts
                mov     dx,Port3x4
                mov     ax,DefaultVREnd
                out     dx,ax           ; restore Vertical Retrace End reg
                jmp     $+2
                sti                     ; enable interrupts

; restore previous interrupt 0Ah handler

                lds     dx,PrevISR0A    ; DS:DX := previous INT 0AH vector
                mov     ax,250Ah        ; AH := 25H (INT 21H function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h


                pop     ds              ; restore registers and exit
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisableISR0A   ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

                EXTRN   _VRcount:word   ; declared in C caller

PrevISR0A       DD      ?               ; save area for old int 0Ah vector
Port3x4         DW      ?               ; 3B4h or 3D4h

DefaultVREnd    LABEL   word
VREndReg        DB      11h             ; Vertical Retrace End register
                                           number
VREndValue      DB      ?               ; default value for VR End register

EGADefaultVals  DB      2Bh,2Bh,2Bh,2Bh,24h,24h,23h,2Eh ; default values
                DB      00h,00h,00h,00h,00h,24h,23h,2Eh ;  for EGA VR End
                                                        ;  reg
                DB      2Bh

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 12-2.  Using a Vertical Interrupt handler in a C program.
---------------------------------------------------------------------------

/* Listing 12-2 */

int     VRcount = 0;            /* vertical interrupt counter */

main()
{
        if ( EnableISR0A() )
        {
          printf( "\nCan't enable vertical interrupt handler\n" );
          exit( 1 );
        }

        while (VRcount < 600)
          printf( "\015Number of vertical interrupts:  %d", VRcount );

        DisableISR0A();
}



---------------------------------------------------------------------------
Listing 12-3.  Handling Vertical Interrupts on the MCGA.
---------------------------------------------------------------------------

                TITLE   'Listing 12-3'
                NAME    VRMCGA
                PAGE    55,132

;
; Name:         VRMCGA
;
; Function:     Vertical Interrupt Service routine for MCGA
;
; Caller:       Microsoft C:
;
;                       int EnableISR0A();      /* returns 0 if */
;                                               /*  installed ok */
;
;                       void DisableISR0A();
;

ADDR_6845       EQU     63h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

ISR0A           PROC    far             ; Interrupt handler for INT 0Ah

                push    ax              ; preserve registers
                push    dx
                push    ds

                mov     ax,seg DGROUP
                mov     ds,ax           ; DS -> DGROUP

                mov     dx,Port3x4      ; DX := CRTC Address reg number
                in      al,dx
                push    ax              ; preserve CRTC Address reg value

; determine whether a Vertical Interrupt has occurred

                mov     al,IContReg     ; AL := register number
                out     dx,al
                jmp     $+2             ; wait for MCGA to respond
                inc     dx              ; DX := 3D5H
                in      al,dx           ; AL := current Interrupt Control
                                        ;        register value
                dec     dx
                test    al,40h          ; test bit 6
                jnz     L10             ; jump if Vertical Interrupt

; not a Vertical Interrupt so chain to previous interrupt handler

                pushf                   ; simulate an INT to the
                call    ds:PrevISR0A    ;  previous INT 0Ah handler
                jmp     short Lexit

; handle a Vertical Interrupt

L10:            mov     ax,DefaultICont ; AH := default value for
                                        ;        Interrupt Control register
                                        ; AL := 11h (register number)
                and     ah,11101111b    ; AH bit 4 := 0 (clear interrupt
                                        ;                 latch)
                out     dx,ax           ; update Interrupt Control reg
                jmp     $+2             ; wait for MCGA to respond

; send End of Interrupt to Programmable Interrupt Controller
;  to allow subsequent IRQ2 interrupts to occur

                mov     al,20h          ; PIC I/O port
                out     20h,al          ; send nonspecific EOI to PIC
                jmp     $+2             ; wait for PIC to respond
                sti                     ; enable interrupts

; do something useful ...

                inc     word ptr _VRcount       ; increment a counter

; enable CRTC to generate another interrupt

                cli                     ; disable interrupts
                mov     ax,DefaultICont ; AH := default value for
                                        ;        Interrupt Control register
                                        ; AL := 11h (register number)
                and     ah,11011111b    ; AH bit 5 := 0 (enable Vert Int)
                or      ah,00010000b    ; AH bit 4 := 1 (enable int latch)
                out     dx,ax
                jmp     $+2

Lexit:          pop     ax
                out     dx,al           ; restore previous 3D4H value

                pop     ds              ; restore registers and exit
                pop     dx
                pop     ax
                iret

ISR0A           ENDP

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

;
; EnableISR0A -- enable Vertical Interrupt Handler
;
                PUBLIC  _EnableISR0A
_EnableISR0A    PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si
                push    di

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area

; save default CRTC register values

                mov     dx,es:[ADDR_6845]  ; DX := CRTC Address port
                mov     Port3x4,dx      ; save port address

                mov     ax,1A00h        ; AH := 1AH (INT 10H function
                                        ;             number)
                                        ; AL := 0 (read Display
                                        ;           Combination)
                int     10h             ; AL := 1AH if function 1AH
                                        ;        supported
                                        ; BL := active video subsystem
                cmp     al,1Ah
                jne     L20             ; jump if not an MCGA

                cmp     bl,0Bh
                je      L21             ; jump if MCGA

                cmp     bl,0Ch
                je      L21             ; jump if MCGA

L20:            mov     ax,0FFFFh       ; return 0FFFFh if not an MCGA
                jmp     short L23

; get default value for MCGA Interrupt Control register

L21:            mov     al,IContReg     ; AL := Interrupt Control reg
                                        ;        number
                cli
                out     dx,al
                jmp     $+2
                inc     dx              ; DX := 3D5H
                in      al,dx           ; AL := current value for register
                sti

                mov     IContValue,al   ; save this value

; save old interrupt 0Ah vector

                mov     ax,350Ah        ; AH := 35H (INT 21h function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h             ; ES:BX := previous INT 0AH vector

                mov     word ptr PrevISR0A,bx
                mov     word ptr PrevISR0A+2,es ; save previous vector

; update interrupt 0AH vector with address of this handler

                push    ds              ; preserve DS
                mov     dx,offset ISR0A
                push    cs
                pop     ds              ; DS:DX -> ISR0A
                mov     ax,250Ah        ; AH := 25H (INT 21H function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h             ; update INT 0AH vector
                pop     ds              ; restore DS

; enable IRQ2 by zeroing bit 2 of the PIC's mask register

                cli                     ; clear interrupts
                mov     dx,21h          ; DX := PIC mask register
                in      al,dx           ; AL := mask register value
                and     al,11111011b    ; reset bit 2
                out     dx,al

; enable Vertical Interrupts

                mov     dx,Port3x4      ; DX := CRTC Address port
                mov     ax,DefaultICont

                and     ah,11001111b
                out     dx,ax           ; clear bits 4 and 5 of Int Control
                                        ;  reg
                jmp     $+2             ; wait for MCGA to respond
                or      ah,00010000b
                out     dx,ax           ; set bit 4
                jmp     $+2
                sti                     ; enable interrupts

                xor     ax,ax           ; AX := 0 (return value)

L23:            pop     di              ; restore registers and exit
                pop     si
                mov     sp,bp
                pop     bp
                ret

_EnableISR0A    ENDP

;
; DisableISR0A -- disable Vertical Interrupt handler
;
                PUBLIC  _DisableISR0A
_DisableISR0A   PROC    near

                push    bp
                mov     bp,sp
                push    si
                push    di
                push    ds

; disable Vertical Interrupts

                cli                     ; disable interrupts
                mov     dx,Port3x4
                mov     ax,DefaultICont
                out     dx,ax           ; restore Interrupt Control
                                        ;  register
                jmp     $+2
                sti                     ; enable interrupts

; restore previous interrupt 0Ah handler

                lds     dx,PrevISR0A    ; DS:DX := previous INT 0AH vector
                mov     ax,250Ah        ; AH := 25H (INT 21H function
                                        ;             number)
                                        ; AL := 0AH (interrupt number)
                int     21h

                pop     ds              ; restore registers and exit
                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_DisableISR0A   ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

                EXTRN   _VRcount:word   ; declared in C caller

PrevISR0A       DD      ?               ; save area for old int 0Ah vector
Port3x4         DW      ?               ; 3B4h or 3D4h

DefaultICont    LABEL   word
IContReg        DB      11h             ; Interrupt Control register number
IContValue      DB      ?               ; default value for Int Control reg

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 12-4.  Setting the screen origin on the EGA and VGA.
---------------------------------------------------------------------------

                TITLE   'Listing 12-4'
                NAME    ScreenOrigin
                PAGE    55,132

;
; Name:         ScreenOrigin
;
; Function:     Set screen origin on EGA and VGA
;
; Caller:       Microsoft C:
;
;                       void ScreenOrigin(x,y);
;
;                               int     x,y;    /* pixel x,y coordinates */
;

ARGx            EQU     [bp+4]
ARGy            EQU     [bp+6]


CRT_MODE        EQU     49h             ; addresses in video BIOS data area
ADDR_6845       EQU     63h
POINTS          EQU     85h
BIOS_FLAGS      EQU     89h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _ScreenOrigin


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
_ScreenOrigin   PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si
                push    di

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area
                mov     cl,es:[CRT_MODE]

                mov     ax,ARGx         ; AX := pixel x-coordinate
                mov     bx,ARGy         ; BX := pixel y-coordinate

                cmp     cl,7
                ja      L01             ; jump if graphics mode

                je      L02             ; jump if monochrome alpha
                test    byte ptr es:[BIOS_FLAGS],1
                jnz     L02             ; jump if VGA
                jmp     short L03

; setup for graphics modes (8 pixels per byte)

L01:            mov     cx,8            ; CL := 8 (displayed pixels per
                                        ;           byte)
                                        ; CH := 0
                div     cl              ; AH := bit offset in byte
                                        ; AL := byte offset in pixel row
                mov     cl,ah           ; CL := bit offset (for Horiz Pel
                                        ;                    Pan)
                xor     ah,ah
                xchg    ax,bx           ; AX := y
                                        ; BX := byte offset in pixel row

                mul     word ptr _BytesPerRow
                                        ; AX := byte offset of start of row
                jmp     short L05

; setup for VGA alphanumeric modes and EGA monochrome alphanumeric mode
;  (9 pixels per byte)

L02:                                    ; routine for alpha modes
                mov     cx,9            ; CL := 9 (displayed pixels per
                                        ;           byte)
                                        ; CH := 0
                div     cl              ; AH := bit offset in byte
                                        ; AL := byte offset in pixel row
                dec     ah              ; AH := -1, 0-7
                jns     L04             ; jump if bit offset 0-7
                mov     ah,8            ; AH := 8
                jmp     short L04
; setup for EGA color alphanumeric modes (8 pixels per byte)

L03:            mov     cx,8            ; CL := 8 (displayed pixels per
                                        ;           byte)
                                        ; CH := 0
                div     cl              ; AH := bit offset in byte
                                        ; AL := byte offset in pixel row

L04:            mov     cl,ah           ; CL := value for Horiz Pel Pan reg
                xor     ah,ah
                xchg    ax,bx           ; AX := y
                                        ; BX := byte offset in row
                div     byte ptr es:[POINTS]  ; AL := character row
                                              ; AH := scan line in char
                                              ;        matrix
                xchg    ah,ch           ; AX := character row
                                        ; CH := scan line (value for Preset
                                        ;                   Row Scan
                                        ;                   register)
                mul     word ptr _BytesPerRow   ; AX := byte offset of char
                                                         row
                shr     ax,1            ; AX := word offset of character
                                                 row

L05:            call    SetOrigin

                pop     di              ; restore registers and exit
                pop     si
                mov     sp,bp
                pop     bp
                ret

_ScreenOrigin   ENDP


SetOrigin       PROC    near            ; Caller:  AX = offset of character
                                        ;                row
                                        ;          BX = byte offset within
                                        ;                row
                                        ;          CH = Preset Row Scan
                                        ;                value
                                        ;          CL = Horizontal Pel Pan
                                        ;                value

                add     bx,ax           ; BX := buffer offset

                mov     dx,es:[ADDR_6845]  ; CRTC I/O port (3B4H or 3D4H)
                add     dl,6            ; video status port (3BAH or 3DAH)

; update Start Address High and Low registers

L20:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,8
                jz      L20

L21:            in      al,dx           ; wait for end of vertical retrace
                test    al,8
                jnz     L21

                cli                     ; disable interrupts
                sub     dl,6            ; DX := 3B4H or 3D4H

                mov     ah,bh           ; AH := value for Start Address
                                        ;        High
                mov     al,0Ch          ; AL := Start Address High reg
                                        ;        number
                out     dx,ax           ; update this register

                mov     ah,bl           ; AH := value for Start Address Low
                inc     al              ; AL := Start Address Low reg
                                        ;        number
                out     dx,ax           ; update this register
                sti                     ; enable interrupts

                add     dl,6            ; DX := video status port

L22:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,8
                jz      L22

                cli                     ; disable interrupts

                sub     dl,6            ; DX := 3B4H or 3D4H
                mov     ah,ch           ; AH := value for Preset Row Scan
                                        ;        reg
                mov     al,8            ; AL := Preset Row Scan reg number
                out     dx,ax           ; update this register

                mov     dl,0C0h         ; DX := 3C0h (Attribute Controller
                                        ;              port)
                mov     al,13h OR 20h   ; AL bit 0-4 := Horiz Pel Pan reg
                                        ;                number
                                        ; AL bit 5 := 1
                out     dx,al           ; write Attribute Controller
                                        ;  Address reg
                                        ;   (The Attribute Controller
                                        ;    address flip-flop.)
                mov     al,cl           ; AL := value for Horiz Pel Pan reg
                out     dx,al           ; update this register

                sti                     ; reenable interrupts
                ret

SetOrigin       ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

                EXTRN   _BytesPerRow:word       ; bytes per pixel row

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing 12-5.  A routine to perform smooth pixel-by-pixel panning on
               an EGA or VGA.
---------------------------------------------------------------------------

Pan( x0, y0, x1, y1 )
int     x0,y0;          /* starting pixel coordinates */
int     x1,y1;          /* ending pixel coordinates */
{
        int     i = x0;
        int     j = y0;
        int     Xinc,Yinc;      /* horizontal and vertical increments */


        if ( x0 < x1 )          /* compute signs of increments */
          Xinc = 1;
        else
          Xinc = -1;

        if ( y0 < y1 )
          Yinc = 1;
        else
          Yinc = -1;

        while ( (i != x1) || (j != y1) )
        {
          if (i != x1)                  /* compute next screen origin */
            i += Xinc;

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
          if (j != y1)
            j += Yinc;

          ScreenOrigin( i, j );         /* move screen origin */
        }
}



---------------------------------------------------------------------------
Listing 12-6a.  Redimensioning the video buffer.
---------------------------------------------------------------------------

                TITLE   'Listing 12-6a'
                NAME    BufferDims
                PAGE    55,132

;
; Name:         BufferDims
;
; Function:     Set video buffer dimensions on EGA
;
; Caller:       Microsoft C:
;
;                       void BufferDims(x,y);
;
;                             int     x,y;    /* horizontal and vertical */
;                                             /*  dimensions in pixels */
;

ARGx            EQU     word ptr [bp+4]
ARGy            EQU     word ptr [bp+6]


CRT_MODE        EQU     49h             ; addresses in video BIOS data area
CRT_COLS        EQU     4Ah
CRT_LEN         EQU     4Ch
ADDR_6845       EQU     63h
ROWS            EQU     84h
POINTS          EQU     85h

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _BufferDims
_BufferDims     PROC    near

                push    bp              ; preserve BP
                mov     bp,sp

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area

; determine width of displayed character matrix (8 or 9 pixels)

                mov     bx,8            ; BX := 8 pixels wide
                cmp     byte ptr es:[CRT_MODE],7  ; check BIOS mode number
                jne     L01             ; jump if not monochrome

                inc     bx              ; BX := 9 pixels wide

; update video BIOS data area

L01:            mov     ax,ARGx         ; AX := number of pixels per row
                div     bl              ; AL := number of character columns
                mov     es:[CRT_COLS],al
                mov     bh,al           ; BH := number of character columns

                mov     ax,ARGy         ; DX:AX := number of pixel rows
                div     byte ptr es:[POINTS]  ; AL := number of character
                                              ;        rows
                dec     al
                mov     es:[ROWS],al

                inc     al
                mul     bh              ; AX := character rows * character
                                        ;        cols
                mov     es:[CRT_LEN],ax ; update video BIOS data area

; update CRTC Offset register

                mov     ah,bh
                shr     ah,1            ; AH := number of words per row
                mov     al,13h          ; AL := CRTC Offset register number
                mov     dx,es:[ADDR_6845]  ; DX := 3B4H or 3D4H
                out     dx,ax

                pop     bp              ; restore BP and exit
                ret

_BufferDims     ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 12-6b.  Creating a 160-by-102 alphanumeric mode.
---------------------------------------------------------------------------

/* Listing 12-6b */

#define CharColumns     160             /* desired character dimensions */
#define CharRows        102

#define CharacterWidth  8               /* 8 for EGA color modes */
                                        /* 9 for EGA monochrome or VGA */

int     BytesPerRow = CharColumns * 2;  /* for 80-column alphanumeric */
                                        /*  modes */

main()
{
        int     i;
        int far *POINTS = 0x00400085;   /* (in video display data area) */

        BufferDims( CharColumns * CharacterWidth, CharRows * (*POINTS) );

        for( i = 0; i < CharColumns / 10; i++ ) /* display a long line */
          printf("0123456789");

        Pan( 0, 0, 80 * CharacterWidth, 0 );    /* pan right */
        Pan( 80 * CharacterWidth, 0, 0, 0 );    /* pan left */
        Pan( 0, 0, 0, 50 * (*POINTS) );         /* pan down */
        Pan( 0, 50 * (*POINTS), 0, 0);          /* pan up */
}



---------------------------------------------------------------------------
Listing 12-7a.  Splitting the screen on the EGA.
---------------------------------------------------------------------------

                TITLE   'Listing 12-7a'
                NAME    SplitScreen
                PAGE    55,132

;
; Name:         SplitScreen
;
; Function:     Horizontal split screen on EGA
;
; Caller:       Microsoft C:
;
;                       void SplitScreen(n);
;
;                               int     n;      /* scan line at which */
;                                               /*  to split screen */
;

ARGn            EQU     word ptr [bp+4]


ADDR_6845       EQU     63h

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _SplitScreen
_SplitScreen    PROC    near

                push    bp              ; preserve BP
                mov     bp,sp

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area
                mov     dx,es:[ADDR_6845]  ; DX := CRTC address port

; wait for vertical retrace

                add     dl,6            ; DX := 3BAH or 3DAH (CRT status
                                        ;                      port)
L01:            in      al,dx           ; wait for end of vertical retrace
                test    al,8
                jnz     L01

L02:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,8
                jz      L02
                sub     dl,6            ; DX := CRTC address port

; isolate bits 0-7 and bit 8 of the Line Compare value

                mov     ax,ARGn         ; AX := scan line value
                mov     bh,ah
                and     bh,1            ; BH bit 0 := Line Compare bit 8
                mov     cl,4
                shl     bh,cl           ; BH bit 4 := Line Compare bit 8

; program the CRTC registers

                mov     ah,al           ; AH := low-order 8 bits of value
                mov     al,18h          ; AL := Line Compare register
                                        ;        number
                out     dx,ax           ; update Line Compare register

                mov     ah,1Fh          ; default value for EGA 350-line

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                                        ;  modes (use 11h in EGA 200-line
                                        ;          modes)
                and     ah,11101111b    ; AH bit 4 := 0
                or      ah,bh           ; AH bit 4 := Line Compare bit 8
                mov     al,7            ; AL := Overflow register number
                out     dx,ax           ; update Overflow register

                pop     bp              ; restore BP and exit
                ret

_SplitScreen    ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 12-7b.  Splitting the screen on the VGA.
---------------------------------------------------------------------------

                TITLE   'Listing 12-7b'
                NAME    SplitScreen
                PAGE    55,132

;
; Name:         SplitScreen
;
; Function:     Horizontal split screen on VGA
;
; Caller:       Microsoft C:
;
;                       void SplitScreen(n);
;
;                               int     n;      /* scan line at which */
;                                               /*  to split screen */
;

ARGn            EQU     word ptr [bp+4]


ADDR_6845       EQU     63h

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _SplitScreen

_SplitScreen    PROC    near

                push    bp              ; preserve BP
                mov     bp,sp

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area
                mov     dx,es:[ADDR_6845]  ; DX := CRTC address port

; wait for vertical retrace

                add     dl,6            ; DX := 3BAH or 3DAH (CRT status
                                        ;                      port)
L01:            in      al,dx           ; wait for end of vertical retrace
                test    al,8
                jnz     L01

L02:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,8
                jz      L02
                sub     dl,6            ; DX := CRTC address port

; isolate bits 0-7, bit 8, and bit 9 of the Line Compare value

                mov     ax,ARGn         ; AX := scan line value
                mov     bh,ah           ; BH bits 0-1 := bits 8-9 of
                                        ;  Line Compare value

                mov     bl,bh
                and     bx,0201h        ; BH bit 1 := Line Compare bit 9
                                        ; BL bit 0 := Line Compare bit 0
                mov     cl,4
                shl     bx,cl           ; BH bit 5 := Line Compare bit 9
                                        ; BL bit 4 := Line Compare bit 8
                shl     bh,1            ; BH bit 6 := Line Compare bit 9

; update the CRTC registers

                mov     ah,al           ; AH := low-order 8 bits of value
                mov     al,18h          ; AL := Line Compare register
                                        ;        number
                out     dx,ax           ; update Line Compare register

                mov     al,7            ; AL := Overflow register number
                out     dx,al
                inc     dx
                in      al,dx           ; AL := current Overflow reg value
                dec     dx

                mov     ah,al
                and     ah,11101111b    ; AH bit 4 := 0
                or      ah,bl           ; AH bit 4 := Line Compare bit 8
                mov     al,7            ; AL := Overflow register number
                out     dx,ax           ; update Overflow register

                mov     al,9            ; AL := Max Scan Line register
                                        ;        number
                out     dx,al
                inc     dx
                in      al,dx           ; AL := current Max Scan Line reg
                                        ;        value
                dec     dx

                mov     ah,al
                and     ah,10111111b    ; AH bit 6 := 0
                or      ah,bh           ; AH bit 6 := Line Compare bit 9
                mov     al,9            ; AL := Max Scan Line reg number
                out     dx,ax           ; update Max Scan Line register

                pop     bp              ; restore BP and exit
                ret

_SplitScreen    ENDP

_TEXT           ENDS
                END



---------------------------------------------------------------------------
Listing 12-8.  Smooth vertical scrolling of a split screen on
               the EGA or VGA.
---------------------------------------------------------------------------

#define MaxScanLine     349             /* (depends on video mode) */

for ( i = MaxScanLine; i >= 0; --i )    /* scroll up */
  SplitScreen( i );

for ( i = 0; i < MaxScanLine; i++ )     /* scroll down */
  SplitScreen( i );

SplitScreen( 0x3FF );                   /* restore default value */



---------------------------------------------------------------------------
Listing 12-9a.  Getting the light pen's location from the CRTC.
---------------------------------------------------------------------------

                TITLE   'Listing 12-9a'
                NAME    GetLightPen
                PAGE    55,132

;
; Name:         GetLightPen
;
; Function:     Get light pen position
;
; Caller:       Microsoft C:
;
;                       int GetLightPen();      /* returns buffer offset */
;

ADDR_6845       EQU     63h

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _GetLightPen
_GetLightPen    PROC    near

                push    bp
                mov     bp,sp

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area

                mov     dx,es:[ADDR_6845]  ; DX := 3B4H or 3D4H

                add     dl,7            ; DX := 3BBH or 3DBH
                xor     al,al           ; AL := 0
                out     dx,al           ; reset CRTC light pen latch
                jmp     $+2             ; ensure that CRTC has time to
                                        ;  respond

                dec     dx              ; DX := 3BAH or 3DAH

L01:            in      al,dx           ; wait for light pen to be
                                        ;  triggered
                test    al,2
                jz      L01

                cli                     ; disable interrupts
                sub     dl,6            ; DX := 3B4H or 3D4H
                mov     al,10h          ; AL := Light Pen High register
                                        ;        number
                out     dx,al
                inc     dx
                in      al,dx

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                mov     ah,al           ; AH := Light Pen High value
                dec     dx

                mov     al,11h          ; AL := Light Pen Low register
                                        ;        number
                out     dx,al
                inc     dx
                in      al,dx           ; AX := offset at which light pen
                                        ;        was triggered
                sti                     ; reenable interrupts

                pop     bp
                ret

_GetLightPen    ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 12-9b.  Using GetLightPen in a C program.
---------------------------------------------------------------------------

/* Listing 12-9b */

main()
{
      int     BufferOffset,Row,Column;
      int far *CRT_START = 0x0040004E;
      char far *CRT_COLS = 0x0040004A;

      printf( "\nCRT_COLS = %d", (int) (*CRT_COLS) );

      for( ; ; )
      {
        BufferOffset = GetLightPen();

        printf( "\nLight pen offset:  %4xh", BufferOffset );

        BufferOffset = BufferOffset - 7;         /* empirical correction */

        BufferOffset = BufferOffset - (*CRT_START)/2; /* offset relative */
                                                      /*  to start of */
                                                      /*  screen */

        Row = BufferOffset / (int)(*CRT_COLS);        /* character row */
        Column = BufferOffset % (int)(*CRT_COLS);     /* character /*
                                                      /*  column */

        printf( "  Column = %d  Row = %d", Column, Row );
      }
}



---------------------------------------------------------------------------
Listing 12-10.  Identifying the current video mode on a Hercules adapter.
---------------------------------------------------------------------------

                TITLE   'Listing 12-10'
                NAME    GetHercMode
                PAGE    55,132

; Name:         GetHercMode
;
; Function:     Determine video mode on Hercules adapters by estimating the 
;                size of the displayed portion of the video buffer.
;
; Caller:       Microsoft C:
;
;                       int GetHercMode(n);     /* returns approximate */
;                                               /*  size of displayed  */
;                                               /*  portion of video   */
                                                /*  buffer in words    */

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                PUBLIC  _GetHercMode
_GetHercMode    PROC    near

                push    bp              ; preserve BP
                mov     bp,sp

; reset CRTC light pen latch

                mov     dx,3BBh         ; DX := light pen reset port
                out     dx,al           ; OUT to this port clears the latch
                                        ;  (the value in AL doesn't matter)

; wait for start of next vertical retrace

                dec     dx              ; DX := 3BAH (CRT status port)
L01:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,80h
                jnz     L01

L02:            in      al,dx           ; wait for end of vertical retrace
                test    al,80h
                jz      L02

                cli                     ; disable interrupts
L03:            in      al,dx           ; wait for start of vertical
                                        ;  retrace
                test    al,80h
                jnz     L03

; latch the current CRTC address counter in the Light Pen registers

                dec     dx              ; DX := 3B9H
                out     dx,al           ; OUT to this port loads the latch
                sti                     ; reenable interrupts

; return the value in the Light Pen registers

                mov     dl,0B4h         ; DX := 3B4H (CRTC address port)
                mov     al,10h          ; AL := Light Pen High register
                                        ;        number
                out     dx,al
                inc     dx
                in      al,dx           ; read this register
                dec     dx
                mov     ah,al           ; AH := current Light Pen High
                                        ;        value

                mov     al,11h          ; AL := Light Pen Low register
                                        ;        number
                out     dx,al
                inc     dx
                in      al,dx           ; AX := current light pen latch
                                        ;        value
                                        ;  (i.e., value of CRTC address
                                        ;   counter at start of vertical
                                        ;   retrace)
                pop     bp
                ret

_GetHercMode    ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 13-1a.  The SetPixel subroutine (Microsoft C small-model
                calling conventions).
---------------------------------------------------------------------------

                TITLE   'Listing 13-1a'
                NAME    SetPixel
                PAGE    55,132

;
; Name:         SetPixel
;
; Function:     Set the value of a pixel in native EGA graphics modes.
;
; Caller:       Microsoft C (small memory model):
;
;                       void SetPixel(x,y,n);
;
;                       int x,y;                /* pixel coordinates */
;                       int n;                  /* pixel value */
;
; Notes:        This is the same routine as in Chapter 5.
;

ARGx            EQU     word ptr [bp+4] ; stack frame addressing
ARGy            EQU     word ptr [bp+6]
ARGn            EQU     byte ptr [bp+8]

RMWbits         EQU     0               ; read-modify-write bits


_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr:near

                PUBLIC  _SetPixel
_SetPixel       PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp

                mov     ax,ARGy         ; AX := y
                mov     bx,ARGx         ; BX := x
                call    PixelAddr       ; AH := bit mask
                                        ; ES:BX -> buffer
                                        ; CL := # bits to shift left

; set Graphics Controller Bit Mask register

                shl     ah,cl           ; AH := bit mask in proper position

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                mov     dx,3CEh         ; GC address register port
                mov     al,8            ; AL := Bit Mask register number
                out     dx,ax

; set Graphics Controller Mode register

                mov     ax,0005h        ; AL :=  Mode register number
                                        ; AH :=  Write Mode 0 (bits 0,1)
                                        ;        Read Mode 0 (bit 3)
                out     dx,ax

; set Data Rotate/Function Select register

                mov     ah,RMWbits      ; AH := Read-Modify-Write bits
                mov     al,3            ; AL := Data Rotate/Function Select
                                        ;        reg
                out     dx,ax

; set Set/Reset and Enable Set/Reset registers

                mov     ah,ARGn         ; AH := pixel value
                mov     al,0            ; AL := Set/Reset reg number
                out     dx,ax

                mov     ax,0F01h        ; AH := value for Enable Set/Reset
                                        ;  (all bit planes enabled)
                                        ; AL := Enable Set/Reset reg number
                out     dx,ax

; set the pixel value

                or      es:[bx],al      ; load latches during CPU read
                                        ; update latches and bit planes
                                        ;  during CPU write

; restore default Graphics Controller registers

                mov     ax,0FF08h       ; default Bit Mask
                out     dx,ax

                mov     ax,0005         ; default Mode register
                out     dx,ax

                mov     ax,0003         ; default Function Select
                out     dx,ax

                mov     ax,0001         ; default Enable Set/Reset
                out     dx,ax

                mov     sp,bp           ; restore caller registers and
                                        ;  return
                pop     bp
                ret

_SetPixel       ENDP

_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 13-1b.  Calling SetPixel() from a C program.
---------------------------------------------------------------------------

/* Listing 13-1b */

/* draws an n-leaved rose of the form  rho = a * cos(n * theta) */

#define Leaves          (double)11      /* n must be an odd number */

#define Xmax            640
#define Ymax            350
#define PixelValue      14
#define ScaleFactor     (double) 1.37

main()
{
        int     x,y;                    /* pixel coordinates */
        double  a;                      /* length of the semi-axis */

        double  rho,theta;              /* polar coordinates */
        double  pi = 3.14159265358979;
        double  sin(),cos();

        void SetPixel();


        a = (Ymax/2) - 1;             /* a reasonable choice for a */

        for (theta=0.0; theta < pi; theta+=0.001)
        {
          rho = a * cos( Leaves * theta );      /* apply the formula */

          x = rho * cos( theta );       /* convert to rectangular coords */
          y = rho * sin( theta ) / ScaleFactor;

                                        /* plot the point */
          SetPixel( x + Xmax/2, y + Ymax/2, PixelValue );
        }
}



---------------------------------------------------------------------------
Listing 13-2a.  The SETPEL subroutine (Microsoft FORTRAN calling
                conventions).
---------------------------------------------------------------------------

                TITLE   'Listing 13-2a'
                NAME    SETPEL
                PAGE    55,132

;
; Name:         SETPEL
;
; Function:     Set the value of a pixel in native EGA graphics modes.
;
; Caller:       Microsoft Fortran
;
;                       integer*2       x,y,n
;                       call SETPEL(x,y,n)
;

ADDRx           EQU     dword ptr [bp+14]       ; x, y, and n are
ADDRy           EQU     dword ptr [bp+10]       ;  referenced by 32-bit
                                                ;  addresses
ADDRn           EQU     dword ptr [bp+6]

RMWbits         EQU     0


SETPEL_TEXT     SEGMENT byte public 'CODE'
                ASSUME  cs:SETPEL_TEXT

                EXTRN   PixelAddr:far

                PUBLIC  SETPEL
SETPEL          PROC    far

                push    bp
                mov     bp,sp

; get parameters via 32-bit addresses on stack

                les     bx,ADDRn                ; ES:BX -> n
                push    es:[bx]                 ; preserve n on stack

                les     bx,ADDRy
                mov     ax,es:[bx]              ; AX := y

                les     bx,ADDRx
                mov     bx,es:[bx]              ; BX := x

                call    PixelAddr               ; compute pixel address

                shl     ah,cl

; program the Graphics Controller

                mov     dx,3CEh
                mov     al,8
                out     dx,ax

                mov     ax,0005h
                out     dx,ax

                mov     ah,RMWbits
                mov     al,3
                out     dx,ax

                pop     ax                      ; AX := n
                mov     ah,al                   ; AH := n
                mov     al,0
                out     dx,ax

                mov     ax,0F01h
                out     dx,ax

; update the pixel, restore the default Graphics Controller state, and
;  return

                or      es:[bx],al              ; update the pixel

                mov     ax,0FF08h               ; restore default Graphics
                out     dx,ax                   ;  Controller values

                mov     ax,0005
                out     dx,ax

                mov     ax,0003
                out     dx,ax

                mov     ax,0001
                out     dx,ax

                mov     sp,bp                   ; restore registers and
                                                ;  exit
                pop     bp

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                ret     12                      ; discard caller's parms

SETPEL          ENDP

SETPEL_TEXT     ENDS
                END



---------------------------------------------------------------------------
Listing 13-2b.  Calling SETPEL() from a FORTRAN program.
---------------------------------------------------------------------------

c Listing 13-2b
c
c draws an n-leaved rose of the form  rho = a * cos(n*theta)

        real*8          Leaves /11/
        real*8          ScaleFactor /1.37/

        integer*2       Xmax /640/, Ymax /350/, PixelValue /14/

        integer*2       x,y
        real*8          a
        real*8          rho,theta
        real*8          pi /3.14159265358979/
        real*8          sin,cos

        a = (Ymax/2) - 1

        do 100 theta = 0.0, pi, 0.001

        rho = a * cos( Leaves * theta )

        x = rho * cos( theta )
        y = rho * sin( theta ) / ScaleFactor

100     call SETPEL( x + Xmax/2, y + Ymax/2, PixelValue )

        stop
        end



---------------------------------------------------------------------------
Listing 13-3a.  The SETPEL subroutine (Turbo Pascal calling conventions).
---------------------------------------------------------------------------

                TITLE   'Listing 13-3a'
                NAME    SETPEL
                PAGE    55,132

;
; Name:         SETPEL
;
; Function:     Set the value of a pixel in 320x200 4-color mode
;
; Caller:       Turbo Pascal
;
;               PROCEDURE SETPEL(VAR x,y:INTEGER; PixelValue:INTEGER);
;                EXTERNAL 'setpel.bin';
;
; Notes:        The code segment is named _TEXT so that PixelAddr may be
;               linked in the same segment.
;

ADDRx           EQU     dword ptr [bp+10]       ; x and y are VAR so their
ADDRy           EQU     dword ptr [bp+6]        ;  addresses are passed
ARGn            EQU     byte ptr [bp+4]         ; n's value is passed on
                                                ;  the stack

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr:near

SETPEL          PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    ds

; make this routine addressable through SI

                call    L01             ; push offset of L01

L01:            pop     si              ; CS:SI -> L01
                sub     si,offset L01

; get parameters via 32-bit addresses on stack

                lds     di,ADDRy        ; DS:DI -> y
                mov     ax,[di]         ; AX := y

                lds     di,ADDRx
                mov     bx,[di]         ; BX := x

                call    PixelAddr       ; AH := bit mask
                                        ; ES:BX -> buffer
                                        ; CL := # bits to shift left

                mov     al,ARGn         ; AL := pixel value
                shl     ax,cl           ; AH := bit mask in proper position
                                        ; AL := pixel value in proper
                                        ;        position

; jump through the variable SetPixelOp to the appropriate routine

                mov     di,cs:SetPixelOp[si]    ; DI := address
                add     di,si           ; DI := relocated address
                jmp     di
                                        ; routine to replace pixel value

ReplacePixel:   not     ah              ; AH := inverse bit mask
                and     es:[bx],ah      ; zero the pixel value
                or      es:[bx],al      ; set the pixel value
                jmp     short L02

                                        ; routine to AND pixel value

ANDPixel:       not     ah              ; AH := inverse bit mask
                or      al,ah           ; AL := all 1's except pixel value
                and     es:[bx],al
                jmp     short L02


ORPixel:        or      es:[bx],al      ; routine to OR pixel value
                jmp     short L02


XORPixel:       xor     es:[bx],al      ; routine to XOR pixel value

L02:            pop     ds              ; restore regs and exit
                mov     sp,bp
                pop     bp
                ret     l0              ; discard parameters and return

SETPEL          ENDP


SetPixelOp      DW      ReplacePixel    ; contains addr of pixel operation


_TEXT           ENDS

                END



---------------------------------------------------------------------------
Listing 13-3b.  Calling SETPEL() from a Turbo Pascal program.
---------------------------------------------------------------------------

{ Listing 13-3b }

PROGRAM rose;    { draws an n-leaved rose of the form   
                    rho = a * cos(n*theta) }

CONST
     Leaves             = 11.0;                   { must be an odd number }

     Xmax               = 320;
     Ymax               = 200;
     PixelValue         = 3;
     ScaleFactor        = 1.20;
     Pi                 = 3.14159265358979;

VAR
     x,y:               INTEGER;                      { pixel coordinates }
     a:                 REAL;                   { length of the semi-axis }
     rho,theta:         REAL;                         { polar coordinates }

PROCEDURE SETPEL(VAR x,y:INTEGER;
                  PixelValue:INTEGER); EXTERNAL 'setpel.bin';

BEGIN
     GraphColorMode;                           { set 320x200 4-color mode }
     a := (Ymax/2) - 1;                       { a reasonable choice for a }

     theta := 0.0;
     WHILE theta < Pi DO
     BEGIN
          rho := a * Cos(Leaves * theta);             { apply the formula }

          x := Trunc(rho * Cos(theta));   { convert to rectangular coords }
          y := Trunc(rho * Sin(theta) / ScaleFactor);

          x := x + Trunc(Xmax/2);                      { center on screen }
          y := y + Trunc(Ymax/2);

          SETPEL(x,y,PixelValue);                        { plot the point }

          theta := theta + 0.001;
     END
END.



---------------------------------------------------------------------------
Listing 13-4a.  The SETPEL subroutine (BASICA calling convention).

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
---------------------------------------------------------------------------

                TITLE   'Listing 13-4a'
                NAME    SETPEL
                PAGE    55,132

;
; Name:         SETPEL
;
; Function:     Set the value of a pixel in 320x200 4-color mode
;
; Caller:       IBM BASICA or Microsoft GWBASIC
;
; Notes:        The code segment is named _TEXT so that PixelAddr may be
;               linked in the same segment.
;

ADDRx           EQU     word ptr [bp+10]
ADDRy           EQU     word ptr [bp+8]
ADDRn           EQU     word ptr [bp+6]

CGROUP          GROUP   _TEXT,END_TEXT

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:CGROUP,ds:CGROUP
                EXTRN   PixelAddr:near

; header for BASIC BLOAD

                DB      0FDh
                DW      2 dup(0)
                DW      (offset CGROUP:BLEnd)-7 ; size of subroutine

; start of subroutine
SETPEL          PROC    far
                push    bp              ; preserve caller registers
                mov     bp,sp
                push    es

; make this routine addressable through SI

                call    L01             ; push offset of L01
L01:            pop     si              ; CS:SI -> L01
                sub     si,offset L01

; get parameters via 16-bit addresses on stack
                mov     di,ADDRy        ; DS:DI -> y
                mov     ax,[di]         ; AX := y
                mov     di,ADDRx
                mov     bx,[di]         ; BX := x
                call    PixelAddr       ; AH := bit mask
                                        ; ES:BX -> buffer
                                        ; CL := # bits to shift left

                mov     di,ADDRn
                mov     al,[di]         ; AL := pixel value
                shl     ax,cl           ; AH := bit mask in proper position
                                        ; AL := pixel value in proper
                                        ;        position
; jump through the variable SetPixelOp to the appropriate routine
                mov     di,SetPixelOp[si]       ; DI := address
                add     di,si           ; DI := relocated address
                jmp     di
                                        ; routine to replace pixel value
ReplacePixel:   not     ah              ; AH := inverse bit mask
                and     es:[bx],ah      ; zero the pixel value
                or      es:[bx],al      ; set the pixel value
                jmp     short L02

                                        ; routine to AND pixel value
ANDPixel:       not     ah              ; AH := inverse bit mask
                or      al,ah           ; AL := all 1s except pixel value
                and     es:[bx],al
                jmp     short L02
ORPixel:        or      es:[bx],al      ; routine to OR pixel value
                jmp     short L02

XORPixel:       xor     es:[bx],al      ; routine to XOR pixel value

L02:            pop     es              ; restore registers
                mov     sp,bp
                pop     bp
                ret     6               ; discard parameters and return
SETPEL          ENDP
SetPixelOp      DW      ReplacePixel    ; contains addr of pixel operation
_TEXT           ENDS

END_TEXT        SEGMENT byte public 'CODE'
BLEnd           LABEL   BYTE            ; this segment is linked after 
                                        ;  _TEXT, so this label can be used
                                        ;  to compute the size of the 
                                        ;  _TEXT segment
END_TEXT        ENDS
                END



---------------------------------------------------------------------------
Listing 13-4b.  Calling SETPEL from a BASICA program.
---------------------------------------------------------------------------

100 ' Listing 13-4b
110 ' Draws an n-leaved rose of the form  rho = a * cos(n*theta)
120 DEFINT A-Z
130 LEAVES = 11
140 XMAX = 320 : YMAX = 200
150 PIXELVALUE = 2
160 SCALEFACTOR# = 1.2
170 PI# = 3.14159265358979#
180 X = 0 : Y = 0                       ' pixel coordinates
190 A# = 0                              ' length of the semi-axis
200 RHO# = 0 : THETA# = 0               ' polar coordinates
210 '
220 SETPEL = 0
230 DIM SPAREA(256)                     ' reserve RAM for the subroutine
240 SETPEL = VARPTR(SPAREA(1))          ' address of subroutine
250 BLOAD "setpel.bin",SETPEL           ' load subroutine into RAM
260 '
270 SCREEN 1 : COLOR 0,0 : CLS          ' set 320x200 4-color mode
280 A# = (YMAX / 2) - 1                 ' a reasonable choice for A
290 THETA# = 0
300 WHILE (THETA# < PI#)
310  RHO# = A# * COS(LEAVES * THETA#)   ' apply the formula
320  X = RHO# * COS(THETA#)             ' convert to rectangular coords
330  Y = RHO# * SIN(THETA#) / SCALEFACTOR#
340  X = X + XMAX/2                     ' center on screen
350  Y = Y + YMAX/2
360  CALL SETPEL(X,Y,PIXELVALUE)        ' plot the point
370  THETA# = THETA# + .001
380  WEND
390 END



---------------------------------------------------------------------------
Listing 13-5.  A RAM-resident routine to write pixels in 640-by-350
               graphics mode.
---------------------------------------------------------------------------

                TITLE   'Listing 13-5'
                NAME    SetPixel
                PAGE    55,132
;
; Name:         SetPixel
;
; Function:     Set the value of a pixel in native EGA graphics modes.
;
; Caller:       Memory-resident routine invoked via interrupt 60H:
;
;                       mov ax,PixelX      ; pixel x-coordinate
;                       mov bx,PixelY      ; pixel y-coordinate
;                       mov cx,PixelValue  ; pixel value

; Notes:        - Assemble and link to create SETPIXEL.EXE.
;               - Execute once to make SetPixel resident in memory and to
;                  point the INT 60H vector to the RAM-resident code.
;               - Requires MS-DOS version 2.0 or later.
;

RMWbits         EQU     0

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT

                EXTRN   PixelAddr:near

                PUBLIC  SetPixel
SetPixel        PROC    near            ; RAM-resident interrupt 60H
                                        ;  handler

                sti                     ; enable interrupts
                push    ax              ; preserve caller registers on
                push    bx              ;  caller's stack
                push    cx
                push    dx

                push    cx              ; preserve pixel value on stack

                call    PixelAddr       ; compute pixel address
                shl     ah,cl

                mov     dx,3CEh         ; program the Graphics Controller
                mov     al,8            ; AL := Bit Mask register number
                out     dx,ax
                mov     ax,0005h
                out     dx,ax

                mov     ah,RMWbits      ; AH := Read-Modify-Write bits
                mov     al,3            ; AL := Data Rotate/Function Select
                                        ;        reg
                out     dx,ax
                pop     ax
                mov     ah,al           ; AH := pixel value
                mov     al,0
                out     dx,ax

                mov     ax,0F01h
                out     dx,ax

                or      es:[bx],al      ; set the pixel value

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

                mov     ax,0FF08h       ; restore default Graphics
                out     dx,ax           ;  Controller values

                mov     ax,0005
                out     dx,ax

                mov     ax,0003
                out     dx,ax

                mov     ax,0001
                out     dx,ax

                pop     dx              ; restore caller registers and
                                        ;  return
                pop     cx
                pop     bx
                pop     ax
                iret

SetPixel        ENDP

_TEXT           ENDS


TRANSIENT_TEXT  SEGMENT para
                ASSUME  cs:TRANSIENT_TEXT,ss:STACK

Install         PROC    near

                mov     ax,2560h        ; AH := 25H (INT 21H function
                                        ;            number)
                                        ; AL := 60H (interrupt number)
                mov     dx,seg _TEXT
                mov     ds,dx
                mov     dx,offset _TEXT:SetPixel   ; DS:DX -> interrupt
                                                   ;  handler

                int     21h             ; point INT 60H vector to
                                        ;  SetPixel routine

                mov     dx,cs           ; DX := segment of start of
                                        ;  transient (discardable)
                                        ;  portion of program
                mov     ax,es           ; ES := Program Segment Prefix
                sub     dx,ax           ; DX := size of RAM-resident
                                        ;  portion
                mov     ax,3100h        ; AH := 31H (INT 21H function
                                        ;  number)
                                        ; AL := 0 (return code)
                int     21h             ; Terminate but Stay Resident

Install         ENDP

TRANSIENT_TEXT  ENDS

STACK           SEGMENT para stack 'STACK'

                DB      80h dup(?)      ; stack space for transient portion
                                        ;  of program
STACK           ENDS

                END     Install



---------------------------------------------------------------------------
Listing 13-6.  Using C to draw a filled rectangle.
---------------------------------------------------------------------------

/* Listing 13-6 */

FilledRectangle( x1, y1, x2, y2, n )
int     x1,y1;                  /* upper left corner */
int     x2,y2;                  /* lower right corner */
int     n;                      /* pixel value */
{
        int     y;

        for (y = y1; y <= y2; y++)      /* draw rectangle as a set of */
          Line( x1, y, x2, y, n );      /*  adjacent horizontal lines */
}



---------------------------------------------------------------------------
Listing 13-7.  Using DGIS to draw a filled rectangle.
---------------------------------------------------------------------------

                TITLE   'Listing 13-7'
                NAME    dgisrect
;
; Name:         dgisrect
; Function:     draw a filled rectangle using DGIS
;
; Notes:        assemble and link to create DGISRECT.EXE
;
CR              EQU     0Dh
LF              EQU     0Ah

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:_DATA,ss:STACK
EntryPoint      PROC    far
                mov     ax,seg _DATA
                mov     ds,ax                   ; DS -> _DATA
                push    ss
                pop     es                      ; ES -> stack segment

; look for installed DGIS devices
                xor     dx,dx                   ; DX = 0 (buffer length)
                xor     cx,cx                   ; CX = 0
                xor     bx,bx                   ; BX = 0
                mov     ax,6A00h                ; AX = DGIS opcode (Inquire
                                                ;       Available Devices)
                int     10h
                or      cx,cx
                jnz     L01                     ; jump if device(s)
                                                ;  installed
                mov     dx,offset _DATA:Msg0
                jmp     ErrorExit

; find a graphics output device in the list of installed DGIS devices
L01:            inc     cx                      ; CX = (# of bytes in list)
                                                ;  + 1
                and     cx,0FFFEh               ; CX = even number of bytes
                mov     bp,sp
                sub     sp,cx                   ; establish stack frame
                                                ;  (SS:BP -> end of frame)
                mov     di,sp                   ; ES:DI -> start of stack
                                                ;  frame
                push    di                      ; save for later
                mov     dx,cx                   ; DX = size of buffer
                xor     cx,cx
                xor     bx,bx
                mov     ax,6A00h                ; AX = DGIS opcode (Inquire
                                                ;       Available Devices)
                int     10h                     ; get device list at ES:DI
                pop     di                      ; ES:DI -> device list

L02:            cmp     word ptr es:[di+2],0    ; is this a graphics
                                                ;  device?
                je      L04                     ; jump if so
                sub     bx,es:[di]              ; BX = bytes remaining in
                                                ;  list
                jnz     L03                     ; jump if more devices in
                                                ;  list
                mov     dx,offset _DATA:Msg1
                jmp     ErrorExit

L03:            add     di,es:[di]              ; ES:DI -> next device in
                                                ;  list
                jmp     L02

; establish a logical connection to the graphics device
;  using the first available configuration on the device
L04:            les     di,es:[di+6]            ; ES:DI -> device entry
                                                ;  point
                mov     word ptr GrDevEntry,di
                mov     word ptr GrDevEntry+2,es  ; save entry point
                mov     cx,0                    ; CX = first configuration
                                                ;  index
                mov     ax,0027h                ; AX = DGIS opcode
                                                ;  (Connect)
                call    dword ptr GrDevEntry    ; connect to graphics
                                                ;  device
                cmp     bx,-1                   ; test returned handle
                jne     L05                     ; jump if connected
                mov     dx,offset _DATA:Msg2
                jmp     ErrorExit

L05:            mov     ChannelHandle,bx        ; save the handle for later
                mov     ax,001Bh                ; AX = DGIS opcode
                                                ;  (Init DGI)
                call    dword ptr GrDevEntry    ; initialize the device
                                                ;  with default attributes
; draw a filled rectangle using default attributes
                mov     di,100                  ; DI = lower right corner y
                mov     si,100                  ; SI = lower right corner x
                mov     dx,0                    ; DX = upper left corner y
                mov     cx,0                    ; CX = upper left corner x
                mov     bx,ChannelHandle        ; BX = handle
                mov     ax,003Fh                ; AX = DGIS opcode (Output
                call    dword ptr GrDevEntry    ;       Filled Rectangle)

; disconnect and exit
                mov     bx,ChannelHandle        ; BX = handle
                mov     ax,002Bh                ; AX = DGIS opcode
                                                ;  (Disconnect)
                call    dword ptr GrDevEntry

Lexit:          mov     ax,4C00h
                int     21h                     ; return to DOS

ErrorExit:      mov     ah,9
                int     21h                     ; display error message
                mov     ax,4C01h
                int     21h                     ; return to DOS

EntryPoint      ENDP


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
_TEXT           ENDS
_DATA           SEGMENT para public 'DATA'

GrDevEntry      DD      ?                       ; graphics device entry 
                                                ;  point
ChannelHandle   DW      ?                       ; handle to connected 
                                                ;  device configuration

Msg0            DB      CR,LF,'No DGIS devices installed',CR,LF,'$'
Msg1            DB      CR,LF,'No graphics devices installed',CR,LF,'$'
Msg2            DB      CR,LF,'Can't connect to graphics device',CR,LF,'$'
_DATA           ENDS

STACK           SEGMENT stack 'STACK'
                DB      400h dup(?)
STACK           ENDS
                END     EntryPoint



---------------------------------------------------------------------------
Listing 13-8.  Using Microsoft Windows GDI (version 1.03) to draw
               a filled rectangle.
---------------------------------------------------------------------------

    HDC          hDC;                 /* device context handle */
    HPEN         hpen;
    HBRUSH       hbrush;
    PAINTSTRUCT  ps;
    .
    .
    .

    /* initialize device context for window */

    hDC = BeginPaint( hWnd, &ps );
    .
    .
    .

    /* associate attributes with device context */

    hpen = CreatePen( PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT) );
    SelectObject( hDC, (HANDLE)hpen );

    hbr = CreateSolidBrush( GetNearestColor(hDC,RectFillColor) );
    SelectObject( hDC, (HANDLE)hbr );
    .
    .
    .

    /* draw a filled rectangle */

    Rectangle( hDC, 0, 0, 100, 100 );
    .
    .
    .
    EndPaint( hWnd, &ps );



---------------------------------------------------------------------------
Listing A-1.  Using a Parameter Save Area to keep track of EGA or VGA
              palette registers.
---------------------------------------------------------------------------

                TITLE   'Listing A-1'
                NAME    EstablishPSA
                PAGE    55,132

;
; Name:         EstablishPSA
;
; Function:     Establish a Parameter Save Area for the EGA or VGA video
;                BIOS. This save area will reflect the current values of 
;                the Attribute Controller's Palette and Overscan registers.
;
; Caller:       Microsoft C:
;
;                       void EstablishPSA();
;

SAVE_PTR        EQU     0A8h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP,es:DGROUP

                PUBLIC  _EstablishPSA
_EstablishPSA   PROC    near

                push    bp
                mov     bp,sp
                push    si
                push    di

; preserve previous SAVE_PTR

                push    ds
                pop     es              ; ES -> DGROUP
                mov     di,offset DGROUP:Old_SAVE_PTR

                mov     ax,40h
                mov     ds,ax           ; DS -> video BIOS data area
                mov     si,SAVE_PTR     ; DS:SI -> SAVE_PTR

                mov     cx,4
                rep     movsb

; copy SAVE POINTER table to RAM

                lds     si,es:Old_SAVE_PTR ; DS:SI -> SAVE POINTER table
                mov     di,offset DGROUP:SP_TABLE1
                mov     cx,7*4          ; number of bytes to move
                rep     movsb

; update SAVE_PTR with the address of the new SAVE POINTER table

                mov     ds,ax           ; DS -> video BIOS data area
                mov     si,SAVE_PTR
                mov     word ptr [si],offset DGROUP:SP_TABLE1
                mov     [si+2],es

; update SAVE POINTER table with address of Parameter Save Area

                push    es
                pop     ds      ; DS -> DGROUP

                mov     word ptr SP_TABLE1[4],offset DGROUP:PSA
                mov     word ptr SP_TABLE1[6],ds

; restore registers and exit

                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_EstablishPSA   ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

Old_SAVE_PTR    DD      ?               ; previous value of SAVE_PTR
SP_TABLE1       DD      7 dup(?)        ; RAM copy of SAVE POINTER table
PSA             DB      256 dup(0)      ; Parameter Save Area

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing A-2.  Using a User Palette Profile to override the default VGA
              palette.
---------------------------------------------------------------------------

                TITLE   'Listing A-2'
                NAME    EstablishUPP
                PAGE    55,132

;
; Name:         EstablishUPP
;
; Function:     Establish a User Palette Profile Save Area for the VGA 
;                video BIOS. This save area overrides the usual default 
;                palette values for a specified list of video modes.
;
; Caller:       Microsoft C:
;
;                       void EstablishUPP();

SAVE_PTR        EQU     0A8h

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP,es:DGROUP

                PUBLIC  _EstablishUPP
_EstablishUPP   PROC    near

                push    bp
                mov     bp,sp
                push    si
                push    di

; preserve previous SAVE_PTR

                push    ds
                pop     es              ; ES -> DGROUP
                mov     di,offset DGROUP:Old_SAVE_PTR

                mov     ax,40h
                mov     ds,ax           ; DS -> video BIOS data area

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                mov     si,SAVE_PTR     ; DS:SI -> SAVE_PTR

                mov     cx,4
                rep     movsb

; copy SAVE POINTER table to RAM

                lds     si,es:Old_SAVE_PTR ; DS:SI -> SAVE POINTER table
                mov     di,offset DGROUP:SP_TABLE1
                mov     cx,7*4          ; number of bytes to move
                rep     movsb

; update SAVE_PTR with the address of the new SAVE POINTER table

                mov     ds,ax           ; DS -> video BIOS data area
                mov     si,SAVE_PTR
                mov     word ptr [si],offset DGROUP:SP_TABLE1
                mov     [si+2],es

; copy SECONDARY SAVE POINTER table to RAM

                lds     si,es:SP_TABLE1[16] ; DS:SI -> SEC SAVE POINTER
                                            ;           table
                mov     di,offset DGROUP:SP_TABLE2
                mov     cx,[si]
                rep     movsb

; update new SAVE POINTER table with address of new SECONDARY SAVE POINTER
;  table

                push    es
                pop     ds      ; DS -> DGROUP

                mov     word ptr SP_TABLE1[16],offset DGROUP:SP_TABLE2
                mov     word ptr SP_TABLE1[18],ds

; update SECONDARY SAVE POINTER with address of User Palette Profile

                mov     word ptr SP_TABLE2[10],offset DGROUP:UPP
                mov     word ptr SP_TABLE2[12],ds

; restore registers and exit

                pop     di
                pop     si
                mov     sp,bp
                pop     bp
                ret

_EstablishUPP   ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

Old_SAVE_PTR    DD      ?               ; previous value of SAVE_PTR

SP_TABLE1       DD      7 dup(?)        ; copy of SAVE POINTER table

SP_TABLE2       DW      ?               ; copy of SECONDARY SAVE POINTER
                                        ;  table
                DD      6 dup(?)

UPP             DB      0               ; underlining flag
                DB      0               ; (reserved)
                DW      0               ; (reserved)
                DW      17              ; # of palette & overscan registers
                DW      0               ; first register specified in table
                DW      DGROUP:PalTable ; pointer to palette table
                DW      seg DGROUP
                DW      0               ; number of video DAC color regs
                DW      0               ; first video DAC register
                DD      0               ; pointer to video DAC color table
                DB      3,0FFh          ; list of applicable video modes

PalTable        DB      30h,31h,32h,33h,34h,35h,36h,37h ; a custom palette
                DB      00h,01h,02h,03h,04h,05h,14h,07h
                DB      01h                             ; overscan reg

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing B-1.  A simple screen dump routine for the CGA.
---------------------------------------------------------------------------

                TITLE   'Listing B-1'
                NAME    ScreenDumpCGA
                PAGE    55,132

;
; Name:         ScreenDumpCGA
;
; Function:     Screen Dump for CGA 640x200 2-color and 320x200 4-color
;                modes
;
; Caller:       (undefined)
;
; Notes:        The main procedure of this program, ScreenDumpCGA, may be
;               called from an application program or as part of a TSR
;               (Terminate-but-Stay-Resident) handler for interrupt 5.
;

STDPRN          =       4               ; MS-DOS standard printer handle


DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

;
; PrintLine
;
;       Writes one line of characters to the standard printer device.
;       Ignores errors.
;

PrintLine       PROC    near            ; Caller:       DS:DX -> data
                                        ;               CX = # of bytes

                mov     bx,STDPRN
                mov     ah,40h          ; INT 21h function 40h:  write
                int     21h
                ret

PrintLine       ENDP

;
; PrinterGraphics
;
;       Puts the printer in its "graphics mode."  This routine must be
;       customized for different printers.
;

PrinterGraphics PROC    near            ; Configures Epson MX-80 printer
                                        ;  for 480 dots/line

                mov     dx,offset DGROUP:EpsonGraphics
                mov     cx,3
                call    PrintLine
                ret

PrinterGraphics ENDP

;
; PrinterDefault
;
;       Puts the printer in its default (non-graphics) mode.  Again, this
;       routine must be customized for different printers.
;

PrinterDefault  PROC    near            ; Configures Epson MX-80 for
                                        ;  default alphanumeric output

                mov     dx,offset DGROUP:EpsonReset
                mov     cx,2
                call    PrintLine
                ret

PrinterDefault  ENDP

;
; ChopZeros
;
;       Chops trailing zeros from the printer output buffer.
;

ChopZeros       PROC    near            ; Caller:       ES:DI -> buffer
                                        ;               CX = buffer length
                                        ; Returns:      CX = adjusted
                                        ;                     length

                jcxz    L01             ; exit if buffer is empty

                add     di,cx
                dec     di              ; ES:DI -> last byte in buffer

                xor     al,al           ; AL := 0 (byte to scan for)

                std                     ; scan backwards
                repe    scasb
                cld                     ; restore direction flag
                je      L01             ; jump if buffer filled with zeros

                inc     cx              ; adjust length past last nonzero
                                        ;  byte

L01:            ret

ChopZeros       ENDP

;
; PrintPixels
;
;       Prints one row of pixels on an Epson MX-80.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;

PrintPixels     PROC    near            ; Caller:       DI = offset of
                                        ;                     buffer
                                        ;               CX = buffer length

                push    ds
                pop     es              ; ES := DS

                push    di              ; preserve buffer offset
                call    ChopZeros
                push    cx              ; preserve length

                mov     word ptr DataHeader+2,cx  ; store buffer length
                                                  ;  in output data header
                mov     dx,offset DGROUP:DataHeader
                mov     cx,4
                call    PrintLine       ; print data header

                pop     cx              ; CX := buffer length
                pop     dx              ; DX := buffer offset
                call    PrintLine       ; print the pixels

                mov     dx,offset DGROUP:CRLF
                mov     cx,2
                call    PrintLine

                ret

PrintPixels     ENDP

;
; TranslatePixels
;
;       Copies one printable row of pixels from the video buffer to the
;       print buffer.  This routine can be modified at will to change the
;       scaling or orientation of the printed image, to interpolate gray-
;       scale values for color pixels, etc.
;
;       This routine formats the printer buffer for output to an Epson
;       MX-80. The page is printed sideways, with two horizontal printed
;       pixels for each vertical pixel in the video buffer. Since the CGA
;       screen is 200 pixels high, the printed output is 400 pixels wide.
;

TranslatePixels PROC    near            ; Caller:       SI = video buffer
                                        ;                     offset
                                        ;               ES:DI -> print
                                        ;                     buffer

                push    ds              ; preserve DS
                mov     ds,VideoBufSeg  ; DS:SI -> video buffer

                add     di,398          ; ES:DI -> 2 bytes before end of
                                        ;           buffer

                mov     cx,200          ; CX := # of vertical pixels
                mov     bx,2000h+1      ; BX := 1st video buffer increment
                mov     dx,81-2000h     ; DX := 2nd video buffer increment

                std                     ; fill the print buffer backwards

L11:            lodsb                   ; AL := 8 pixels from video buffer
                mov     ah,al           ; AX := 8 doubled pixels
                stosw                   ; write them to print buffer

                add     si,bx           ; increment to next interleave of
                xchg    bx,dx           ;  video buffer

                loop    L11

                cld                     ; clear direction flag
                pop     ds              ; restore DS
                ret

TranslatePixels ENDP

;
; ScreenDumpCGA
;

ScreenDumpCGA   PROC    near            ; Caller:       DS = DGROUP

                call    PrinterGraphics ; configure the printer for
                                        ;  graphics

                push    ds
                pop     es              ; DS,ES := DGROUP
                xor     si,si           ; SI := offset of start of video
                                        ;        buffer

L21:            push    si
                mov     di,offset DGROUP:PrintBuf
                call    TranslatePixels ; copy one printable row of pixels

                mov     cx,400
                mov     di,offset DGROUP:PrintBuf
                call    PrintPixels     ; print them

                pop     si
                inc     si
                cmp     si,80           ; loop across all 80 columns in
                jb      L21             ;  the video buffer

                call    PrinterDefault  ; restore the printer to its
                                        ;  default state
                ret

ScreenDumpCGA   ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

PrintBuf        DB      400 dup(?)      ; print output buffer

VideoBufSeg     DW      0B800h

EpsonGraphics   DB      1Bh,33h,18h
EpsonReset      DB      1Bh,40h
DataHeader      DB      1Bh,4Bh,00h,00h
CRLF            DB      0Dh,0Ah

_DATA           ENDS
                END



---------------------------------------------------------------------------
Listing B-2.  An EGA screen printing routine.
---------------------------------------------------------------------------

                TITLE   'Listing B-2'
                NAME    ScreenDumpEGA
                PAGE    55,132

; Name:         ScreenDumpEGA
;
; Function:     Screen Dump for EGA 640x350 16-color mode
;
; Caller:       (undefined)
;
; Notes:        The main procedure of this program, ScreenDumpEGA, may be
;               called from an application program or as part of a TSR
;               (Terminate-but-Stay-Resident) handler for interrupt 5.

STDPRN          =       4               ; MS-DOS standard printer handle

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

; PrintLine
;
;       Writes one line of characters to the standard printer device.
;       Ignores errors.
;

PrintLine       PROC    near            ; Caller:       DS:DX -> data
                                        ;               CX = # of bytes
                mov     bx,STDPRN
                mov     ah,40h          ; INT 21h function 40h:  Write
                int     21h
                ret

PrintLine       ENDP

; PrinterGraphics
;
;       Puts the printer in its "graphics mode."  This routine must be
;       customized for different printers.
;

PrinterGraphics PROC    near            ; Configures Epson MX-80 printer
                                        ;  for 480 dots/line

                mov     dx,offset DGROUP:EpsonGraphics
                mov     cx,3
                call    PrintLine
                ret
PrinterGraphics ENDP

;
; PrinterDefault
;
;       Puts the printer in its default (non-graphics) mode.  Again, this
;       routine must be customized for different printers.
;

PrinterDefault  PROC    near            ; Configures Epson MX-80 for
                                        ;  default alphanumeric output

                mov     dx,offset DGROUP:EpsonReset
                mov     cx,2
                call    PrintLine
                ret

PrinterDefault  ENDP


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;
; ChopZeros
;
;       Chops trailing zeros from the printer output buffer.
;

ChopZeros       PROC    near            ; Caller:       ES:DI -> buffer
                                        ;               CX = buffer length
                                        ; Returns:      CX = adjusted
                                        ;                     length

                jcxz    L01             ; exit if buffer is empty

                add     di,cx
                dec     di              ; ES:DI -> last byte in buffer

                xor     al,al           ; AL := 0 (byte to scan for)

                std                     ; scan backwards
                repe    scasb
                cld                     ; restore direction flag
                je      L01             ; jump if buffer filled with zeros

                inc     cx              ; adjust length past last nonzero
                                        ;  byte

L01:            ret

ChopZeros       ENDP

;
; PrintPixels
;
;       Prints one row of pixels on an Epson MX-80.
;

PrintPixels     PROC    near            ; Caller:       DI = offset of
                                        ;                     buffer
                                        ;               CX = buffer length

                push    ds
                pop     es              ; ES := DS
                push    di              ; preserve buffer offset
                call    ChopZeros
                push    cx              ; preserve length

                mov     word ptr DataHeader+2,cx  ; store buffer length
                                                  ;  in output data header
                mov     dx,offset DGROUP:DataHeader
                mov     cx,4
                call    PrintLine       ; print data header

                pop     cx              ; CX := buffer length
                pop     dx              ; DX := buffer offset
                call    PrintLine       ; print the pixels

                mov     dx,offset DGROUP:CRLF
                mov     cx,2
                call    PrintLine

                ret

PrintPixels     ENDP

;
; TranslatePixels
;
;       Copies one printable row of pixels from the video buffer to the
;       print buffer.  This routine can be modified at will to change the
;       scaling or orientation of the printed image, to interpolate gray-
;       scale values for color pixels, etc.
;
;       This routine formats the printer buffer for output to an Epson
;       MX-80.  The page is printed sideways, so the printed output is
;       350 pixels wide.
;

TranslatePixels PROC    near            ; Caller:       SI = video buffer
                                        ;                     offset
                                        ;               ES:DI -> print
                                        ;                     buffer

                push    ds              ; preserve DS
                mov     ds,VideoBufSeg  ; DS:SI -> video buffer

                add     di,349          ; ES:DI -> last byte in print
                                        ;           buffer

                mov     cx,350          ; CX := # of vertical pixels

; set up the Graphics Controller for read mode 1

                mov     dx,3CEh         ; Graphics Controller I/O port
                mov     ax,805h         ; AH := 00001000b (read mode 1)
                                        ; AL := Mode register number
                out     dx,ax

                mov     ax,002          ; AH := 0 (color compare value)
                out     dx,ax           ; AL := Color Compare register
                                        ;        number

                mov     ax,0F07h        ; AH := 00001111b (color don't care
                                        ;        mask)
                out     dx,ax           ; AL := Color Don't Care register
                                        ;        number

; fill the print buffer; all nonzero pixels in the video buffer are
;  printed

                std                     ; fill the print buffer backwards
L11:            lodsb                   ; AL := 8-pixel color compare value
                                        ;  (bits = 0 if pixel <> 0)
                not     al              ; AL := 8 printable pixels
                stosb                   ; store in print buffer

                add     si,81           ; increment to next row in video
                                        ;  buffer
                loop    L11

                cld                     ; clear direction flag

; restore Graphics Controller default state

                mov     ax,5            ; AH := read mode 0, write mode 0
                out     dx,ax           ; AL := Mode register number

                mov     ax,7            ; AH := 0 (color don't care mask)
                out     dx,ax           ; AL := Color Don't Care register
                                        ;        number

                pop     ds              ; restore DS
                ret

TranslatePixels ENDP

;
; ScreenDumpEGA
;

ScreenDumpEGA   PROC    near            ; Caller:       DS = DGROUP

                call    PrinterGraphics ; configure the printer for
                                        ;  graphics

                push    ds
                pop     es              ; DS,ES := DGROUP

                xor     si,si           ; SI := offset of start of video
                                        ;        buffer

L21:            push    si
                mov     di,offset DGROUP:PrintBuf
                call    TranslatePixels ; copy one printable row of pixels

                mov     cx,350
                mov     di,offset DGROUP:PrintBuf
                call    PrintPixels     ; print them

                pop     si
                inc     si
                cmp     si,80           ; loop across all 80 columns in
                jb      L21             ;  the video buffer

                call    PrinterDefault  ; restore the printer to its
                                        ;  default state
                ret

ScreenDumpEGA   ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

PrintBuf        DB      350 dup(?)      ; print output buffer

VideoBufSeg     DW      0A000h

EpsonGraphics   DB      1Bh,33h,18h
EpsonReset      DB      1Bh,40h
DataHeader      DB      1Bh,4Bh,00h,00h
CRLF            DB      0Dh,0Ah

_DATA           ENDS
                END



---------------------------------------------------------------------------
Listing B-3.  Using RAM-based character definition tables to print
              the character set.
---------------------------------------------------------------------------

                TITLE   'Listing B-3'
                NAME    ScreenDumpAlpha
                PAGE    55,132

;
; Name:         ScreenDumpAlpha
;
; Function:     Screen Dump for EGA alphanumeric modes with 350-line

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;                resolution
;
; Caller:       (undefined)
;
; Notes:        The main procedure of this program, ScreenDumpAlpha, may be
;               called from an application program or as part of a TSR
;               (Terminate-but-Stay-Resident) handler for interrupt 5.
;

STDPRN          =       4               ; MS-DOS standard printer handle

DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP,es:DGROUP

;
; PrintLine
;
;       Writes one line of characters to the standard printer device.
;       Ignores errors.
;

PrintLine       PROC    near            ; Caller:       DS:DX -> data
                                        ;               CX = # of bytes
                mov     bx,STDPRN
                mov     ah,40h          ; INT 21h function 40h:  Write
                int     21h
                ret

PrintLine       ENDP

;
; PrinterGraphics
;
;       Puts the printer in its "graphics mode."  This routine must be
;       customized for different printers.
;

PrinterGraphics PROC    near            ; Configures Epson MX-80 printer
                                        ;  for 480 dots/line

                mov     dx,offset DGROUP:EpsonGraphics
                mov     cx,3
                call    PrintLine
                ret

PrinterGraphics ENDP

;
; PrinterDefault
;
;       Puts the printer in its default (non-graphics) mode.  Again, this
;       routine must be customized for different printers.
;

PrinterDefault  PROC    near            ; Configures Epson MX-80 for
                                        ;  default alphanumeric output

                mov     dx,offset DGROUP:EpsonReset
                mov     cx,2
                call    PrintLine
                ret

PrinterDefault  ENDP

;
; ChopZeros
;
;       Chops trailing zeros from the printer output buffer.

ChopZeros       PROC    near            ; Caller:       ES:DI -> buffer
                                        ;               CX = buffer length
                                        ; Returns:      CX = adjusted
                                        ;                     length
                jcxz    L01             ; exit if buffer is empty

                add     di,cx
                dec     di              ; ES:DI -> last byte in buffer

                xor     al,al           ; AL := 0 (byte to scan for)

                std                     ; scan backwards
                repe    scasb
                cld                     ; restore direction flag
                je      L01             ; jump if buffer filled with zeros

                inc     cx              ; adjust length past last nonzero
                                        ;  byte

L01:            ret

ChopZeros       ENDP

;
; PrintPixels
;
;       Prints one row of pixels on an Epson MX-80.
;

PrintPixels     PROC    near            ; Caller:       DI = offset of
                                        ;                     buffer
                                        ;               CX = buffer length

                push    ds
                pop     es              ; ES := DS

                push    di              ; preserve buffer offset
                call    ChopZeros
                push    cx              ; preserve length

                mov     word ptr DataHeader+2,cx  ; store buffer length
                                                  ;  in output data header
                mov     dx,offset DGROUP:DataHeader
                mov     cx,4
                call    PrintLine       ; print data header

                pop     cx              ; CX := buffer length
                pop     dx              ; DX := buffer offset
                call    PrintLine       ; print the pixels

                mov     dx,offset DGROUP:CRLF
                mov     cx,2
                call    PrintLine

                ret

PrintPixels     ENDP

;
; TranslatePixels
;
;       Copies one printable row of pixels from the first character
;       definition table in map 2 to the print buffer.
;
;       This routine formats the printer buffer for output to an Epson
;       MX-80.  The page is printed sideways, so the printed output is
;       350 pixels wide.
;

TranslatePixels PROC    near            ; Caller:       SI = video buffer
                                        ;                     offset
                                        ;               ES:DI -> print
                                        ;                      buffer

                push    ds              ; preserve DS
                mov     ds,VideoBufSeg  ; DS:SI -> video buffer

                add     di,es:PrintBufSize
                dec     di              ; ES:DI -> last byte in print
                                        ;           buffer

                mov     dx,3CEh         ; Graphics Controller I/O port

; fill the print buffer

                mov     cx,es:Rows      ; CX := number of character rows

L11:            push    cx              ; preserve CX and SI
                push    si

                mov     ax,0004h        ; AH := value for Read Map Select
                                        ;        reg
                                        ; AL := Read Map Select reg number
                out     dx,ax           ; select map 0 (character codes)

                lodsb                   ; AX := next char code in video
                                        ;        buffer
                mov     cl,5
                shl     ax,cl           ; AX := AX * 32
                mov     si,ax           ; SI := offset of character
                                        ;  definition in map 2
                mov     ax,0204h
                out     dx,ax           ; select map 2 (bit patterns)

                mov     cx,es:Points    ; CX := size of character
                                        ;        definition

L12:            cld
                lodsb                   ; AL := 8-bit pattern from
                                        ;  character definition table
                                        ; SI := SI + 1
                std
                stosb                   ; store bit pattern in print buffer
                                        ; DI := DI - 1
                loop    L12             ; loop down character definition

                pop     si              ; restore SI and CX
                pop     cx

                add     si,es:Columns   ; DS:SI -> next row of characters
                loop    L11             ; loop down character rows

                cld                     ; clear direction flag
                pop     ds              ; restore DS
                ret

TranslatePixels ENDP

;

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
; ScreenDumpAlpha
;

ScreenDumpAlpha PROC    near            ; Caller:       DS = DGROUP

                call    PrinterGraphics ; configure the printer for
                                        ;  graphics

                call    CGenModeSet     ; address EGA memory maps in
                                        ;  parallel:
                                        ;  map 0 contains character codes
                                        ;  map 2 contains character
                                        ;  definitions

; copy screen dimensions from Video Display Data Area

                mov     ax,40h
                mov     es,ax           ; ES -> video BIOS data area
                mov     al,es:[84h]     ; AX := ROWS
                inc     ax
                mov     Rows,ax
                mov     ax,es:[4Ah]     ; AX := CRT_COLS
                add     ax,ax           ; * 2 for proper buffer addressing
                mov     Columns,ax
                mov     ax,es:[85h]     ; AX := POINTS
                mov     Points,ax
                mul     Rows            ; AX := ROWS * POINTS
                mov     PrintBufSize,ax

; print the screen

                push    ds
                pop     es              ; DS,ES := DGROUP
                xor     si,si           ; SI := offset of start of video
                                        ;        buffer

L21:            push    si
                mov     di,offset DGROUP:PrintBuf
                call    TranslatePixels ; copy one printable row of pixels

                mov     cx,PrintBufSize
                mov     di,offset DGROUP:PrintBuf
                call    PrintPixels     ; print them
                pop     si
                add     si,2            ; increment to next character
                                        ;  column
                cmp     si,Columns      ; loop across all character columns
                jb      L21

                call    CGenModeClear   ; restore previous alphanumeric
                                        ;  mode
                call    PrinterDefault  ; restore the printer to its
                                        ;  default state
                ret
ScreenDumpAlpha ENDP

;
; CGenModeSet (from Chapter 10)
;

CGenModeSet     PROC    near

                push    si              ; preserve these registers
                push    cx

                cli                     ; disable interrupts
                mov     dx,3C4h         ; Sequencer port address
                mov     si,offset DGROUP:SetSeqParms
                mov     cx,4

L31:            lodsw                   ; AH := value for Sequencer
                                        ;        register
                                        ; AL := register number
                out     dx,ax           ; program the register
                loop    L31
                sti                     ; enable interrupts

                mov     dl,0CEh         ; DX := 3CEH (Graphics Controller
                                        ;        port address)
                mov     si,offset DGROUP:SetGCParms
                mov     cx,3

L32:            lodsw                   ; program the Graphics Controller
                out     dx,ax
                loop    L32

                pop     cx              ; restore registers and return
                pop     si
                ret

CGenModeSet     ENDP

;
; CGenModeClear (from Chapter 10)
;

CGenModeClear   PROC    near

                push    si              ; preserve these registers
                push    cx

                cli                     ; disable interrupts
                mov     dx,3C4h         ; Sequencer port address
                mov     si,offset DGROUP:ClearSeqParms
                mov     cx,4

L41:            lodsw                   ; AH := value for Sequencer
                                        ;        register
                                        ; AL := register number
                out     dx,ax           ; program the register
                loop    L41
                sti                     ; enable interrupts

                mov     dl,0CEh         ; DX := 3CEH (Graphics Controller
                                        ;               port address)

                mov     si,offset DGROUP:ClearGCParms
                mov     cx,3

L42:            lodsw                   ; program the Graphics Controller
                out     dx,ax
                loop    L42

                mov     ah,0Fh          ; AH := INT 10H function number
                int     10h             ; get video mode

                cmp     al,7
                jne     L43             ; jump if not monochrome mode

                mov     ax,0806h        ; program Graphics Controller
                out     dx,ax           ;  to start map at B000:0000

L43:            pop     cx              ; restore registers and return
                pop     si
                ret

CGenModeClear   ENDP

_TEXT           ENDS

_DATA           SEGMENT word public 'DATA'

PrintBuf        DB      400 dup(?)      ; print output buffer

VideoBufSeg     DW      0A000h

EpsonGraphics   DB      1Bh,33h,18h
EpsonReset      DB      1Bh,40h
DataHeader      DB      1Bh,4Bh,00h,00h
CRLF            DB      0Dh,0Ah
Columns         DW      ?               ; number of displayed character
                                        ;  columns
Rows            DW      ?               ; number of displayed character
                                        ;  rows
Points          DW      ?               ; vertical size of character matrix
PrintBufSize    DW      ?               ; Rows * Points

SetSeqParms     DW      0100h           ; parameters for CGenModeSet
                DW      0402h
                DW      0704h
                DW      0300h

SetGCParms      DW      0204h
                DW      0005h
                DW      0006h

ClearSeqParms   DW      0100h           ; parameters for CGenModeClear
                DW      0302h
                DW      0304h
                DW      0300h

ClearGCParms    DW      0004h
                DW      1005h
                DW      0E06h

_DATA           ENDS
                END



---------------------------------------------------------------------------
Listing C-1.  A routine to identify PC and PS/2 video subsystems.
---------------------------------------------------------------------------

                TITLE   'Listing C-1 - VideoID'
                NAME    VideoID
                PAGE    55,132

;
; Name:         VideoID
;
; Function:     Detects the presence of various video subsystems and
;                associated monitors.
;
; Caller:       Microsoft C:
;
;                       void VideoID(VIDstruct);
;
;                       struct
;                       {

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;                         char VideoSubsystem;
;                         char Display;
;                       }
;                               *VIDstruct[2];
;
;               Subsystem ID values:
;                                0  = (none)
;                                1  = MDA
;                                2  = CGA
;                                3  = EGA
;                                4  = MCGA
;                                5  = VGA
;                               80h = HGC
;                               81h = HGC+
;                               82h = Hercules InColor
;
;               Display types:   0  = (none)
;                                1  = MDA-compatible monochrome
;                                2  = CGA-compatible color
;                                3  = EGA-compatible color
;                                4  = PS/2-compatible monochrome
;                                5  = PS/2-compatible color
;
;
;       The values returned in VIDstruct[0].VideoSubsystem and
;       VIDstruct[0].Display indicate the currently active subsystem.
;

ARGpVID         EQU     word ptr [bp+4] ; stack frame addressing


VIDstruct       STRUC                   ; corresponds to C data structure

Video0Type      DB      ?               ; first subsystem type
Display0Type    DB      ?               ; display attached to first
                                        ;  subsystem
Video1Type      DB      ?               ; second subsystem type
Display1Type    DB      ?               ; display attached to second
                                        ;  subsystem

VIDstruct       ENDS


Device0         EQU     word ptr Video0Type[di]
Device1         EQU     word ptr Video1Type[di]


MDA             EQU     1               ; subsystem types
CGA             EQU     2
EGA             EQU     3
MCGA            EQU     4
VGA             EQU     5
HGC             EQU     80h
HGCPlus         EQU     81h
InColor         EQU     82h

MDADisplay      EQU     1               ; display types
CGADisplay      EQU     2
EGAColorDisplay EQU     3
PS2MonoDisplay  EQU     4
PS2ColorDisplay EQU     5

TRUE            EQU     1
FALSE           EQU     0


DGROUP          GROUP   _DATA

_TEXT           SEGMENT byte public 'CODE'
                ASSUME  cs:_TEXT,ds:DGROUP

                PUBLIC  _VideoID
_VideoID        PROC    near

                push    bp              ; preserve caller registers
                mov     bp,sp
                push    si
                push    di

; initialize the data structure that will contain the results

                mov     di,ARGpVID      ; DS:DI -> start of data structure

                mov     Device0,0       ; zero these variables
                mov     Device1,0

; look for the various subsystems using the subroutines whose addresses are
;  tabulated in TestSequence; each subroutine sets flags in TestSequence
;  to indicate whether subsequent subroutines need to be called

                mov     byte ptr CGAflag,TRUE
                mov     byte ptr EGAflag,TRUE
                mov     byte ptr Monoflag,TRUE

                mov     cx,NumberOfTests
                mov     si,offset DGROUP:TestSequence

L01:            lodsb                   ; AL := flag
                test    al,al
                lodsw                   ; AX := subroutine address
                jz      L02             ; skip subroutine if flag is false

                push    si
                push    cx
                call    ax              ; call subroutine to detect
                                        ;  subsystem
                pop     cx
                pop     si

L02:            loop    L01

; determine which subsystem is active

                call    FindActive
                pop     di              ; restore caller registers and
                                        ;  return
                pop     si
                mov     sp,bp
                pop     bp
                ret

_VideoID        ENDP

;
; FindPS2
;
;       This subroutine uses INT 10H function 1Ah to determine the video
;        BIOS Display Combination Code (DCC) for each video subsystem
;        present.
;

FindPS2         PROC    near

                mov     ax,1A00h
                int     10h             ; call video BIOS for info

                cmp     al,1Ah
                jne     L13             ; exit if function not supported
                                        ;  (i.e., no MCGA or VGA in system)

; convert BIOS DCCs into specific subsystems & displays

                mov     cx,bx
                xor     bh,bh           ; BX := DCC for active subsystem
                or      ch,ch
                jz      L11             ; jump if only one subsystem
                                        ;  present

                mov     bl,ch           ; BX := inactive DCC
                add     bx,bx
                mov     ax,[bx+offset DGROUP:DCCtable]

                mov     Device1,ax

                mov     bl,cl
                xor     bh,bh           ; BX := active DCC

L11:            add     bx,bx
                mov     ax,[bx+offset DGROUP:DCCtable]

                mov     Device0,ax

; reset flags for subsystems that have been ruled out

                mov     byte ptr CGAflag,FALSE
                mov     byte ptr EGAflag,FALSE
                mov     byte ptr Monoflag,FALSE

                lea     bx,Video0Type[di]  ; if the BIOS reported an
                                           ;  MDA...
                cmp     byte ptr [bx],MDA
                je      L12

                lea     bx,Video1Type[di]
                cmp     byte ptr [bx],MDA
                jne     L13

L12:            mov     word ptr [bx],0    ; ... Hercules can't be ruled
                                           ;      out
                mov     byte ptr Monoflag,TRUE

L13:            ret

FindPS2         ENDP


;
; FindEGA
;
; Look for an EGA.  This is done by making a call to an EGA BIOS function
;  which doesn't exist in the default (MDA, CGA) BIOS.

FindEGA         PROC    near            ; Caller:       AH = flags
                                        ; Returns:      AH = flags
                                        ;               Video0Type and
                                        ;                Display0Type
                                                         updated

                mov     bl,10h          ; BL := 10h (return EGA info)
                mov     ah,12h          ; AH := INT 10H function number

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
                int     10h             ; call EGA BIOS for info
                                        ; if EGA BIOS is present,
                                        ;  BL <> 10H
                                        ;  CL = switch setting
                cmp     bl,10h
                je      L22             ; jump if EGA BIOS not present

                mov     al,cl
                shr     al,1            ; AL := switches/2
                mov     bx,offset DGROUP:EGADisplays
                xlat                    ; determine display type from
                                        ;  switches
                mov     ah,al           ; AH := display type
                mov     al,EGA          ; AL := subystem type
                call    FoundDevice

                cmp     ah,MDADisplay
                je      L21             ; jump if EGA has a monochrome
                                        ;  display

                mov     CGAflag,FALSE   ; no CGA if EGA has color display
                jmp     short L22

L21:            mov     Monoflag,FALSE  ; EGA has a mono display, so MDA
                                        ;  and Hercules are ruled out
L22:            ret

FindEGA         ENDP


;
; FindCGA
;
;       This is done by looking for the CGA's 6845 CRTC at I/O port 3D4H.
;

FindCGA         PROC    near            ; Returns:      VIDstruct updated

                mov     dx,3D4h         ; DX := CRTC address port
                call    Find6845
                jc      L31             ; jump if not present

                mov     al,CGA
                mov     ah,CGADisplay
                call    FoundDevice

L31:            ret

FindCGA         ENDP


;
; FindMono
;
;       This is done by looking for the MDA's 6845 CRTC at I/O port 3B4H.
;       If a 6845 is found, the subroutine distinguishes between an MDA
;       and a Hercules adapter by monitoring bit 7 of the CRT Status byte.
;       This bit changes on Hercules adapters but does not change on an
;       MDA. The various Hercules adapters are identified by bits 4 through
;       6 of the CRT Status value:
;
;               000b = HGC
;               001b = HGC+
;               101b = InColor card

FindMono        PROC    near            ; Returns:      VIDstruct updated

                mov     dx,3B4h         ; DX := CRTC address port
                call    Find6845
                jc      L44             ; jump if not present

                mov     dl,0BAh         ; DX := 3BAh (status port)
                in      al,dx
                and     al,80h
                mov     ah,al           ; AH := bit 7 (vertical sync on
                                        ;        HGC)

                mov     cx,8000h        ; do this 32768 times 
L41:            in      al,dx
                and     al,80h          ; isolate bit 7
                cmp     ah,al
                loope   L41             ; wait for bit 7 to change

                jne     L42             ; if bit 7 changed, it's a Hercules

                mov     al,MDA          ; if bit 7 didn't change, it's an
                                        ;  MDA
                mov     ah,MDADisplay
                call    FoundDevice
                jmp     short L44

L42:            in      al,dx
                mov     dl,al           ; DL := value from status port

                mov     ah,MDADisplay   ; assume it's a monochrome display

                mov     al,HGC          ; look for an HGC
                and     dl,01110000b    ; mask off bits 4 thru 6
                jz      L43

                mov     al,HGCPlus      ; look for an HGC+
                cmp     dl,00010000b
                je      L43             ; jump if it's an HGC+

                mov     al,InColor      ; it's an InColor card
                mov     ah,EGAColorDisplay

L43:            call    FoundDevice

L44:            ret

FindMono        ENDP


;
; Find6845
;
;       This routine detects the presence of the CRTC on an MDA, CGA, or
;       HGC. The technique is to write and read register 0Fh of the chip
;       (Cursor Location Low). If the same value is read as written,
;       assume the chip is present at the specified port address.
;

Find6845        PROC    near            ; Caller:       DX = port addr
                                        ; Returns:      cf set if not
                                        ;                present
                mov     al,0Fh
                out     dx,al           ; select 6845 reg 0Fh (Cursor Low)
                inc     dx

                in      al,dx           ; AL := current Cursor Low value
                mov     ah,al           ; preserve in AH
                mov     al,66h          ; AL := arbitrary value
                out     dx,al           ; try to write to 6845

                mov     cx,100h

L51:            loop    L51             ; wait for 6845 to respond

                in      al,dx
                xchg    ah,al           ; AH := returned value
                                        ; AL := original value
                out     dx,al           ; restore original value

                cmp     ah,66h          ; test whether 6845 responded
                je      L52             ; jump if it did (cf is reset)

                stc                     ; set carry flag if no 6845 present

L52:            ret

Find6845        ENDP


;
; FindActive
;
;       This subroutine stores the currently active device as Device0.  The
;       current video mode determines which subsystem is active.
;

FindActive      PROC    near

                cmp     word ptr Device1,0
                je      L63                     ; exit if only one
                                                ;  subsystem

                cmp     Video0Type[di],4        ; exit if MCGA or VGA
                                                ;  present
                jge     L63                     ;  (INT 10H function 1AH
                cmp     Video1Type[di],4        ;  already did the work)
                jge     L63

                mov     ah,0Fh
                int     10h                     ; AL := current BIOS video
                                                ;        mode

                and     al,7
                cmp     al,7                    ; jump if monochrome
                je      L61                     ;  (mode 7 or 0Fh)

                cmp     Display0Type[di],MDADisplay
                jne     L63                     ; exit if Display0 is color
                jmp     short L62

L61:            cmp     Display0Type[di],MDADisplay
                je      L63                     ; exit if Display0 is
                                                ;  monochrome

L62:            mov     ax,Device0              ; make Device0 currently
                                                ;  active
                xchg    ax,Device1
                mov     Device0,ax

L63:            ret

FindActive      ENDP

;
; FoundDevice

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
;
;       This routine updates the list of subsystems.
;

FoundDevice     PROC    near                    ; Caller:  AH = display #
                                                ;          AL = subsystem #
                                                ; Destroys: BX
                lea     bx,Video0Type[di]
                cmp     byte ptr [bx],0
                je      L71                     ; jump if 1st subsystem

                lea     bx,Video1Type[di]       ; must be 2nd subsystem

L71:            mov     [bx],ax                 ; update list entry
                ret

FoundDevice     ENDP

_TEXT           ENDS


_DATA           SEGMENT word public 'DATA'

EGADisplays     DB      CGADisplay      ; 0000b, 0001b  (EGA switch values)
                DB      EGAColorDisplay ; 0010b, 0011b
                DB      MDADisplay      ; 0100b, 0101b
                DB      CGADisplay      ; 0110b, 0111b
                DB      EGAColorDisplay ; 1000b, 1001b
                DB      MDADisplay      ; 1010b, 1011b

DCCtable        DB      0,0             ; translate table for INT 10h func
                                        ;  1Ah
                DB      MDA,MDADisplay
                DB      CGA,CGADisplay
                DB      0,0
                DB      EGA,EGAColorDisplay
                DB      EGA,MDADisplay
                DB      0,0
                DB      VGA,PS2MonoDisplay
                DB      VGA,PS2ColorDisplay
                DB      0,0
                DB      MCGA,EGAColorDisplay
                DB      MCGA,PS2MonoDisplay
                DB      MCGA,PS2ColorDisplay

TestSequence    DB      ?               ; this list of flags and addresses
                DW      FindPS2         ;  determines the order in which
                                        ;  this program looks for the
EGAflag         DB      ?               ;  various subsystems
                DW      FindEGA

CGAflag         DB      ?   
                DW      FindCGA

Monoflag        DB      ?   
                DW      FindMono

NumberOfTests   EQU     ($-TestSequence)/3

_DATA           ENDS

                END



---------------------------------------------------------------------------
Listing C-2.  Calling VideoID from a C program.
---------------------------------------------------------------------------

/* Listing C-2 */

main()
{
        char    *SubsystemName();
        char    *DisplayName();

        static struct
        {
          char  Subsystem;
          char  Display;
        }
        VIDstruct[2];


        /* detect video subsystems */

        VideoID( VIDstruct );


        /* show results */

        printf( "Video subsystems in this computer:" );

        printf( "\n  %s (%s)", SubsystemName(VIDstruct[0].Subsystem),
          DisplayName(VIDstruct[0].Display) );

        if ( VIDstruct[1].Subsystem )
          printf( "\n  %s (%s)", SubsystemName(VIDstruct[1].Subsystem),
            DisplayName(VIDstruct[1].Display) );
}


char *SubsystemName( a )
char    a;
{
        static char *IBMname[] =
        {
          "(none)",
          "MDA",
          "CGA",
          "EGA",
          "MCGA",
          "VGA"
        };

        static char *Hercname[] =
        {
          "HGC",
          "HGC+",
          "InColor"
        };

        if ( a & 0x80 )
          return ( Hercname[a & 0x7F] );
        else
          return( IBMname[a] );
}


char *DisplayName( d )
char    d;
{
        static char *name[] =
        {
          "(none)",
          "MDA-compatible monochrome display",
          "CGA-compatible color display",
          "EGA-compatible color display",
          "PS/2-compatible monochrome display",
          "PS/2-compatible color display"
        };

        return( name[d] );
}




Index


References to source code listings and illustrative figures are in italics.


A
----------------------------------------------------------------------
Adapter. See Video adapter
Algorithm. See Circle; Ellipse; Line; Region fill
All Points Addressable (APA) modes
Alphanumeric mode. See Video modes, alphanumeric
Alternate select. See Interrupt 10H, function 12H
Analog video signals. See also Video DAC
Animation
Application Program Interface (API)
Aspect ratio
Assembly language
Attribute Controller (EGA and VGA)
   programming
   registers
Attributes
   alphanumeric mode
      CGA
      EGA
      HGC
      HGC+
      InColor Card
      MCGA
      MDA
      VGA
   graphics mode
      CGA
      EGA
      HGC
      InColor Card
      MCGA
      VGA


B
----------------------------------------------------------------------
BASIC
BIOS (Basic Input/Output System). See also Interrupt 10H
   about
   anomalies
   data area
      about
      Alphanumeric Character Set Override
      Display Combination Code table
      Graphics Character Set Override
      Parameter Save Area

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
      SAVE POINTER table
      SECONDARY SAVE POINTER table
      User Palette Profile table
      Video Parameter table
   hardware supported by
   planar
   programming interface
   status
   video modes
      determining
      establishing
Bit block. See also CGA; EGA; HGC; MCGA; VGA
   about
   animation
   tiling
Bit planes
   about
   layering
   programming
      EGA
      InColor Card
      VGA
   write-protecting
      EGA
      InColor Card
Blanking
   horizontal
   vertical
Blinking. See also Interrupt 10H, function 10H
   alphanumeric mode
      CGA
      EGA
      InColor
      MDA
   graphics mode
Border (region fill). See Region fill
Border (video display). See Overscan
Bresenham, J.E.


C
----------------------------------------------------------------------
C language
Cathode ray tube. See CRT Controller
CGA (Color Graphics Adapter)
   about
   alphanumeric mode
      attributes
      character generator
      data representation
      snow
   BIOS
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      text
   graphics mode
      attributes
      character generator
      data representation
Character definition tables
   alphanumeric mode
      address map
      BIOS
      dedicated ROM
      format
   graphics mode
      BIOS
      format
Character generator. See also Character definition tables
   alphanumeric mode
   graphics mode
Character string. See Text
Circle. See also Ellipse
   algorithm
   clipping
Code page
Cohen, D.
Color Select register (VGA)
Compaq
Composite video
Configuration Switch (Hercules)
CRT Controller (CRTC)
   about
   programming
   registers
      CGA
      EGA
      Hercules
      MCGA
      MDA
      VGA
   status (see CRT Status register)
   timing
      computations
      horizontal
      vertical
   write-protecting
CRT Status register
Cursor
   alphanumeric
      emulation by BIOS
      invisible
      location
      size
   graphics


D
----------------------------------------------------------------------
DAC. See Video DAC
Decoder gate array (InColor Card)
DGIS (Direct Graphics Interface Standard)
Digital video signals
Display
   active
   interference (see Snow)
   refresh
   switching
      BIOS support for
      configurations (see  Dual-display configurations)
   video
Display Combination Code
Display Enable
DOS. See MS-DOS
Dot clock
Dual-display configurations


E
----------------------------------------------------------------------
EGA (Enhanced Graphics Adapter)
   about
   alphanumeric mode
      attributes
      character generator
EGA, alphanumeric mode 
       data representation
   BIOS
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      region fill
      text
   graphics mode
      attributes
      character generator
      data representation
Ellipse
   algorithm
      derivation
      optimization
      scan-conversion
   clipping
   implementation
Enable Blink bit
Encoder gate array (InColor Card)
EQUIP_FLAG
Exception register (InColor Card)


F
----------------------------------------------------------------------
Fill. See Region fill; Video buffer, fill
Font pages (MCGA)
FORTRAN


G
----------------------------------------------------------------------
GDI (Graphics Device Interface)
GKS (Graphical Kernel  System)
Global data area
GRAFTABL
GRAPHICS
Graphics Controller (EGA  and VGA)
   about
   programming
   read/write modes
      read mode 0
      read mode 1
      write mode 0
Graphics Controller, read/write 
      write mode 1
      write mode 2
      write mode 3
   registers
Graphics Memory Expansion Card (EGA)
Graphics mode. See Video mode, graphics
Graphics window (alphanumeric mode)
Gray-scale
   palette
   summing
GWBASIC. See BASIC

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


H
----------------------------------------------------------------------
Hercules Color Card
Hercules InColor Card. See InColor Card
HGC (Hercules Graphics Card)
   about
   alphanumeric mode
      attributes
      character generator
      data representation
      determining
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      text
   graphics mode
      attributes
      character generator
      data representation
      determining
      establishing
HGC+ (Hercules Graphics  Card Plus)
   about
   alphanumeric mode
      attributes
      character generator
      data representation
      determining
      establishing
   graphics I/O (see also HGC)
      pixel
   graphics mode (see HGC)
Horizontal sync. See Retrace, horizontal


I
----------------------------------------------------------------------
IBM PS/2. See PS/2
InColor Card
   about
   alphanumeric mode
      attributes
      character generator
      data representation
      determining
      establishing
   compared with EGA
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      text
   graphics mode
      attributes
      character generator
      data representation
      determining
      establishing
Inline code
Intel 8259A
Intel 82786
Intensity. See also Attributes
Interface. See Layered interface; Subroutines
Interrupt. See Print screen
Interrupt 0AH. See Vertical interrupt
Interrupt 10H
   about
   functions
      00H (Select Video Mode)
      01H (Set Alphanumeric Cursor Size)
      02H (Set Cursor Location)
      03H (Return Cursor Status)
      04H (Return Light Pen Position)
      05H (Select Video Page)
      06H (Scroll Up)
      07H (Scroll Down)
      08H (Return Character Code and Attribute at Cursor)
      09H (Write Character and Attribute at Cursor)
Interrupt 10H, functions 
      0AH (Write Character(s) at Cursor Position)
      0BH (Set Overscan Color, Select 4-Color Palette)
      0CH (Store Pixel Value)
      0DH (Return Pixel  Value)
      0EH (Display Character in Teletype Mode)
      0FH (Return Current Video Status)
      10H (Set Palette Registers, Set Intensity/Blink Attribute)
      11H (Character Generator Interface)
      12H (Video Subsystem Configuration)
      13H (Display Character String)
      1AH (Video Display Combination)
      1BH (Video BIOS Functionality/State Information)
      1CH (Save or Restore Video State)
Interrupt 1DH
Interrupt 1FH
Interrupt 43H
I/O Support Gate Array  (MCGA)


K
----------------------------------------------------------------------
Kappel, M.R.


L
----------------------------------------------------------------------
Language. See Assembly language; BASIC; C language; FORTRAN; Pascal
Latch
   graphics mode
      EGA and VGA
      InColor Card
   vertical interrupt
Latch Protect register (InColor Card)
Layered interface
   about
   BIOS
   DGIS
   GDI
   GKS
   VDI
Light pen
   about
   programming
Line
   algorithm
      derivation
      optimization
      scan-conversion
   clipping
   implementation
      CGA
      EGA
      HGC
      InColor Card
      MCGA
      VGA
Line-adjacency graph (LAG)
Linking


M
----------------------------------------------------------------------
Macintosh
MCGA (Multi-Color  Graphics Array)
   about
   alphanumeric mode
      attributes
      character generator
      data representation
   BIOS
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      text
   graphics mode
      attributes
      character generator
      data representation
MDA (Monochrome Display Adapter)
   about
   attributes
   BIOS
   character generator
   data representation
Memory Controller Gate Array (MCGA)
Memory-resident program
Microsoft Windows
Miscellaneous Output register (EGA)
Mode Control register
   CGA
   Hercules
   MCGA
   MDA
Monitor. See Display, video
Motorola 6845
MS-DOS


N
----------------------------------------------------------------------
Novak, M.


O
----------------------------------------------------------------------
Optimization
   alphanumeric mode
   graphics mode
      ellipse
      line
      region fill

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
      text
   techniques
Overscan
   color
   EGA
   horizontal
   vertical


P
----------------------------------------------------------------------
Palette. See also Attributes
   colors
   programming
      BIOS
      CGA
      EGA and VGA
      InColor Card
      MCGA
Panning (EGA and VGA)
Pascal
Pavlidis, T.
Personal System/2. See PS/2
Pixel
   attributes
      CGA
      EGA
      HGC
      InColor Card
      MCGA
      VGA
   connectivity
   coordinates
      computation of
      scaling
   logical operations
      about
      AND
      NOT
      OR
      XOR
   representation
      in video buffer
      on screen
   value (see also individual names of adapters)
      reading
      setting
Plane Mask register (InColor Card)
Print screen
   alphanumeric mode
   BIOS
   graphics mode
Programmable interrupt controller (PIC)
Programming language. See Assembly language; BASIC; C language; FORTRAN;
   Pascal
PS/2
   Display Adapter. See VGA; VGA Adapter
   Model 25. See also MCGA
   Model 30. See also MCGA
   Models and 80. See also VGA


R
----------------------------------------------------------------------
Raster
Read mode. See Pixel, value, reading
Read/Write Color register (InColor Card)
Read/Write Control register (InColor Card)
Refresh. See Display, refresh
Regeneration buffer. See Video buffer
Region fill
   about
   algorithms
      border trace
      line adjacency
      recursive
      using horizontal lines
   optimization
   scan-conversion
Retrace
   horizontal
   vertical
Reverse video. See also Attributes
RGB (Red, Green, Blue)
ROM BIOS. See BIOS
Rubberbanding


S
----------------------------------------------------------------------
Save area
   BIOS (see BIOS, data area)
   display switch
   video state
SAVE POINTER table. See BIOS, data area
Scaling factors
Scan-conversion
   about
   ellipse
   line
   region
Screen dump. See Print screen
Scrolling
SECONDARY SAVE POINTER table. See BIOS, data area
Sequencer (EGA and VGA)
   programming
   registers
Shani, U.
Shift-PrtSc
Snapshot. See Print screen
Snow
Split screen (EGA and VGA)
Sproull, R.F.
Status
   BIOS (see BIOS, status)
   CRT Controller
   register (see CRT Status register)
   video subsystem
Subroutines
   linking
   memory models
   parameter passing
   structure
      BASIC
      C
      FORTRAN
      Pascal
Sutherland, I.E.


T
----------------------------------------------------------------------
Text. See also Attributes
   alphanumeric mode
   graphics mode (see names of individual adapters)
Tiling. See Bit block, tiling
TMS34010


U
----------------------------------------------------------------------
Underline attribute.
   See also Attributes, alphanumeric mode


V
----------------------------------------------------------------------
Van Aken, J.R.
Van Dam, A.
VDI (Virtual Device Interface)
Vertical interrupt
   EGA
   MCGA
   VGA
Vertical sync. See Retrace, vertical
VGA (Video Graphics Array)
   about
   alphanumeric mode
      attributes
      character generator
      data representation
   BIOS
   graphics I/O
      bit block
      circle
      ellipse
      line
      pixel
      text
   graphics mode
      attributes
      character generator
      data representation
VGA Adapter. See  also VGA
Video adapter. See also names of individual adapters
Video bandwidth. See Dot clock
Video BIOS. See BIOS
Video buffer
   about
   address map
   CPU access
   data representation
      alphanumeric mode
      graphics mode
   fill
      about
      CGA
      EGA
      HGC
      InColor Card
      MCGA
      VGA
   paging
   panning
   resizing
   scrolling
   split screen
Video Control Data Area. See Video Display Data Area
Video DAC (Digital-to-Analog Converter)
   about

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
   programming
Video display
   about
   resolution
Video Display Data Area (VDDA)
   about
   format
   variables
      ACTIVE_PAGE
      ADDR_6845
      CRT_COLS
      CRT_LEN
      CRT_MODE
      CRT_MODE_SET
      CRT_PALETTE
      CRT_START
      CURSOR_MODE
      CURSOR_POSN
      INFO
      INFO_3
      POINTS
      ROWS
      SAVE_PTR
Video Formatter (MCGA)
Video modes
   about
   alphanumeric
      about
      attributes
      data representation
   BIOS interface
   determining
      BIOS
      Hercules
   establishing
   graphics
      about
      attributes
      data representation
   hardware control
Video monitor. See Video display
Video page. See Video buffer, paging


W
----------------------------------------------------------------------
Window
   alphanumeric mode
   Microsoft Windows
Write mode. See Pixel, value, setting


X
----------------------------------------------------------------------
xMode register


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
