
PROGRAMMER'S GUIDE TO PC(R) AND PS/2(TM) VIDEO SYSTEMS



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



               PROGRAMMER'S GUIDE TO PC(R) AND PS/2(TM) 

                            VIDEO SYSTEMS 


    Maximum Video Performance from the EGA(TM), VGA, HGC, and MCGA 




                            RICHARD WILTON 



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



PUBLISHED BY
Microsoft Press
A Division of Microsoft Corporation
16011 NE 36th Way, Box 97017, Redmond, Washington 98073-9717

Copyright(C) 1987 by Richard Wilton
All rights reserved. No part of the contents of this book may
be reproduced or transmitted in any form or by any means without
the written permission of the publisher.

Library of Congress Cataloging in Publication Data
Wilton, Richard, 1953-
The programmer's guide to PC and PS/2 video systems.
Includes index.
1. IBM Personal Computer--Programming.  2. Expansion boards
   (Microcomputers).
3. Computer graphics.  I. Title.
QA76.8.I2594W55    1987    005.265    87-20264
ISBN 1-55615-103-9

Printed and bound in the United States of America.

1 2 3 4 5 6 7 8 9  FGFG  8 9 0 9 8 7

Distributed to the book trade in the
United States by Harper & Row.

Distributed to the book trade in
Canada by General Publishing Company, Ltd.

Distributed to the book trade outside the
United States and Canada by Penguin Books Ltd.

Penguin Books Ltd., Harmondsworth, Middlesex, England
Penguin Books Australia Ltd., Ringwood, Victoria, Australia
Penguin Books N.Z. Ltd., 182-190 Wairau Road, Auckland 10, New Zealand

British Cataloging in Publication Data available


Acquisitions Editor: Claudette Moore
Technical Editor: Jeff Hinsch


IBM(R) is a registered trademark and PC/AT(TM), PC-DOS(TM), PC/XT(TM), and
PS/2(TM) are trademarks of International Business Machines Corporation.
Microsoft(R) and MS-DOS(R) are registered trademarks of Microsoft
Corporation.



     Contents



     Acknowledgments

     Introduction

      1     IBM Video Hardware and Firmware

      2     Programming the Hardware

      3     Alphanumeric Modes

      4     Graphics Modes

      5     Pixel Programming

      6     Lines

      7     Circles and Ellipses

      8     Region Fill

      9     Graphics Text

     10     Alphanumeric Character Sets

     11     Bit Blocks and Animation

     12     Some Advanced Video Programming Techniques

     13     Graphics Subroutines in High-Level Languages

     Appendix A: Video BIOS Summary

     Appendix B: Printing the Screen

     Appendix C: Identifying Video Subsystems

     Glossary

     Index



Acknowledgments



     The material in Chapters 6, 7, and 8 owes a great deal to the orig-
     inal efforts of several respected workers in the field of computer
     graphics. In each of these chapters I have included references to some
     of their best-known publications. If you are intrigued by the
     algorithms described in these chapters, by all means obtain the
     original publications and explore them yourself.

     This book could not have been written without the encouragement of my
     family, friends, and colleagues, who deserve great thanks for their
     patience and support. My gratitude also to Andy Fischer and to Charles
     Petzold, both of whom graciously reviewed portions of this book and
     offered accurate criticism and suggestions.

     And, of course, my special thanks to the enthusiastic people at
     Microsoft Press--Claudette Moore, Jeff Hinsch, and many others--who
     painstakingly transformed the raw material of this book into the
     finished product.



Introduction



     I clearly remember the day I first plugged a new IBM Enhanced Graphics
     Adapter (EGA) into an IBM PC. It was good to have IBM's new "enhanced"
     video hardware, with its better resolution and control over colors, as
     well as features not found in any of IBM's earlier PC video hardware.
     Now I was ready to write some really sharp graphics applications.

     Or so I thought. The problem was, I couldn't figure out how to program
     the contraption. I had no technical documentation at all. (It arrived
     in the mail six months and $125 later.) I tried disassembling the
     EGA's ROM BIOS, but studying 6000 uncommented machine instructions
     soon raised more questions than it answered. I desperately tried the
     shotgun approach--changing the contents of memory locations and
     machine registers just to see what would happen--but this was like
     chopping out random pieces of an automobile just to see what would
     stop working.

     What I lacked was the details--conceptual descriptions of the hardware
     design, tables describing the programming interface, and, above all,
     source code examples for some typical programming techniques. A few
     well-chosen source code examples would have saved many hours of
     experimentation and frustration when I was trying to understand how to
     program that video adapter.

     This book was inspired by the painful memory of that experience. It is
     filled with source code examples. Its text describes the source code,
     and vice versa. This book also has many tables and summary
     descriptions of the hardware programming interface. In short, this
     book is what I wish I'd had when I started to program PC video
     hardware.


What This Book Is About

     The first chapter of this book is a general overview of the video
     display environment. It describes the commonly used PC and PS/2 video
     hardware the rest of the book deals with. It also introduces you (if
     you aren't already on speaking terms) to the well-known ROM BIOS video
     support routines.

     The next 10 chapters contain the nuts and bolts of IBM video
     programming. The earlier chapters cover the fundamentals, including
     hardware architecture, video display modes, and the nature of the
     interface between your programs and the hardware. The later chapters
     build upon the fundamentals to demonstrate a number of techniques for
     producing text and graphics output.

     The last two chapters of this book take you to the low and high levels
     of video graphics programming. Chapter 12 is the hardware tinkerer's
     chapter--if you want to work with vertical interrupts or play with bit

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     planes, this one's for you. Finally, Chapter 13 tells how to link
     your video hardware drivers to high-level programs and introduces you
     to several commercial video output packages.


What You Need to Use This Book

     This book is not really meant for beginners. That's not to say that a
     programmer who is just learning how to write working code will not
     benefit from this material. On the contrary, the many working examples
     of useful source code should be valuable to anyone who plans to do
     serious programming for PCs or PS/2s. Nevertheless, the broader your
     programming background, the more tools you will have for solving the
     diverse and exacting problems involved in video programming.

Languages

     I use assembly language and C for most of the programming examples in 
     this book, although I intentionally avoid some of C's more cryptic
     syntactic constructs. If you are comfortable with assembly language
     and with a high-level language such as C, Pascal, FORTRAN, PL/1, or
     structured BASIC, you should have no problem reading the source code
     examples.

     Moreover, Chapter 13 discusses interfaces for several high-level
     languages using different memory models and subroutine-calling
     protocols. You can follow the guidelines there to convert any of the
     C-callable source code examples to the subroutine-calling protocol
     used by your favorite language translator.

     You might want to use some other programming tools if you plan to
     experiment with the source code examples that follow. For example, a
     good assembly-language debugger can be extremely helpful. You will
     probably need an object linker if you plan to call the assembly-
     language routines in this book from high-level-language programs.
     Also, as source files and object modules proliferate, you might find a
     UNIX-like make utility quite useful in keeping things straight.

Operating System

     Everything in this book is intended to run under MS-DOS, or PC-DOS,
     version 2.0 or later. However, there is nothing in any of the source
     code that verifies which operating system is in use, so be careful if
     you transport the code to earlier versions of MS-DOS or to another
     operating system.

Hardware

     Having a PC or PS/2 with a video display attached is essential. Video
     programming is like swimming: It's one thing to read about it, but
     it's quite another experience to try it yourself. In fact, if you plan
     to do a great deal of video programming, you should consider
     installing two different video subsystems and displays in your PC.
     With two separate sets of video hardware in the same computer, you can
     run a debugger on one screen while a test program produces output on
     the other screen. This dual-display hardware configuration is a real
     timesaver, particularly when you're developing video graphics routines
     such as those described in Chapters 5 through 9.

     Here is a list of the various computers and video adapters I used to
     develop the techniques discussed in this book:

     Computers
       IBM PC/XT
       IBM PC/AT
       IBM PS/2 Model 30
       IBM PS/2 Model 60

     Adapters
       IBM Monochrome Display Adapter
       IBM Color Graphics Adapter
       IBM Enhanced Graphics Adapter
       IBM PS/2 Display Adapter
       Hercules Graphics Card
       Hercules Graphics Card Plus
       Hercules Color Card
       Hercules InColor Card

     If you are using one of these computers or adapters, or a hardware-
     compatible clone, then you should be able to run the source code
     examples.

Manuals

     To program IBM PC video hardware effectively, you need to know what
     the hardware is designed to do and how software and the system BIOS
     are expected to interact with it. This basic information is found in
     IBM's Technical Reference manuals for the PC, PC/XT, PC/AT, and PS/2s
     and in its Options and Adapters Technical Reference manuals. Most
     second-source manufacturers of IBM PC video equipment also provide
     detailed technical information on their hardware.

     The material in this book is intended to complement the discussions in
     the manufacturers' technical documentation. I tried to follow the
     manufacturers' terminology and hardware descriptions wherever
     possible. However, the manufacturers' documentation goes somewhat awry
     at times. If you find a discrepancy between the official documentation
     and this book, you can (I hope) rely on this book to contain the right
     information.

     Still, in a book this size, I have certainly made some mistakes. I
     welcome your comments, criticisms, and suggestions.

     I have found that writing good video software is challenging, but the
     rewards are particularly satisfying. I hope to share some of the
     challenges--and some of the satisfaction--with you in this book.



                    1  IBM Video Hardware and Firmware


                      IBM PC and PS/2 Video Hardware
         IBM Monochrome Display Adapter and Color Graphics Adapter
           Hercules Graphics Card ş Hercules Graphics Card Plus
           IBM Enhanced Graphics Adapter ş Hercules InColor Card
             Multi-Color Graphics Array ş Video Graphics Array

                  Introduction to the ROM BIOS Interface
                  Interrupt 10H ş Video Display Data Area
            Accessing the Video BIOS from a High-Level Language



     Microcomputer video systems keep getting better. Since the
     introduction of the IBM PC in 1981, engineering technology has
     improved, and the market for more powerful video hardware has widened.
     Both IBM and its competitors have responded by developing increasingly
     sophisticated video adapters and displays, as well as the software to
     accompany them.

     This chapter provides an overview of the evolution of IBM PC and PS/2
     video hardware. This overview is by no means comprehensive, but it
     covers the most widely used video equipment that IBM and Hercules
     offer. The chapter concludes with an introduction to IBM's video BIOS,
     a set of drivers built into ROM in all IBM PCs and PS/2s, which
     provides a basic programming interface for video applications.


IBM PC and PS/2 Video Hardware


     A "plain vanilla" IBM PC/XT or PC/AT contains no built-in video
     hardware, so you must select and install the video hardware yourself.
     In a typical configuration, a video display (monitor) is attached with
     a 9-wire cable to a video adapter installed inside the PC. A typical
     video adapter is a printed circuit board with a 9-pin connector that
     attaches to the monitor's cable and a 2-by-31-connection card-edge tab
     that inserts into one of the slots on the PC's motherboard. Figure
     1-1 shows these connectors, as well as some of the integrated
     circuits common to many IBM video adapters. The circuitry in the video
     adapter generates the signals that control what is displayed on the
     monitor's screen.

     When you purchase an IBM PC, you must decide which video adapter and
     monitor to use. The most widely used video adapters with the most
     software written for them are IBM's Monochrome Display Adapter, Color
     Graphics Adapter, and Enhanced Graphics Adapter, and the monochrome
     Graphics Card made by Hercules.

     In contrast, all IBM PS/2 series computers are equipped with a built-
     in video subsystem, so purchasing a separate video adapter is
     unnecessary. The video subsystem in the PS/2 Models 25 and 30 is
     called the Multi-Color Graphics Array. In Models 50, 60, and 80, the
     integrated video subsystem is commonly known as the Video Graphics
     Array. The Video Graphics Array subsystem also is available as an
     adapter for the PC/XT, PC/AT, and PS/2 Model 30. This adapter has
     essentially the same hardware features as the integrated  PS/2
     subsystem.


IBM Monochrome Display Adapter and Color Graphics Adapter

     When the PC was introduced in 1981, IBM offered two video adapters:
     the Monochrome Display Adapter (MDA) and the Color Graphics Adapter
     (CGA). The MDA is designed for use with a monochrome monitor (the IBM
     Monochrome Display) that displays 80 columns and 25 rows of
     alphanumeric text. The CGA supports either an RGB display (a monitor
     with separate input signals for red, green, and blue) or a home
     television set (which uses a composite video signal). The CGA, of
     course, can display graphics information on a dot-by-dot basis as well
     as alphanumeric text.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 1-1 is found on page 3         º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

           Figure 1-1.  A typical IBM PC video adapter.


     Even though both the MDA and the CGA can display 25 rows of 80-column
     text, most people find the MDA's green monochrome display easier on
     the eyes. This is because the monochrome display used with an MDA has
     significantly higher resolution than that of any monitor you can use
     with the CGA. Its resolution is 720 dots wide and 350 dots high; the
     maximum resolution of a CGA-driven display is 640 dots wide and 200

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     dots high.

     Both adapters display characters in a rectangular matrix of dots. A
     simple calculation shows that each character is 9 dots wide and 14
     dots high on a Monochrome Display but only 8-by-8 dots on a CGA
     display. The MDA's higher resolution produces more crisply defined
     characters that are easier to read. For this reason, most PC users who
     need to read text prefer an MDA to a CGA.

     On the other hand, many computer users need to display charts,
     diagrams, and other graphics information in addition to alphanumeric
     text. Also, displaying colors on the screen is essential to many
     computer applications. Because the MDA can display only monochrome
     text, PC users who need graphics output can compromise by using the
     CGA, with its dot-by-dot color graphics capability but less-readable
     text.

     Why not just attach the higher-resolution monochrome display to a
     Color Graphics Adapter and get the best of both worlds? Unfortunately,
     the video signals generated by an MDA are incompatible with those
     required to drive a CGA monitor, and vice versa. Mismatching the
     monitor and the adapter leads to a malfunctioning monitor instead of a
     higher-resolution display.

     If you need sharp, readable text as well as color graphics, and you
     can afford the extra equipment, you can install both an MDA and a CGA
     in the same PC. You can then use the monochrome display (attached to
     the MDA) for text processing and an RGB color display (driven by the
     CGA) for color graphics.


Hercules Graphics Card

     Hercules' solution to the problem of displaying readable text and dot-
     by-dot graphics on the same monitor was to add graphics capability to
     a monochrome display adapter. The monochrome Hercules Graphics Card
     (HGC), introduced in 1982, can display graphics and alphanumeric text
     on the same green monochrome display that is used with an IBM MDA. (In
     addition to its graphics capabilities, the HGC exactly duplicates the
     function of IBM's original MDA.) The ability to display a combination
     of readable text and monochrome graphics is sufficient for many
     applications, so many PC users find the HGC an economical option.
     Because it has received support from major software vendors, the HGC
     has become firmly established in the marketplace.


Hercules Graphics Card Plus

     The HGC+ was released in June 1986. The big difference in this upgrade
     of the original HGC is that it can display customized, RAM-based
     alphanumeric character sets, whereas the MDA and HGC can display only
     one, predefined, ROM-based alphanumeric character set. Because
     alphanumeric characters can be displayed much more rapidly than dot-
     by-dot graphics characters, using the HGC+ can double or triple the
     speed of some text-oriented applications.


IBM Enhanced Graphics Adapter

     A different response to the demand for better text and graphics
     resolution is IBM's Enhanced Graphics Adapter (EGA), released in early
     1985. The EGA can be configured to emulate either an MDA or a CGA;
     what makes the EGA "enhanced" is that it can also do things its
     predecessors cannot. Unlike the MDA, the EGA can produce dot-by-dot
     graphics on a monochrome display. Furthermore, the EGA improves on the
     CGA with the ability to generate 16-color alphanumeric or graphics
     images with 640-by-350 resolution.

     Although the resolution and color capabilities of the EGA are not that
     much greater than those of the CGA, both text and graphics appear much
     sharper on the EGA than on the CGA. The availability of low-priced EGA
     clones and of high-quality software applications that exploit the
     adapter's capabilities have made the EGA a de facto hardware standard
     in the marketplace.


Hercules InColor Card

     The Hercules InColor Card, introduced in April 1987, is essentially a
     16-color version of the HGC+. The InColor hardware fully emulates the
     HGC+, so programs that run properly on the HGC+ can run without change
     on the InColor Card. The InColor Card's resolution is the same as that
     of the HGC and HGC+: 720 horizontal by 348 vertical pixels. The
     adapter's color capabilities equal those of the EGA. It can display 16
     colors at once from a palette of 64 colors. The adapter must be used
     with an EGA-compatible color display that has 350-line vertical
     resolution.

       ÉÍÍÍ»     Don't confuse the InColor Card with the Hercules Color
       º T º     Card, an augmented CGA clone designed for use in the same
       º I º     computer with an HGC or HGC+.
       º P º
       ÈÍÍÍ¼


Multi-Color Graphics Array

     The Multi-Color Graphics Array (MCGA) is the video subsystem
     integrated into the PS/2 Models 25 and 30. From a programmer's
     perspective, the MCGA resembles the CGA in many ways, yet the MCGA has
     much better resolution (a maximum of 640 horizontal by 480 vertical
     dots) and improved color-display capabilities.

     A significant difference between the MCGA and the above video adapters
     is that the MCGA generates analog RGB video signals, whereas the
     others produce digital RGB signals. The difference between digital and
     analog RGB is something like the difference between an on-off wall
     switch and a dimmer switch. With digital RGB signals, the video
     display must recognize only whether the signal for a particular color
     (red, green, or blue) is on or off. On the other hand, a video display
     that uses analog RGB signals translates the voltage of each signal
     into a wide range of corresponding color intensities. Only an analog
     video display can be used with the MCGA.

       ÉÍÍÍ»     Some video monitors can be configured for either analog or
       º T º     digital video signals. If you use the right cable, these
       º I º     monitors can be connected to an MCGA if they are
       º P º     configured for analog video.
       ÈÍÍÍ¼

     The justification for using analog video is that it can display a
     wider range of colors. The MCGA has a video Digital to Analog
     Converter (DAC) that enables the subsystem to display as many as 256
     different colors at once from a palette of 262,144 (256 K or 2^18)
     colors. In addition to an analog color display, IBM supplies an analog
     monochrome display for use with the MCGA. With a monochrome monitor,
     the MCGA can display as many as 64 shades of gray.


Video Graphics Array

     The term Video Graphics Array (VGA) refers specifically to part of the
     circuitry of the video subsystem in PS/2 Models 50, 60, and 80. The
     VGA is actually a single chip that integrates the same set of
     functions performed by several chips on the EGA. Nevertheless, people
     generally use the abbreviation VGA to describe the entire video
     subsystem.

     The VGA's programming interface is similar to the EGA's, so many
     programs written for the EGA will run unchanged on the VGA. The VGA is
     capable of somewhat higher display resolution (as much as 720-by-400
     in text modes, or 640-by-480 in graphics modes). Like the MCGA,
     however, the VGA contains a video DAC that can generate 256 colors at
     a time from a possible 262,144. Because the VGA generates the same
     analog RGB signals as the MCGA, it must be used with the same analog
     monochrome or color monitors.


Introduction to the ROM BIOS Interface


     A set of BIOS (Basic Input/Output System) routines in ROM is built
     into every IBM PC and PS/2. The ROM BIOS routines provide an interface
     to standard hardware features, including the time-of-day clock, the
     keyboard, floppy and hard disks, and of course the video subsystem.
     The video BIOS routines comprise a set of simple tools for performing
     basic video programming tasks such as writing strings of characters to
     the screen, erasing the screen, changing colors, and so on.

     Although the ROM BIOS video routines are sometimes slow and relatively
     unsophisticated, programs that use them are portable among different
     video subsystems in IBM PCs and PS/2s. Furthermore, most manufacturers
     of IBM PC clones have duplicated the functions of IBM's BIOS in their
     machines. Thus, a program that uses BIOS routines to access the video
     hardware is likely to be more portable than one that does not.


Interrupt 10H

     The BIOS routines are written in assembly language, so accessing them
     is easiest when you program in assembly language. All BIOS video
     routines are accessed by executing 80x86 software interrupt 10H. (The
     term 80x86 refers to the microprocessors in the Intel 8086 family:
     8086, 8088, 80286, and 80386.) For this reason, the ROM BIOS video
     interface is widely known as the INT 10H interface. The ROM BIOS
     supports a number of video input/output functions, each accessed by
     executing interrupt 10H. The functions are numbered; before executing
     interrupt 10H, you place the number of the desired function in 80x86
     register AH.

     At the time the interrupt is executed, the remaining 80x86 registers
     usually contain parameters to be passed to the BIOS routines. If the
     INT 10H function returns data to your program, it does so by leaving
     the data in one or more of the 80x86 registers. This register-based
     parameter-passing protocol is intended for use in assembly-language
     programs.

     To see how the INT 10H interface is typically used, examine the
     assembly-language routine SetVmode() in Listing 1-1. This routine can
     be linked with a program written in Microsoft C. (The underscore
     preceding the procedure name, the near keyword in the PROC
     declaration, and the use of the stack to pass parameters all follow
     Microsoft C conventions.) The heart of the routine is its call to the
     ROM BIOS to configure the video hardware for a particular video mode.
     (The details of this operation are discussed in Chapter 2 and in
     Appendix A.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     Listing 1-1.  SetVmode().

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The actual call to the video BIOS is simple. First, the desired
     function number is placed into register AH (XOR AH,AH). Then, after
     preserving the contents of register BP on the stack (PUSH BP), the
     routine invokes the ROM BIOS function by executing interrupt 10H
     (INT 10H).

     In Listing 1-2, a complementary routine called GetVmode() interrogates
     the BIOS for the number of the current video mode. The routine obtains
     this number by executing interrupt 10H function 0FH. The ROM BIOS
     function leaves the mode number in register AL. GetVmode() then
     returns the number to the calling program.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 1-2.  GetVmode().

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Video Display Data Area

     The code that precedes the actual call to the ROM BIOS in Listing 1-1 
     modifies one of several global variables that reflect the status of
     the PC's video subsystem. These variables are updated and referenced
     by all ROM BIOS video routines. They are collected in a block of RAM
     called, in IBM's technical documentation, the Video Display Data Area
     (or Video Control Data Area). The Video Display Data Area consists of
     two blocks of RAM. The first block is found between memory locations
     0040:0049 and 0040:0066, the second between 0040:0084 and 0040:008A.

     Some video BIOS routines also reference a 2-bit field in a global
     variable at 0040:0010 (called EQUIP_FLAG in IBM's technical
     documentation). Bits 4 and 5 of this variable indicate a default video
     mode to be used when the computer is first booted. The code in
     SetVmode() updates this bit field to conform with the video mode being
     selected. For example, if a Monochrome Display Adapter (MDA) is
     required for the desired video mode, the bit field in EQUIP_FLAG is
     updated accordingly. (Again, details on ROM BIOS video modes are found
     in Chapter 2 and in Appendix A.)

       ÉÍÍÍ»     Throughout this book are references to the INT 10H
       º T º     interface, the BIOS's Video Display Data Area, and the
       º I º     symbolic names of specific locations in the Video Display
       º P º     Data Area that are of particular interest. If you aren't
       ÈÍÍÍ¼     already familiar with the available INT 10H functions and
                 the contents of the Video Display Data Area, a perusal of
                 Appendix A might be very helpful.


Accessing the Video BIOS from a High-Level Language

     You can make ROM BIOS routines accessible in high-level language
     programs with an assembly-language routine such as SetVmode() or
     GetVmode(). Listings 1-3 and 1-4 are short C programs that can be
     executed as MS-DOS commands. The program in Listing 1-3 calls
     SetVmode() to select a video mode. This program may be executed
     interactively or from a batch file. The program in Listing 1-4 calls
     GetVmode() and returns the video mode number in a way that can be used
     in a batch file (that is, with IF ERRORLEVEL == commands).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 1-3.  A C program based on SetVmode().

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 1-4.  A C program based on GetVmode().
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The overall process of generating an executable file for one of these
     programs consists of compiling the C code to produce an object module,
     assembling the assembly-language code to produce another object
     module, and linking the object modules to create the executable file.
     If the C source code in Listing 1-3 is contained in a file named SM.C
     and the assembly code in Listing 1-1 is saved in SETVMODE.ASM, you
     can build the executable file SM.EXE as follows:


msc       sm;          (compile the C code)
masm      setvmode;    (assemble the subroutine)
link      sm+setvmode; (link the object modules)


       ÉÍÍÍ»     Some high-level language compilers can generate
       º T º     appropriate object code for loading the 80x86 registers,
       º I º     executing interrupt 10H, and copying the results from the
       º P º     registers to the calling program. If your compiler has
       ÈÍÍÍ¼     this capability, you might prefer to access the INT 10H
                 interface directly, instead of linking an assembly-
                 language subroutine to your high-level program. For
                 example, Listing 1-5 uses Microsoft C's int86() function
                 to implement GetVmode().


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 1-5.  Microsoft C's int86() function.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Many other INT 10H functions are available in the ROM BIOS. Your
     application program accesses them by loading the appropriate registers
     and executing interrupt 10H. Although the INT 10H support for video
     input/output admittedly is less than perfect, it is widely used in
     operating-system software (including MS-DOS) as well as in countless
     applications. If you want to write effective video and graphics
     programs, become familiar with the capabilities and the limitations of
     the INT 10H interface.



                        2  Programming the Hardware


           Functional Components of IBM PC and PS/2 Video Subsystems
                            Monitor ş Video Buffer
                     Color and Character Display Hardware
                                CRT Controller

                           The Display Refresh Cycle
                      Horizontal Timing ş Vertical Timing

                        Programming the CRT Controller
               MDA ş CGA ş Hercules Adapters ş EGA ş MCGA ş VGA

                            Basic CRTC Computations
                Dot Clock ş Horizontal Timing ş Vertical Timing

                            The CRT Status Register

                                  Video Modes
                Resolution ş Colors ş Video Buffer Organization

                          Hardware Video Mode Control
                           MDA ş CGA and MCGA ş HGC
                      HGC+ and InColor Card ş EGA and VGA
                              Video BIOS Support

                       Combinations of Video Subsystems
                    MDA ş Hercules ş CGA ş EGA ş MCGA ş VGA



     This chapter describes IBM PC and PS/2 video hardware from a
     programmer's point of view. It covers the basics: which parts of the
     computer's video subsystem can be programmed, how a program interacts
     with the hardware, and how calculations for changing the video display
     format are performed. Many of the programming techniques in later
     chapters are based on the fundamental information discussed here.

     The purpose of this chapter is to demystify the hardware programming
     interface. Because most programmers rely on the video BIOS to perform
     most, if not all, hardware-level programming in their applications, an
     aura of mystery surrounds the way software interacts with video
     hardware. Of course, after you learn about it, you may wish it had
     remained a mystery--but the more you know, the more your programs will
     be able to do with the video hardware.


Functional Components of IBM PC and PS/2 Video Subsystems


     As you write programs that interact with IBM video hardware, it helps
     to visualize the relationships among the programmable components of
     IBM video subsystems (see Figure 2-1). You do not need a circuit
     designer's understanding of the hardware to write a good video
     interface. You do need to know where and how your program can interact
     with the hardware to produce video output efficiently.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³             ³  Attributes       ³  Attribute  ³
     ³    Video    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³   decoder   ³
     ³    Buffer   ³                   ³             ³
     ³             ³                   ÀÄÄÄÄÄÄÂÄÄÄÄÄÄÙ
     ³             ³                          ³Color, intensity, etc.
     ÀÄÄÄÄÄÄÂÄÄÄÄÄÄÙ                          
            ³Character codes           ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                      ³             ³
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                   ³    Video    ³Video drive signals
     ³ Alphanumeric³                   ³   signal    ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     ³  character  ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ³  generator  ³(to video display)
     ³  generator  ³                   ³             ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                             
            ³Horizontal & vertical timing   ³  ³Internal timings,
            ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ  ³buffer addressing, etc.
     ÚÄÄÄÄÄÄÁÄÄÄÄÄÄ¿                   ÚÄÄÄÄÄÄÄÁÄÄÄÄÄ¿

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     ³     CRT     ³                   ³    Mode     ³
     ³ Controller  ³                   ³   control   ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 2-1.  Programmable components (video buffer, attribute
     controller, and so on) of the IBM PC and PS/2 video subsystems. Some
     or all of these components are under software control in each of the
     video subsystems described in this book.


Monitor

     The most tangible part of a computer's video hardware is the monitor,
     or video display. However, there's nothing you can directly program in
     the monitor's hardware. It is the computer's video subsystem that
     contains programmable hardware. The signals generated by the video
     subsystem control what appears on the screen.

     The monitor differs from a home television receiver in that a group of
     separate timing and color signals drives it. In contrast, a home TV
     decodes a single "composite" signal that contains timing, color, and
     audio information. Although some IBM PC video adapters can generate
     such composite video output signals, as well as the direct drive
     signals that computer monitors use, most people avoid using a home
     television with their computers. Both text and colors appear sharper
     on a computer monitor than they do on a composite television screen.

     All the video monitors discussed in this book are raster-scan devices.
     The image on the screen of a monitor is made up of a group of closely
     spaced horizontal lines called the raster. An electron beam scans each
     successive line from left to right, starting at the upper left corner
     of the display. As the beam sweeps each line, the color and brightness
     of each of several hundred points (pixels) in the line are varied, and
     the entire raster appears as a coherent image.

     Conceptually, you can regard the electron beam as having "color" and
     "intensity," but in color video monitors the beam actually comprises
     three separate electron beams. Each beam controls the display of one
     of the three primary video colors (red, green, and blue) on the
     screen. Each pixel on a color display is physically represented by a
     small, closely spaced triad of red, green, and blue luminescent dots
     or stripes of phosphor. The three electron beams are masked in such a
     way that each illuminates dots of only one primary color. Thus, the
     relative intensity of the beams as they sweep over each triad
     determines the color and brightness of the pixels. Of course, unless
     you use a magnifying glass or look closely at the display, you do not
     perceive the red, green, and blue dots individually, but rather as
     blended colors.


Video Buffer

     The video buffer is a block of RAM in the video subsystem where
     displayable data is stored. This RAM lies within the address space of
     the computer's CPU, so a program may read from and write to the video
     buffer in the same way it accesses any other portion of RAM.

     The video subsystem's display circuitry updates, or refreshes, the
     screen by continually and repeatedly reading the data in the video
     buffer. Each bit or group of bits in the video buffer specifies the
     color and brightness of a particular location on the screen. The
     screen is refreshed between 50 and 70 times a second, depending on
     which video subsystem is in use. Obviously, when a program changes the
     displayed contents of the video buffer, the screen changes almost
     immediately.

     The actual amount of RAM available as a video buffer varies with the
     video subsystem. Most IBM video subsystems incorporate video buffers
     large enough to hold more than one screen of displayable data, so only
     part of the buffer is visible on the screen at any time. (Chapter 3
     discusses how to make full use of available video RAM.)


Color and Character Display Hardware

     All IBM video subsystems incorporate hardware that reads and decodes
     the data in the video buffer. For example, an alphanumeric character
     generator translates ASCII codes from the video buffer into the dot
     patterns that make up characters on the screen. An attribute decoder
     translates other data in the video buffer into the signals that
     produce colors, underlining, and so forth. Software can control these
     and other specialized components of the video subsystem; later
     chapters describe such programming in detail.


CRT Controller

     The CRT Controller (or CRTC for short) generates horizontal and
     vertical timing signals. It also increments a video buffer address
     counter at a rate that is synchronized with the timing signals. The
     video display circuitry reads data from the video buffer using the
     CRTC's address value, decodes the data, and sends the resulting color
     and brightness signals to the monitor along with the CRTC's timing
     signals. In this way the CRTC synchronizes the display of data from
     the video buffer with the timing signals that drive the video display.

     The CRTC performs several other miscellaneous functions. Among them
     are determining the size and displayed position of the hardware
     cursor, selecting the portion of the video buffer to be displayed,
     locating the hardware underline, and detecting light pen signals.
     (Chapter 3 contains examples of CRTC programming for some of these
     functions.)

     On the MDA, CGA, and Hercules cards, the CRTC is a single chip, the
     Motorola 6845. On the EGA, the CRTC is a custom LSI (large-scale
     integration) chip designed by IBM. On the MCGA, the CRTC is part of
     its Memory Controller Gate Array. The VGA's CRTC is one component of
     the single-chip Video Graphics Array. Regardless of the hardware
     implementation, the CRTC can be programmed to generate a variety of
     timing parameters in all these subsystems. Before delving into the
     techniques of CRTC programming, however, it is worthwhile to review
     how the CRTC's timing signals control the monitor's display of a
     raster-scan video image.


The Display Refresh Cycle


     The video image is refreshed in a cyclic manner between 50 and 70
     times a second, depending on the configuration of the video subsystem.
     During each refresh cycle, the electron beam sweeps across the screen
     in a zigzag fashion, starting at the left side of the topmost
     horizontal line in the raster (see Figure 2-2). After scanning a line
     from left to right, the beam is deflected down to the start of the
     next line until the entire raster is scanned. Then the beam returns to
     the upper left corner of the display, and the cycle repeats.


             ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
             º                                          º
             º    Figure 2-2 is found on page 17        º
             º    in the printed version of the book.   º
             º                                          º
             ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼

     Figure 2-2.  The path followed by the electron beam in a raster scan.


Horizontal Timing

     A number of carefully timed events occur as the beam moves across the
     display. At the beginning of each line, the electron beam is turned on
     in response to a Display Enable signal that the CRTC generates. As the
     beam sweeps left to right across the line, the video display circuitry
     uses the CRTC's address counter to read a sequence of bytes from the
     video buffer. The data is decoded and used to control the color and
     brightness signals sent to the monitor. As the beam sweeps across the
     screen, its color and brightness vary in response to these signals.

     Near the screen's right edge, the CRTC turns off the Display Enable
     signal and no further data is displayed from the video buffer. The
     CRTC then generates a horizontal sync signal, which causes the monitor
     to deflect the electron beam leftward and downward to the start of the
     next horizontal line in the raster. Then the CRTC turns the Display
     Enable signal back on to display the next line of data.

     The short period of time between the end of one line of video data and
     the beginning of the next is called the horizontal blanking interval.
     Because the horizontal retrace interval (the amount of time required
     to deflect the beam to the start of the next line) is shorter than the
     horizontal blanking interval, a certain amount of horizontal overscan
     is generated on both ends of each line (see Figure 2-3).


                ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                ³        ³ Vertical overscan        ³
                ³   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³
                ³   ³                           ³   ³
                ³   ³                           ³   ³
                ³   ³                           ³   ³
      Horizontal³   ³                           ³   ³ Horizontal
      overscan  ³Ä³                           ³Ä³ overscan
                ³   ³                           ³   ³
                ³   ³                           ³   ³
                ³   ³                           ³   ³
                ³   ³                           ³   ³
                ³   ³                           ³   ³
                ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ³
                ³        ³ Vertical overscan        ³
                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 2-3.  Overscan.


     During periods of horizontal overscan, the electron beam can be left
     on, displaying an overscan, or border, color. However, the primary
     reason horizontal overscan is designed into a video subsystem is to
     provide a margin of error in centering the raster, so that no data is
     lost at the edges of the screen.


Vertical Timing

     Once the electron beam has scanned all horizontal lines in the raster,
     the Display Enable signal is turned off. The CRTC then generates a
     vertical sync signal, which tells the monitor to deflect the electron
     beam from the bottom of the screen back to the upper left corner. The
     vertical retrace interval (during which the beam travels from the
     bottom to the top of the screen) is shorter than the vertical blanking
     interval (during which no data from the video buffer is displayed), so

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     there are areas of vertical overscan at the top and bottom of the
     raster (see Figure 2-3). Like horizontal overscan, vertical overscan
     provides a border as well as a safety margin so that the raster can be
     centered on the screen.


Programming the CRT Controller


     The CRTC programming interface is well defined and easy to use. The
     same general programming approach applies to all IBM PC and PS/2 video
     subsystems.


MDA

     The Monochrome Display Adapter's CRTC, the Motorola 6845, has nineteen
     8-bit internal data registers. The contents of each register control
     various characteristics of the timing signals generated by the 6845
     (see Figure 2-4). One of these registers is an address register; its
     contents indicate which of the other 18 can be accessed. Most of the
     registers are write-only, but registers 0EH and 0FH, which control the
     position of the hardware cursor, may be read as well as written. On
     the MDA, the 6845's Address register is mapped to an I/O port at 3B4H,
     and the remaining 18 registers are all mapped to the next I/O port
     at 3B5H.

     To access the 6845's data registers, you first write the register
     number to the 6845's Address register (I/O port 3B4H). Then you access
     the specified data register with an I/O write or read at port 3B5H.
     For example, Listing 2-1 shows how to determine the current cursor
     location by reading the contents of registers 0EH and 0FH on the 6845.
     These two registers (Cursor Location High and Cursor Location Low)
     contain the high-order and low-order bytes of the cursor location
     relative to the start of the video buffer.


Register  Name                          Read/Write Access
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H       Horizontal Total              Write only
01H       Horizontal Displayed          Write only
02H       Horizontal Sync Position      Write only
03H       Horizontal Sync Pulse Width   Write only
04H       Vertical Total                Write only
05H       Vertical Total Adjust         Write only
06H       Vertical Displayed            Write only
07H       Vertical Sync Position        Write only
08H       Interlace Mode                Write only
09H       Maximum Scan Line             Write only
0AH       Cursor Start                  Write only
0BH       Cursor End                    Write only
0CH       Start Address High            Write only
0DH       Start Address Low             Write only
0EH       Cursor Location High          Read/Write
0FH       Cursor Location Low           Read/Write
10H       Light Pen High                Read only
11H       Light Pen Low                 Read only
     Figure 2-4.  Motorola 6845 CRTC data registers (for the MDA, CGA, and
     Hercules video adapters).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 2-1.  Reading the 6845 Cursor Location registers.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     With the MDA, there is rarely any reason to change the values in any
     of the 6845 registers except 0AH and 0BH (Cursor Start and Cursor End)
     and 0EH and 0FH (Cursor Location High and Low). Registers 00H through
     09H control the horizontal and vertical timing signals, which should
     not be changed. Registers 0CH and 0DH (Start Address High and Start
     Address Low), which indicate what part of the MDA's video buffer is
     displayed, should always be set to 0.


CGA

     The Color Graphics Adapter's CRTC is a Motorola 6845, as is the MDA's.
     The same programming technique used to access the CRTC on the MDA also
     works on the CGA. On the CGA, however, the CRTC Address register is
     mapped to I/O port 3D4H and the data registers are accessed at 3D5H.
     If you write a program that can run on either an MDA or a CGA, you can
     take advantage of the fact that the video BIOS routines in both the PC
     and PS/2 families maintain the value of the CRTC's Address register
     I/O port in a variable. Many of the programming examples in this book
     reference this variable, ADDR_6845, which is located at 0040:0063 in
     the BIOS Video Display Data Area.


Hercules Adapters

     Like the MDA and CGA, the Hercules Graphics Card, Graphics Card Plus,
     and InColor Card all use a Motorola 6845 as a CRTC. The CRTC registers
     are mapped at I/O ports 3B4H and 3B5H on all Hercules adapters.
     Although it is a color adapter, the InColor Card uses the MDA's I/O
     port and video buffer addresses in order to preserve compatibility
     with the MDA and with Hercules monochrome adapters.

       ÉÍÍÍ»     On all Hercules video adapters (as well as the EGA, MCGA,
       º T º     and VGA), you can set both the address and data registers
       º I º     of the CRTC with one 16-bit port write (OUT DX,AX) instead
       º P º     of two 8-bit port writes  (OUT DX,AL). For example, the
       ÈÍÍÍ¼     two sequences of code that follow do the same thing to the
                 CRTC.

mov     dx,3B4h         ; CRTC address register
mov     al,0Ch          ; CRTC register number
out     dx,al           ; select this register
inc     dx              ; DX := 3B5h (CRTC data register)
mov     al,8            ; data
out     dx,al           ; store data in register
dec     dx

     and

mov     dx,3B4h         ; CRTC address register
mov     ax,080Ch        ; AL := reg number, AH := data
out     dx,ax           ; store data in register


EGA

     The Enhanced Graphics Adapter's CRTC is a proprietary LSI chip with a
     set of registers different from those in the 6845 (see Figure 2-5).
     The programming interface is similar to the 6845's, but the register
     assignments and formats are different enough that programs that write
     directly to CRTC registers on the MDA or CGA will probably crash on an
     EGA.

     The EGA's CRTC supports a wider set of control functions than does the
     6845. For example, the CRTC can cause a hardware interrupt at the
     start of a vertical blanking interval. The CRTC also supports the
     simultaneous display of two noncontiguous portions of the video
     buffer. (Chapter 12 describes these CRTC capabilities.)

     A curious feature of the EGA's CRTC is its Overflow register (07H).
     Because the EGA can display a raster of more than 256 lines, the CRTC
     registers that contain a number of scan lines must be 9 bits wide
     instead of 8. The high-order bit in each of these registers is stored
     in the Overflow register.


Register  Name                          EGA Read/Write Access
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H       Horizontal Total              Write only
01H       Horizontal Display Enable End Write only
02H       Start Horizontal Blanking     Write only
03H       End Horizontal Blanking       Write only
04H       Start Horizontal Retrace      Write only
05H       End Horizontal Retrace        Write only
06H       Vertical Total                Write only
07H       Overflow                      Write only
08H       Preset Row Scan               Write only
09H       Maximum Scan Line Address     Write only
0AH       Cursor Start                  Write only
0BH       Cursor End                    Write only
0CH       Start Address High            Read/Write
0DH       Start Address Low             Read/Write
0EH       Cursor Location High          Read/Write
0FH       Cursor Location Low           Read/Write
10H       Vertical Retrace Start        Write only
10H       Light Pen High                Read only
11H       Vertical Retrace End          Write only
11H       Light Pen Low                 Read only
12H       Vertical Display Enable End   Write only
13H       Offset (Logical Line Width)   Write only
14H       Underline Location            Write only
15H       Start Vertical Blanking       Write only
16H       End Vertical Blanking         Write only
17H       Mode Control                  Write only
18H       Line Compare                  Write only
     Figure 2-5.  EGA and VGA CRT Controller data
     registers.


MCGA

     In the MCGA, the functions of a CRTC are integrated into a circuit
     component called the Memory Controller Gate Array. The first 16 Memory
     Controller registers are analogous to those in the 6845 (see Figure 2-
     6). As on the CGA, all MCGA Memory Controller registers, including
     the CRTC registers, are indexed through an address register at I/O
     port 3D4H. The data registers themselves may be accessed at port
     3D5H.

     Several features of the MCGA's CRTC distinguish it from the CGA's
     6845. All of the Memory Controller registers can be read as well as
     written. Moreover, registers 00H through 07H may be designated read-
     only so that horizontal and vertical timing parameters are not
     inadvertently disrupted. Setting bit 7 of the Memory Controller Mode
     Control register (10H) to 1 protects registers 00H through 07H.

     Another feature of the MCGA CRTC is that the hardware can compute the
     horizontal timing parameters for each of the available video modes.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     When bit 3 of the Mode Control register is set to 1, and when the
     values in registers 00H through 03H represent appropriate horizontal
     timing values for 40-by-25 alphanumeric mode (video BIOS mode 0), the
     Memory Controller generates proper horizontal timing signals in all
     available video modes.

     If you compare the MCGA CRTC and the Motorola 6845 register by
     register, you will note several discrepancies in the interpretation of
     the values stored in some CRTC registers. In particular, the values
     expected in registers 09H, 0AH, and 0BH are specified in units of two
     scan lines on the MCGA, instead of one scan line on the 6845. Because
     the default alphanumeric character matrix on the MCGA is 16 scan lines
     high, this feature provides a certain amount of low-level
     compatibility, letting you use the same values for these registers as
     you would on a CGA.


Register  Name                               Read/Write Access
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H       Horizontal Total                   Read/Write
01H       Horizontal Displayed               Read/Write
02H       Start Horizontal Sync              Read/Write
03H       Sync Pulse Width                   Read/Write
04H       Vertical Total                     Read/Write
05H       Vertical Total Adjust              Read/Write
06H       Vertical Displayed                 Read/Write
07H       Start Vertical Sync                Read/Write
08H       (reserved)
09H       Scan Lines per Character           Read/Write
0AH       Cursor Start                       Read/Write
0BH       Cursor End                         Read/Write
0CH       Start Address High                 Read/Write
0DH       Start Address Low                  Read/Write
0EH       Cursor Location High               Read/Write
0FH       Cursor Location Low                Read/Write
10H       Mode Control                       Read/Write
11H       Interrupt Control                  Read/Write
12H       Character Generator, Sync Polarity Read/Write
13H       Character Generator Pointer        Read/Write
14H       Character Generator Count          Read/Write
20-3FH    (reserved)
     Figure 2-6.  MCGA Memory Controller data registers. Registers 00H
     through 0FH are comparable to those in the CGA's CRT Controller.


VGA

     Functionally, the VGA's CRTC registers (see Figure 2-5) comprise a
     superset of those in the EGA's CRTC. The VGA's CRTC register set is
     addressable at the same I/O ports as the EGA's. A few more bit fields
     have been added to the register set, primarily so that the CRTC can
     handle 400-line and 480-line rasters. However, unlike the EGA's CRTC,
     the VGA's CRTC does not support the use of a light pen.

     More important, however, all the EGA's CRTC register specifications
     have been carried over to the VGA. Thus, programs that write to the
     EGA's CRTC registers can be run unchanged on VGA-based hardware.

     As on the MCGA, the VGA's CRTC data registers can all be read as well
     as written. Also, the VGA horizontal and vertical timing registers
     (CRTC registers 00H through 07H) can be write-protected by setting bit
     7 of the Vertical Retrace End register (11H) to 1.

       ÉÍÍÍ»     As on Hercules adapters, you can program the CRTC on the
       º T º     EGA, MCGA, and VGA using a 16-bit port write (OUT DX,AX).
       º I º     Moreover, you will find by experimenting that 16-bit port
       º P º     writes work on many non-IBM video adapters. But stay away
       ÈÍÍÍ¼     from this technique on MDAs, CGAs, and clones if
                 portability is important.


Basic CRTC Computations


     To use the CRTC effectively, you must be able to perform the basic
     computations necessary to specify the CRTC's timings correctly. These
     computations are based on three constraints: the bandwidth of the
     video signal sent to the monitor and the monitor's horizontal and
     vertical synchronization rates.


Dot Clock

     IBM PC video subsystems display pixels at a rate determined by the
     hardware. This rate is variously known as the video bandwidth, the dot
     rate, or the pixel rate; the oscillator that generates this rate is
     called the dot clock. The MDA, CGA, and Hercules adapter use only one
     dot clock; on the EGA and VGA, more than one dot clock is available
     (see Figure 2-7). The higher the dot clock frequency, the better the
     displayed pixel resolution.

     Given the dot rate, the CRTC must be programmed so that the horizontal
     and vertical scan frequencies sent to the video display are limited to
     frequencies the display can handle. Older displays, such as the IBM
     Monochrome Display, are designed to handle only one horizontal and one
     vertical scan rate. Newer displays, such as the NEC MultiSync, can
     synchronize with a range of horizontal and/or vertical scan rates.


                       Video Bandwidth     Horizontal Scan   Vertical Scan
IBM Subsystem          (Dot Rate) in MHz   Rate in KHz       Rate in Hz
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA, HGC
720x350 mono           16.257              18.43             50

CGA
640x200 color          14.318              15.75             60

EGA 
640x350 color          16.257              21.85             60
640x200 color          14.318              15.75             60
720x350 mono           16.257              18.43             50

InColor 
720x350 color          19.000              21.80             60

MCGA
640x400 mono/color     25.175              31.50             70
640x480 mono/color     25.175              31.50             60

VGA
640x400 mono/color     25.175              31.50             70
720x400 mono/color     28.322              31.50             70
640x480 mono/color     25.175              31.50             60
640x350 mono/color     25.175              31.50             70
     Figure 2-7.  Basic timings for IBM video subsystems.


Horizontal Timing

     Consider how you would calculate the typical CRTC register values
     shown in Figure 2-8 for an MDA with an IBM Monochrome Display. The
     MDA's video bandwidth (dot rate) is 16.257 MHz; that is, 16,257,000
     dots per second. The monochrome display's horizontal scan rate is
     18.432 KHz (18,432 lines per second). Dividing the dot rate by the
     horizontal scan rate gives 882 dots per line. Each character displayed
     by the MDA is 9 dots wide, so the total number of characters in each
     line is 882 / 9, or 98.

     This value is used to program the CRTC's Horizontal Total register.
     For the MDA's CRTC, a Motorola 6845, the value you store in the
     Horizontal Total register must be 1 less than the computed total, or
     97 (61H).


Register  Name                      Parameter       Description
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H       Horizontal Total          97 (61H)        (total characters per
                                                    scan line) - 1

01H       Horizontal Displayed      80 (50H)        Characters displayed in
                                                    each scan line

02H       Horizontal Sync Position  82 (52H)        Position in scan line
                                                    where horizontal
                                                    retrace starts

03H       Horizontal Sync Width     15 (0FH)        Duration of horizontal
                                                    retrace interval
                                                    (character clocks)

04H       Vertical Total            25 (19H)        Total character rows in
                                                    one frame

05H       Vertical Total Adjust     2               Remaining scan lines in
                                                    one frame

06H       Vertical Displayed        25 (19H)        Character rows dis-
                                                    played in each frame

07H       Vertical Sync Position    25 (19H)        Position in frame where
                                                    vertical retrace
                                                    starts

08H       Interlace Mode            2               Always set to 2

09H       Maximum Scan Line         13 (0DH)        (height of one charac-
                                                    ter in scan lines) - 1
     Figure 2-8.  Typical CRTC parameters for the Monochrome Display
     Adapter.


     In terms of CRTC timings, the Horizontal Total value describes the
     amount of time, in "character clocks," required to complete one
     horizontal scan. During this period, 80 characters are actually
     displayed. (This is the value used for the Horizontal Displayed
     register.) The other 18 character clocks are spent in horizontal
     overscan and in horizontal retrace.

     The duration of the horizontal retrace interval is about 10 to 15
     percent of the Horizontal Total value. The exact value depends on the
     video subsystem. On the MDA, the horizontal retrace interval is set at
     15 character clocks by storing this value in the CRTC Horizontal Sync
     Width register. This leaves 3 character clocks of horizontal overscan.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     The horizontal retrace signal is programmed to start 2 character
     clocks after the rightmost displayed character by storing the value 82
     (52H) in the CRTC Horizontal Sync Position register. Thus, there are 2
     character clocks of right horizontal overscan and 1 character clock of
     left overscan.

       ÉÍÍÍ»     Changing the value in the Horizontal Sync Position
       º T º     register changes the size of the right and left overscan
       º I º     areas and thus the horizontal position of the displayed
       º P º     raster. For example, to shift the displayed raster to the
       ÈÍÍÍ¼     left, increase the size of the right overscan interval by
                 increasing the value in the CRTC Horizontal Sync Position
                 register.


Vertical Timing

     Similar considerations apply in programming the CRTC to generate
     appropriate vertical timings. The nominal horizontal scan rate in the
     MDA's monochrome display is 18.432 KHz (18,432 lines per second) with
     a vertical scan rate of 50 Hz (50 frames per second), so the number of
     lines in one frame is 18,432 / 50, or 368. Since each character
     displayed is 14 lines high, 25 rows of characters account for 350
     lines. The MDA's CRTC always uses 16 lines for vertical retrace; this
     leaves 368 - (350 + 16), or 2 lines of vertical overscan.

     The CRTC programming follows these calculations. The height of each
     displayed character is specified by the value in the CRTC Maximum Scan
     Line register. Since characters are 14 scan lines high, the maximum
     scan line value is 13 (0DH). Taken together, the values for Vertical
     Total (25 character rows) and Vertical Total Adjust (2 scan lines)
     indicate the total number of scan lines in one frame. The number of
     character rows displayed (25) is indicated in the Vertical Displayed
     register. The position in the frame where vertical retrace starts (25)
     is specified by the value in the Vertical Sync Position register.

     The CRTCs on the MCGA, EGA, and VGA are more complex than the Motorola
     6845 CRTC on the MDA and CGA. Nevertheless, the registers that control
     horizontal and vertical timings in the newer video subsystems are
     similar in nomenclature and functionality to the 6845's registers. The
     computations for the MCGA, EGA, and VGA CRTCs are derived from the dot
     rate, the character size, and the horizontal and vertical capabilities
     of the video display, just as they are for the MDA and CGA.


The CRT Status Register


     All IBM video subsystems have a read-only CRT Status register. This
     register is located at I/O port 3BAH on the MDA and Hercules adapters
     and at 3DAH on the CGA and MCGA; on the EGA and VGA, this register is
     at 3BAH in monochrome configurations and at 3DAH in color
     configurations. Generally, two of the eight bits in this register
     reflect the current status of the horizontal and vertical timing
     signals generated by the CRTC. These status bits can be used to
     synchronize video buffer updates with the screen refresh cycle to
     minimize interference with the displayed image. (Chapter 3 contains
     examples of this type of programming.)

     Unfortunately, the exact interpretation of the status bits in the CRT
     Status register varies among the different IBM video subsystems (see
     Figure 2-9). Therefore, programs should be designed to determine
     which hardware they are running on (Appendix C) before they attempt
     to use the status information in this register.

     Listing 2-2 shows how the status bits in the CRTC Status register are
     used to synchronize program operation with the video refresh cycle.
     This subroutine can be used on the CGA to time the horizontal blanking
     interval. The subroutine uses bit 3 of the CRT Status register, which
     indicates when the CRTC's vertical sync signal is active, to
     synchronize with the start of a refresh cycle. The loops at L01 and
     L02 show how this is done.

     The loops at L03 and L04 then synchronize with the Display Enable
     signal, using bit 0 of the CRT Status value. When the Display Enable
     signal goes off, the loop at L05 decrements the value in CX during the
     horizontal blanking interval, that is, while the Display Enable signal
     is off. The number of iterations counted in CX can then be used as a
     timeout value to determine when the last horizontal line in the frame
     has been scanned. (See Chapter 3.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 2-2.  Timing the horizontal blanking interval on the CGA

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Video Modes


     Despite the timing constraints imposed by the dot clock and the rated
     horizontal and vertical scan rates of available monitors, all IBM
     video subsystems except the MDA can be programmed with a variety of
     different CRTC parameters. This makes a number of video modes
     available. Each video mode is characterized by its resolution (the
     number of characters or pixels displayed horizontally and vertically),
     by the number of different colors that can be displayed
     simultaneously, and by the format of the displayable data in the video
     buffer.


Resolution

     The horizontal and vertical resolution in a video mode is a function
     of the dot rate as well as the monitor's horizontal and vertical scan
     rates. The number of pixels displayed in each frame corresponds to the
     dot rate divided by the vertical scan rate. The actual horizontal and
     vertical resolution then depends on the horizontal scan rate.


                    Register    Bit 7               Bit 3               Bit 2               Bit 1             Bit 0
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA                 3BA                             Video drive                                               1 = horizontal sync

HGC, HGC+, InColor  3BA         0 = vertical sync   Video drive                             1 = light pen     1 = horizontal sync
                                                                                                trigger
CGA                 3DA                             1 = vertical sync   1 = light pen       1 = light pen     0 = display enable
                                                                            switch closed       trigger
EGA                 3BA or 3DA                      1 = vertical sync   1 = light pen       1 = light pen     0 = display enable
                                                                            switch closed       trigger
VGA                 3BA or 3DA                      1 = vertical sync                                         0 = display enable

MCGA                3DA                             1 = vertical sync 1                                       0 = display enable
     Figure 2-9.  CRTC Status register bit assignments


Colors

     The number and variety of colors that can be displayed in a video mode
     depend on the design of the video subsystem's attribute decoding and
     video signal generator components. The attribute decoder uses data
     stored in the video buffer to control the color and brightness signals
     produced by the video signal generator. Establishing a particular
     video mode always involves programming a video subsystem's attribute
     decoder in addition to updating its CRTC parameters.


Video Buffer Organization

     The format of the data in video RAM also characterizes a video mode.
     In all PC and PS/2 subsystems, video modes can be classified as
     alphanumeric or graphics modes, depending on the video buffer data
     format. In alphanumeric modes, the data in the video buffer is
     formatted as a sequence of ASCII code and attribute byte pairs; the
     alphanumeric character generator translates the ASCII codes into
     displayed characters while the attribute bytes specify the colors used
     to display them (see Chapter 3). In graphics modes, the video buffer
     is organized as a sequence of bit fields; the bits in each field
     designate the color of a particular pixel on the screen.


Hardware Video Mode Control


     Establishing a video mode on an IBM PC or PS/2 video subsystem
     generally requires specific mode control programming apart from
     specifying CRTC parameters. For example, the alphanumeric character
     generator must be enabled in alphanumeric modes and disabled in
     graphics modes. Also, the subsystem's internal character clock, which
     determines the number of pixels generated for each alphanumeric
     character code read from the video buffer, may run at different rates
     in different video modes. These and other internal functions are
     controlled by loading one or more specialized mode control registers
     with values appropriate for each video mode.


MDA

     The MDA's Mode Control register is a write-only register mapped to
     port 3B8H (see Figure 2-10). Only three of the eight bits in this
     register have meaning. Bit 0 is set to 1 at powerup and must always
     remain set to 1. Bit 3, when set to 1, enables video refresh; clearing
     this bit blanks the screen. Bit 5 is the Enable Blink bit; it controls
     whether characters can blink. On the MDA, most programs leave bit 3
     set at all times. Chapter 3 explains how to use bit 5 (the Enable
     Blink bit).


Bit         Settings
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           1 = adapter enabled (should always = 1)
1           (unused, should always = 0)
2           (unused, should always = 0)
3           1 = video enabled
            0 = video disabled (screen blank)
4           (unused, should always = 0)
5           1 = blinking attribute enabled
            0 = blinking attribute disabled
6           (unused, should always = 0)
7           (unused, should always = 0)
     Figure 2-10.  Bit settings for the MDA Mode Control register (3B8H).


CGA and MCGA

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     The Mode Control register on the CGA and MCGA is found at 3D8H (see
     Figure 2-11a). The five low-order bits control internal timings
     appropriate for the video modes they select, while bit 5 is an Enable
     Blink bit just as it is on the MDA. The useful bit patterns for the
     CGA's Mode Control register are listed in Figure 2-11b. These values
     correspond to the available BIOS video modes on the CGA.

     The Mode Control registers on the CGA and the MCGA have two
     differences. One is that the MCGA Mode Control register may be read as
     well as written; the CGA register is write-only. The other difference
     relates to the function of bit 2. On the CGA, setting bit 2 to 1
     disables the color burst component of the composite video output
     signal. This can improve the quality of the display if you are using a
     composite green or amber monitor with a CGA. On the MCGA, which does
     not support a composite monitor, the function of bit 2 of the Mode
     Control register is to select between two sources for the foreground
     color in 2-color graphics modes.


Bit         Settings
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           1 = 80-character alphanumeric modes
            0 = 40-character alphanumeric modes
1           1 = 320-wide graphics mode
            0 = (all other modes)
2           1 = color burst disabled (CGA only)
            1 = foreground color from video DAC register 7 (MCGA only)
            0 = color burst enabled (CGA only)
            0 = foreground color from the video DAC register specified
                in bits 0-3 of the Palette register (3D9H) (MCGA only)
3           1 = video enabled
            0 = video disabled (screen blank)
4           1 = 640-wide graphics modes
            0 = (all other modes)
5           1 = blinking attribute enabled
            0 = blinking attribute disabled
6           (unused, should always = 0)
7           (unused, should always = 0)
     Figure 2-11a.  Bit settings for the CGA and MCGA Mode Control register
     (3D8H).


BIOS Mode                                Value for Mode
Number      Description                  Control Register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           40x25 alpha                  00101100b (2CH)
              (color burst disabled)
1           40x25 alpha                  00101000b (28H)
2           80x25 alpha                  00101101b (2DH)
              (color burst disabled)
3           80x25 alpha                  00101001b (29H)
4           320x200 graphics             00101010b (2AH)
5           320x200 graphics             00101110b (2EH)
              (color burst disabled)
6           640x200 graphics             00011100b (1CH)
7           80x25 alpha                  00101001b (29H)
              (MDA only)
11H         640x480 graphics             00011000b (18H)
              (MCGA only)
     Figure 2-11b.  MDA, CGA, and MCGA Mode Control register options.


     The MCGA has two additional mode control registers, which are not
     implemented on the CGA. The MCGA Memory Controller Mode Control
     register (10H) at port 3D4H/3D5H selects 640-by-480 2-color and 320-
     by-200 256-color graphics modes (see Figure 2-12). An Extended Mode
     Control register is mapped to I/O port 3DDH. This register is used
     only during machine coldstart; it has no practical use in applications
     programs.


Bit         Settings
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           1 = select 320x200 256-color mode
            0 = (all other modes)
1           1 = select 640x480 2-color mode
            0 = (all other modes)
2           (reserved)
3           1 = horizontal timing parameters computed for video mode
            0 = horizontal timing parameters as specified in registers
                00-03H
4           1 = enable dot clock (should always be 1)
5           (reserved)
6           Inverse of bit 8 of Vertical Displayed register (06H)
7           1 = write-protect registers 00-07H
            0 = allow updating of registers 00-07H
     Figure 2-12.  Bit settings for the MCGA Memory Controller Mode Control
     register.


HGC

     The Hercules Graphics Card has two control registers whose contents
     affect the video mode configuration. The Mode Control register at 3B8H
     is functionally compatible with the MDA's Mode Control register, but
     it maps additional mode configuration functions to bits 1 and 7 (see
     Figure 2-13). Bit 1, when set to 1, establishes internal timings for
     a 720-by-348 graphics mode. Setting bit 7 to 1 while the adapter is in
     graphics mode displays the second half of the adapter's 64 KB video
     buffer at B800:0000. These bits have no function, however, unless the
     appropriate bits in the adapter's Configuration Switch register are
     set properly.

     The Configuration Switch register (3BFH) determines the function of
     the Mode Control register at 3B8H (see Figure 2-14). When bit 0 of
     the Configuration Switch register is 0, the HGC cannot be placed in
     its graphics mode, so bit 1 of the Mode Control register must also be
     0. Bit 1 of the Configuration Switch register controls video buffer
     addressing when the adapter is used in combination with a CGA or
     compatible (see below).


Bit         Settings
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           (unused)
1           1 = 720x348 graphics mode
            0 = 80x25 alphanumeric mode
2           (unused, should always = 0)
3           1 = video enabled
            0 = video disabled (screen blank)
4           (unused, should always = 0)
5           1 = blinking attribute enabled
            0 = blinking attribute disabled
6           (unused, should always = 0)
7           1 = graphics mode buffer displayed from B800:0000 (video
                page 1)
            0 = graphics mode buffer displayed from B000:0000 (video
                page 0)
     Figure 2-13.  Bit settings for the Hercules Mode Control register
     (3B8H). This register is the same on the HGC, HGC+, and InColor Card.


Bit         Settings
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           1 = allows graphics mode
            0 = prevents graphics mode
1           1 = enables upper 32 KB of graphics mode video buffer at
                B800:0000
            0 = disables upper 32 KB of graphics mode buffer
2-7         (unused)
     Figure 2-14.  Bit settings for the Hercules Configuration Switch
     register (3BFH). This register is the same on the HGC, HGC+, and
     InColor Card.


HGC+ and InColor Card

     The HGC+ and InColor Card implement an extended mode control register
     (called the xMode register) in addition to the Mode Control and
     Configuration Switch registers found on the HGC. The xMode register is
     a write-only register addressable as register 14H at port 3B4H/3B5H.
     (The register is addressed exactly as if it were a CRTC register.) The
     xMode register controls the alphanumeric character generator; Chapter
     10 explains this in detail.


EGA and VGA

     When you establish a video mode on the EGA and the VGA, you can
     control the internal timing and addressing of several different
     components of the video subsystem. These include the Sequencer, the
     Graphics Controller, and the Attribute Controller, each of which has
     several control registers. There is also a Miscellaneous Output
     register, which controls I/O port and video buffer addressing and
     selects the dot clock frequency.

       ÉÍÍÍ»     All Sequencer, Graphics Controller, and Attribute
       º T º     Controller registers on the EGA are write-only registers,
       º I º     but on the VGA they can be read as well as written.
       º P º
       ÈÍÍÍ¼


     Sequencer
     The Sequencer generates internal timings for video RAM addressing. It
     has five programmable data registers (see Figure 2-15) mapped to
     ports 3C4H and 3C5H in a manner analogous to CRTC register mapping.
     The Sequencer's Address register is located at 3C4H; its five data
     registers are selected by storing an index value between 0 and 4 in
     the Address register and then accessing the corresponding data
     register at 3C5H.


Register    Name
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           Reset
1           Clocking Mode
2           Map Mask

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
3           Character Map Select
4           Memory Mode
     Figure 2-15.  EGA and VGA Sequencer registers.


     Graphics Controller
     The Graphics Controller mediates data flow between the video buffer
     and the CPU, as well as from the video buffer to the Attribute
     Controller. The Graphics Controller has nine data registers, plus an
     Address register (see Figure 2-16). The Address register maps to
     port 3CEH, and the data registers map to port 3CFH.


Register    Name
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           Set/Reset
1           Enable Set/Reset
2           Color Compare
3           Data Rotate/Function Select
4           Read Map Select
5           Graphics Mode
6           Miscellaneous
7           Color Don't Care
8           Bit Mask
     Figure 2-16.  EGA and VGA Graphics Controller registers.


     Attribute Controller
     The Attribute Controller supports a 16-color palette on the EGA and
     VGA. It also controls the color displayed during overscan intervals.
     The Attribute Controller's Address register and 21 data registers all
     map to I/O port 3C0H (see Figure 2-17). A value written to port 3C0H
     will be stored in either the Address register or a data register,
     depending on the state of a flip-flop internal to the Attribute
     Controller.


Register(s) Function
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0-0FH       Palette
10H         Attribute Mode Control
11H         Overscan Color
12H         Color Plane Enable
13H         Horizontal Pixel Panning
14H         Color Select (VGA only)
     Figure 2-17.  EGA and VGA Attribute Controller registers.


     To set the flip-flop, perform an I/O read (IN AL,DX) of the CRT Status
     register (port 3BAH in monochrome modes, 3DAH in color modes). Listing
     2-3 illustrates how this is done in updating an Attribute Controller
     register. On the VGA, Attribute Controller data registers may be read
     as well as written. Do this by writing the register number to port
     3C0H and then reading the value from port 3C1H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 2-3.  Updating the EGA or VGA Attribute Controller

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     You can use 16-bit port writes (OUT DX,AX) to store data
       º T º     in EGA and VGA Sequencer and Graphics Controller
       º I º     registers. On the EGA, you can use the same technique to
       º P º     program the Attribute Controller, which recognizes I/O
       ÈÍÍÍ¼     port writes at 3C1H as well as 3C0H. However, the VGA
                 Attribute Controller does not emulate the EGA in this
                 regard, so this technique should be used carefully when
                 VGA compatibility is important.


Video BIOS Support

     The video BIOS supports a number of different video modes on IBM PC
     and PS/2 video subsystems (see Figure 2-18). The video BIOS routines,
     which can be called with INT 10H, let you establish a video mode
     simply by specifying its number.

     Not all of the BIOS video modes are available on all IBM PC video
     subsystems. Furthermore, the video BIOS does not support video mode
     configurations on non-IBM hardware unless it exactly emulates the
     corresponding IBM hardware.

     For example, all Hercules video adapters emulate IBM's MDA exactly.
     Thus, the video BIOS can be used to select the monochrome alphanumeric
     mode (BIOS mode 7) on all Hercules products. However, the Hercules
     hardware also supports a 720-by-348 graphics mode which is not
     recognized by IBM's video BIOS. Consequently, to set up the Hercules
     graphics mode, a program must configure the hardware directly (see
     Listing 2-4.)


Mode
Number                                            Mode      Buffer
(hex)  Resolution                        Colors   Type      Segment   MDA  CGA  EGA  MCGA  VGA
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0      40x25 chars (320x200 pixels) 1,2  16       Alpha     B800           x    x    x     x
0      40x25 chars (320x350 pixels) 2    16       Alpha     B800                x          x
0      40x25 chars (320x400 pixels)      16       Alpha     B800                     x
0      40x25 chars (360x400 pixels) 2    16       Alpha     B800                           x
1      40x25 chars (320x200 pixels) 2    16       Alpha     B800           x    x    x     x
1      40x25 chars (320x350 pixels) 2    16       Alpha     B800                x          x
1      40x25 chars (320x400 pixels)      16       Alpha     B800                     x
1      40x25 chars (360x400 pixels) 2    16       Alpha     B800                           x
2      80x25 chars (640x200 pixels) 1,2  16       Alpha     B800           x    x    x     x
2      80x25 chars (640x350 pixels) 2    16       Alpha     B800                x          x
2      80x25 chars (640x400 pixels)      16       Alpha     B800                     x
2      80x25 chars (720x400 pixels) 2    16       Alpha     B800                           x
3      80x25 chars (640x200 pixels) 2    16       Alpha     B800           x    x    x     x
3      80x25 chars (640x350 pixels) 2    16       Alpha     B800                x          x
3      80x25 chars (640x400 pixels)      16       Alpha     B800                     x
3      80x25 chars (720x400 pixels) 2    16       Alpha     B800                           x
4      320x200 pixels                     4       Graphics  B800           x    x    x     x
5      320x200 pixels 3                   4       Graphics  B800           x    x    x     x
6      640x200 pixels                     2       Graphics  B800           x    x    x     x
7      80x25 chars (720x350 pixels) 2     2       Alpha     B000      x         x          x
7      80x25 chars (720x400 pixels) 2     2       Alpha     B000                           x
8      (PCjr only)
9      (PCjr only)
0A     (PCjr only)
0B     (used by EGA video BIOS)
0C     (used by EGA video BIOS)
0D     320x200 pixels                    16       Graphics  A000           x         x
0E     640x200 pixels                    16       Graphics  A000           x         x
0F     640x350 pixels                     2       Graphics  A000           x         x
10     640x350 pixels 4                   4       Graphics  A000           x
10     640x350 pixels                    16       Graphics  A000           x         x
11     640x480 pixels                     2       Graphics  A000                x    x
12     640x480 pixels                    16       Graphics  A000                     x
13     320x200 pixels                   256       Graphics  A000                x    x
     Figure 2-18.  ROM BIOS video modes


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 2-4.  Configuring a Hercules adapter for 720-by-348 graphics
     mode

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Combinations of Video Subsystems


     IBM designed the original MDA and CGA such that both adapters can be
     used in the same PC. This is possible because the CRTC registers and
     other control and status registers are assigned to a different range
     of I/O ports on the MDA than on the CGA. The MDA's port addresses
     range from 3B0H through 3BFH, while the CGA's range from 3D0H through
     3DFH. Also, the video buffers on the MDA and the CGA occupy different
     portions of the 80x86 address space: The MDA's 4 KB video buffer is at
     B000:0000, while the CGA's 16 KB buffer starts at B800:0000.

     This separation was carried forward in the design of the EGA. The
     EGA's I/O port and video buffer addressing are programmable. When the
     EGA is attached to a monochrome monitor, the MDA-compatible addresses
     are used. When the EGA is used with a color monitor, the CGA-
     compatible addresses are used. Thus, an EGA can coexist with either an
     MDA or a CGA.

     Figure 2-19 shows which PC and PS/2 video subsystems can coexist in
     the same computer. The table reflects the dichotomy between MDA-
     compatible and CGA-compatible I/O port and video buffer addressing. As
     a rule of thumb, you can usually combine one MDA-compatible adapter
     and one CGA-compatible adapter in the same system.

     NOTE: The Hercules InColor Card should be regarded as an MDA-
     compatible adapter, even though it is ostensibly a color card. In
     fact, if you use the InColor Card in a PS/2 Model 30 with a monochrome
     monitor attached to the Model 30's MCGA, you end up with the strange
     combination of an MDA-compatible color subsystem and a CGA-compatible
     monochrome subsystem in the same computer.

     The BIOS video mode routines generally support dual-display
     configurations. The video BIOS routines use bits 4 and 5 of the
     variable EQUIP_FLAG at 0040:0010 in the BIOS video data area to choose
     between two video subsystems. If there are addressing conflicts
     between two subsystems, the BIOS in the MCGA and VGA provides a
     "display switch" interface that lets you independently disable and
     enable each subsystem (see Appendix A).


              MDA   CGA   EGA   MCGA   VGA Adapter   HGC   HGC+   InColor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
MDA                 x     x     x      x
CGA           x           x                          x     x      x
EGA           x     x                                x     x      x
MCGA          x                        x             x     x      x
VGA Adapter   x                 x                    x     x      x
HGC                 x     x     x      x

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
HGC+                x     x     x      x
InColor             x     x     x      x
     Figure 2-19.  Allowable combinations of IBM PC and PS/2 video
     subsystems.


     With some combinations of video adapters, the address space the two
     subsystems' video buffers occupy may overlap even if their I/O port
     address assignments do not. In this situation you must selectively
     exclude part or all of one subsystem's video buffer from the CPU
     memory map so that the CPU can access the other subsystem's buffer
     without addressing conflicts. The technique for doing this varies with
     the hardware.


MDA

     The MDA's video buffer is mapped to the addresses between B000:0000
     and B000:FFFF. The same buffer is also mapped to the 4 KB blocks of
     RAM starting at segments B100H, B200H, and so on through B700H,
     although there is no real reason for software to use these alternate
     address maps. The MDA's video buffer address mapping cannot be
     disabled.


Hercules

     On the HGC, the HGC+, and the InColor Card, the video buffer occupies
     the 64 KB of RAM starting at B000:0000. The second 32 KB of the video
     buffer overlaps the address space of a CGA's video buffer (starting at
     B800:0000). For this reason these Hercules adapters are designed so
     that the second 32 KB can be selectively excluded from the CPU memory
     map. The extent of the video buffer address space depends upon the
     value you store in the Configuration Switch register (3BFH). When bit
     1 of this register is 0 (the power-on default), video RAM occupies
     addresses from B000:0000 through B000:7FFF, which excludes the second
     32 KB portion from the CPU memory map and allows the card to be used
     with a CGA. To make the second half of the video buffer addressable,
     set bit 1 to 1.


CGA

     The CGA's video buffer maps to the addresses between B800:0000 and
     B800:3FFF. The same buffer is also mapped between BC00:0000 and
     BC00:3FFF, although few programs use this alternate address map. As
     with the MDA, the CGA's video buffer mapping cannot be altered.

     This is not the case, however, for all CGA clones. The Hercules Color
     Card (not to be confused with the InColor Card) is a CGA work-alike
     whose video buffer can be excluded from the CPU's address space. This
     is achieved by setting bit 1 of the card's Configuration Switch
     register (3BFH) to 1. This register maps to the same I/O port as the
     equivalent register on an HGC, HGC+, or InColor Card, but the polarity
     of the control bit is opposite that on the other Hercules cards. Thus,
     by toggling this bit, software can address the video buffers on both a
     Hercules Color Card and another Hercules adapter without addressing
     conflicts.


EGA

     The EGA's video buffer can be mapped to any of four locations,
     depending on the values of bits 2 and 3 in the Graphics Controller
     Miscellaneous register (see Figure 2-20). The default values for
     these bits depend on the video mode. When the video BIOS sets up a
     video mode, it sets these bits to appropriate values.


Bit 3       Bit 2       Video Buffer Address Range
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           0           A000:0000-B000:FFFF
0           1           A000:0000-A000:FFFF
1           0           B000:0000-B000:7FFF
1           1           B800:0000-B800:7FFF
     Figure 2-20.  Control of EGA and VGA video buffer addressing with the
     Graphics Controller Miscellaneous register.


     The EGA also provides another level of control over the video buffer
     address map. When set to 0, bit 1 of the EGA's Miscellaneous Output
     register (3C2H) excludes the entire video buffer from the CPU memory
     address space.


MCGA

     The MCGA's 64 KB video buffer occupies the addresses between A000:0000
     and A000:FFFF, but the second 32 KB of the buffer, starting at
     A000:8000 (A800:0000), also maps to the CGA video buffer address range
     (B800:0000 through B800:7FFF). CPU addressing of the MCGA's video
     buffer and I/O ports can be disabled by setting bit 2 of the system
     board control port at 65H to 0. Listing 2-5 shows how INT 10H function
     12H can be called to set or reset this bit.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 2-5.  Enable or disable video I/O port and buffer addressing
     on an MCGA or VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


VGA

     Control over the VGA's video buffer address map is the same as on the
     EGA. However, there are two different methods of disabling CPU
     addressing of the video subsystem, depending on whether you are using
     an integrated VGA (in a PS/2 Model 50, 60, or 80) or the VGA Adapter.
     In the integrated subsystem, the Video Subsystem Enable Register
     (3C3H) controls both video buffer addressing and I/O port addressing;
     setting bit 0 of this register to 0 disables addressing, and setting
     bit 0 to 1 enables addressing.

     On the VGA Adapter, the Video Subsystem Enable register does not
     exist. Instead, bit 3 of the control register at I/O port 46E8H
     enables and disables addressing: Writing a default value of 0EH to
     this port enables addressing; writing a value of 6 disables
     addressing.

     In all VGA subsystems, however, INT 10H function 12H provides the same
     interface as it does on the MCGA (see Listing 2-5). Because of the
     hardware differences between the MCGA, the integrated VGA and the VGA
     Adapter, it is easier to use INT 10H function 12H to enable or disable
     addressing in the PS/2 video subsystems (see Listing 2-5).



                         3  Alphanumeric Modes


                        Using Alphanumeric Modes
                    BIOS and Operating-System Support
                          Speed ş Compatibility

                   Representation of Alphanumeric Data

                               Attributes
                          MDA ş HGC ş CGA ş EGA
                        InColor Card ş MCGA ş VGA

                           Gray-Scale Summing

                              Border Color
                            CGA ş EGA and VGA

                            Avoiding CGA Snow
                          Blanking the Display
                  Using the Vertical Blanking Interval
                 Using the Horizontal Blanking Interval

                       Using All the Video Buffer
                             CGA Video Pages
                     EGA, MCGA, and VGA Video Pages

                             Cursor Control
                     Cursor Size on the MDA and CGA
                   Cursor Location on the MDA and CGA
            MCGA Cursor Control ş EGA and VGA Cursor Control
                        ROM BIOS Cursor Emulation
                           An Invisible Cursor



     All IBM PC and PS/2 video subsystems except the MDA can be programmed
     to display characters in either alphanumeric or graphics modes. This
     chapter discusses what you need to know to use alphanumeric modes--the
     advantages and disadvantages of programming in alphanumeric modes; the
     basics of colors, blinking, and other character display attributes;
     and special techniques that exploit the capabilities of the hardware
     to improve the on-screen appearance and performance of your programs.


Using Alphanumeric Modes


     The video BIOS on all IBM PCs and PS/2s always selects an alphanumeric
     video display mode when you boot the computer. In the IBM PC family,
     switches on the motherboard, the video adapter, or both determine
     whether a 40-column or 80-column mode is selected and whether a color
     or monochrome display is used. In the PS/2 series, the initial video
     mode is always an 80-column alphanumeric mode. Furthermore, the video
     mode set by the ROM BIOS is the one the operating system initially
     uses. Until you run a program that changes the video mode, all video
     output appears in the default mode--which is alphanumeric.

     For this reason, the simplest way to write a program is to assume that
     it runs in an alphanumeric mode and to program the video interface
     accordingly. This assumption minimizes the coding required to send
     output to the screen. Not only are alphanumeric video output routines
     simpler than equivalent routines for graphics modes, but in most cases
     the ROM BIOS or the operating system provides character output
     routines that can be used in any alphanumeric mode.


BIOS and Operating-System Support

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     In the IBM PC, operating-system output routines are usually based on
     the set of primitive routines in the ROM BIOS that are called with
     software interrupt 10H. You can send characters to the video display
     either by using operating-system calls or by calling the INT 10H
     routines directly. In either case, use of these routines obviates the
     need for writing your own character output routines.

     An additional advantage to using BIOS or operating-system character
     output functions is that programs using only such functions are more
     likely to run on different video hardware. For example, a program
     using only MS-DOS function calls for video output will run in almost
     any MS-DOS environment, regardless of the video hardware, including
     (but not limited to) the entire IBM PC and PS/2 family.

     Of course, routing video output through an operating system is
     relatively slow compared with writing directly to the hardware. The
     use of operating-system character output routines introduces a certain
     amount of unavoidable overhead,particularly when such features as
     input/output redirection and multiprocessing are supported. Never-
     theless, this overhead may be acceptable in many applications. You
     should always consider whether the extra programming and decreased
     portability required to improve video output performance are
     worthwhile in your application.


Speed

     This is not to say that alphanumeric video output is inherently slow.
     When compared with character output in graphics modes, alphanumeric
     output is significantly faster, simply because much less data must be
     stored in the video buffer to display characters. In alphanumeric
     modes, each character is represented by a single 16-bit word; the
     video hardware takes care of displaying the pixels that make up the
     character. In graphics modes, every pixel in every character is
     represented explicitly in a bit field in the video buffer. For this
     reason, graphics-mode output is much more costly than equivalent
     character output in alphanumeric modes, both in terms of display
     memory used and processing required.

     For example, in a 16-color graphics mode, each character drawn on the
     screen in an 8-by-8 dot matrix is represented by 32 bytes of data in
     the video buffer (8 * 8 * 4 bits per pixel). The memory overhead
     increases rapidly, in direct relationship to increasing resolution and
     the addition of more colors, as does the amount of time the CPU spends
     in manipulating data in the video buffer. On newer video adapters,
     dedicated graphics coprocessors such as the Intel 82786 or the TI
     34010 may assume much of the computational burden of graphics-mode
     text display, thereby improving the speed of graphics-mode text
     output. Without a coprocessor, however, output in graphics modes is
     much slower than in alphanumeric modes.


Compatibility

     Writing a program that is compatible with different IBM video
     subsystems is easier if you use only alphanumeric video display modes.
     The reason is simple: All commonly used IBM video subsystems support
     an 80-column by 25-row alphanumeric mode with the same video buffer
     format. If you design your video interface with an 80-by-25
     alphanumeric display in mind, your program will run on a majority of
     PCs and compatibles with little or no modification.

     Unfortunately, high compatibility is generally achieved only by
     sacrificing speed. Fast video output routines usually take advantage
     of hardware idiosyncrasies, so they are less likely to be portable to
     different video hardware than routines that rely on slower but more
     universal BIOS or operating-system calls. This trade-off will be
     implicit in almost every video output routine you write.


Representation of Alphanumeric Data


     All IBM PC and PS/2 video subsystems use the same format for storing
     alphanumeric data in the video buffer. Each character is represented
     by a simple 2-byte data structure (see Figure 3-1). Characters are
     stored in the buffer in a linear sequence that maps across and down
     the screen (see Figure 3-2).


        Low-order byte      High-order byte
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³  ASCII character  ³     Attribute     ³
     ³        code       ³                   ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 3-1.  Alphanumeric character and attribute mapping in a 16-bit
     word.


                                                      Display
               Video buffer                          ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ
     0000H ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                     ³°°°°°°°°°
           ³                   ÃÄÄÄ Character row O ³ÛÛÛÛÛÛÛÛÛ
     00A0H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                     ³°°°°°°°°°
           ³                   ÃÄÄÄ Character row 1 ³ÛÛÛÛÛÛÛÛÛ
     0140H ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´                     ³°°°°°°°°°
           ³                   ÃÄÄÄ Character row 2 ³ÛÛÛÛÛÛÛÛÛ
     01E0H ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ                     ³°°°°°°°°°
           ³                   ³                     ³°°°°°°°°°
            Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä                      ³°°°°°°°°°
           ³                   ³                     ³°°°°°°°°°
            Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä                      ³°°°°°°°°°
           ³                   ³                     ³°°°°°°°°°
           À Ä Ä Ä Ä Ä Ä Ä Ä Ä Ù                     ³

     Figure 3-2.  Video buffer map in 80-by-25 alphanumeric modes.


     A hardware character generator converts each character code into the
     proper dot pattern on the display. At the same time, attribute decoder
     circuitry generates the appropriate attribute--color, intensity
     (brightness), blinking, and so on--for each character. Since each
     character code in the video buffer is accompanied by an attribute
     byte, you can independently control the displayed attributes of each
     character on the screen.

     The hardware character generator displays each alphanumeric character
     within a rectangular matrix of pixels. Within this character matrix,
     the character itself is composed of a set of foreground pixels. The
     colors of the character's foreground and background pixels are
     specified by the low and high nibbles of the corresponding attribute
     byte.

     To display a character, you store its ASCII code and attribute in the
     proper location in the video buffer. Because of the linear mapping
     scheme, you can easily calculate the buffer address of a particular
     screen location. The general formula is

     offset = ((row * width) + column) * 2

     In this formula, width is the number of characters in each row. The
     factor of 2 is included because each character requires 2 bytes (one
     16-bit word) of storage in the video buffer. The values for row and
     column are zero-based, starting in the upper left corner of the
     screen. (The character in the upper left corner is located at row 0,
     column 0.)

     If you examine the contents of the video buffer, you can see how this
     data corresponds to characters on the screen (see Figure 3-3). Note
     how each character code is followed by its attribute byte. (All of the
     attribute bytes in the portion of the video buffer shown in Figure 3-3
     have the value 07H.)


           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF
B000:0000  43 07 68 07 61 07 72 07 61 07 63 07 74 07 65 07 C.h.a.r.a.c.t.e.
B000:0010  72 07 20 07 72 07 6F 07 77 07 20 07 30 07 30 07 r. .r.o.w. .0.0.
B000:0020  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0030  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0040  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0050  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0060  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0070  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0080  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0090  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:00A0  43 07 68 07 61 07 72 07 61 07 63 07 74 07 65 07 C.h.a.r.a.c.t.e.
B000:00B0  72 07 20 07 72 07 6F 07 77 07 20 07 30 07 31 07 r. .r.o.w. .0.1.
B000:00C0  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:00D0  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:00E0  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:00F0  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0100  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0110  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0120  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................
B000:0130  00 07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 ................

     Figure 3-3.  Hexadecimal dump of an alphanumeric video buffer.


Attributes


     Although all IBM PC and PS/2 video subsystems use the same pattern 
     of alternating character codes and attribute bytes to represent
     alphanumeric data, the way the attribute byte is interpreted varies.
     In general, the attribute byte is formatted as two 4-bit nibbles.
     The low-order nibble (bits 0 through 3) determines the character's
     foreground attribute; that is, the color and intensity of the
     character itself. The high-order nibble (bits 4 through 7) indicates
     the character's background attribute, although bit 7 may also control
     blinking in some situations.

     The 4-bit foreground and background attributes are ultimately decoded
     into a set of signals that drive the video monitor. In the simplest
     case, on the CGA, the four bits correspond directly to the three color
     signals and the intensity signal. The decoding scheme on other video
     subsystems can be complex, as on the EGA, MCGA, VGA, and InColor Card,
     or comparatively simple, as on the MDA.


MDA

     Although you may specify any of 16 (2^4) attributes for both
     foreground and background attributes, the MDA only recognizes certain
     combinations (see Figure 3-4). Nevertheless, you can generate a
     useful variety of character attributes by creatively combining
     intensity, blinking, and underlining. You can also exchange the usual
     foreground and background attributes to obtain "reverse video"--black

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     characters on a normal-intensity background.


                           Not Underlined
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                              Foreground
               Black     Dim1    Normal Intensity    High Intensity
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Background 
Black          00        2        07                  0F
Dim1          2        88        87                  8F
Normal         70        78        2                  2
High           F0        F8        2                  2

                             Underlined
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
                             Foreground
               Normal Intensity       High Intensity
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Background
Black          01                     09 
Dim1          81                     89 

     Figure 3-4.  MDA foreground-background attribute combinations (values
     in hex). Attribute values not in this table always map to one of the
     combinations shown.


     On the MDA, as well as on all other IBM video hardware, bit 7 of each
     character's attribute byte can serve two purposes. By default, this
     bit controls whether a character blinks when displayed; setting the
     bit to 1 causes the associated character to blink. Bit 7 controls
     blinking because bit 5 (the Enable Blink bit) of the MDA's CRT Mode
     Control register (3B8H) is set to 1 by the video BIOS when the
     computer is powered up.

     If the Enable Blink bit is 0, however, bit 7 of the attribute byte no
     longer controls blinking (see Listing 3-1). Instead, bit 7 is
     interpreted as an intensity bit for the background attribute. When bit
     7 is set in a character's attribute byte, the character's background
     attribute is intensified; that is, normal green becomes intense green
     and black becomes dim green. Thus, to obtain all possible combinations
     of monochrome attributes listed in Figure 3-4, you must zero the
     Enable Blink bit.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-1.  Resetting the Enable Blink bit on the MDA or CGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The value of the Mode Control register's Enable Blink bit affects the
     interpretation of bit 7 of all attribute bytes, so you can't display
     both blinking characters and characters with intensified background at
     the same time. You must decide which attribute is more useful in your
     program and set the Enable Blink bit accordingly.

     All IBM PC and PS/2 video subsystems, including the MDA, blink
     alphanumeric characters by substituting the background attribute for
     the foreground attribute about twice a second. The effect is that each
     blinking character alternates with a blank character.

     If you fill the display with blinking characters, the overall effect
     can be disconcerting, because the screen is blanked and restored twice
     each second. But if your purpose is to attract attention to the
     display, using the blink attribute can be very effective.

       ÉÍÍÍ»     If you use the underline attribute (foreground attribute 1
       º T º     or 9) on a Compaq portable, you won't see underlined
       º I º     characters. This is because the Compaq portable decodes
       º P º     attribute values into 16 progressively brighter shades
       ÈÍÍÍ¼     of green; the underline attribute values of 1 and 9
                 therefore appear as shades of green.

       ÉÍÍÍ»     Surprisingly, a few IBM MDAs generate color as well as
       º T º     monochrome output. Of course, the MDA's green monochrome
       º I º     display uses only two signals to control attributes (video
       º P º     on/off and intensity on/off); it ignores any color video
       ÈÍÍÍ¼     signals. However, a color display that can use the MDA's
                 16.257 MHz horizontal sync and 50 Hz vertical sync signals
                 will display eight colors (with and without intensity)
                 when attached to some (but not all) MDAs. Unfortunately,
                 you can never be certain which MDA will turn out to be a
                 color adapter in disguise.


HGC

     The HGC and HGC+ exactly emulate the MDA's monochrome alphanumeric
     mode. Programs written for the MDA run unchanged on either of these
     adapters.


CGA

     The CGA uses the same foreground-background attribute scheme as does
     the MDA. However, the CGA's attribute decoder circuitry recognizes all
     16 possible combinations of the four bits in each nibble of the
     attribute byte. For each character on the screen, you can
     independently specify any of 16 colors for foreground and background.

     The available colors are simple combinations of the primary colors
     red, green, and blue. Each bit in each nibble of the attribute byte
     corresponds to a signal that the CGA supplies to the video monitor
     (see Figure 3-5). The low-order three bits of each nibble correspond
     to the red (R), green (G), and blue (B) signals. The eight possible
     combinations produce a gamut of red, green, blue, and their
     intermediate colors (see Figure 3-6).


     Bit   3     2     1     0
        ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
        ³  I  ³  R  ³  G  ³  B  ³
        ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
           ³     ³     ³     ³
           ³     ³     ³     ³
           ³     ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄPin 5
           ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 4
           ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 3
           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 6

     Figure 3-5.  CGA attributes and monitor color drive signals. Pin
     numbers refer to the CGA's 9-pin connector.


Color               Binary (IRGB)  Hexadecimal
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Black               0000           00
Blue                0001           01
Green               0010           02
Cyan                0011           03
Red                 0100           04
Violet              0101           05
Yellow (brown)      0110           06
White               0111           07
Black (gray)        1000           08
Intense blue        1001           09
Intense green       1010           0A
Intense cyan        1011           0B
Intense red         1100           0C
Intense violet      1101           0D
Intense yellow      1110           0E
Intense white       1111           0F
     Figure 3-6.  CGA display attributes.


     Setting bit 3 of the attribute byte (the intensity bit in the
     foreground nibble) displays the color designated in the R, G, and B
     bits (bits 0 through 2) with higher intensity. However, as on the MDA,
     the high-order bit (bit 7) of each attribute byte controls either
     background intensity or blinking. Again, the attribute displayed
     depends upon the state of a bit in a control register.

     Bit 5 of the CGA's Mode Control register (I/O port 3D8H) is an Enable
     Blink bit analogous to bit 5 of the MDA's CRT Control register. When
     you set the Enable Blink bit to 0, bit 7 of a character's attribute
     byte signifies that the background color specified in bits 4 through
     6 should be intensified. When you set the Enable Blink bit to 1, only
     nonintensified background colors are displayed, but characters whose
     attribute bytes have bit 7 set to 1 will blink.

     The Enable Blink bit is set to 1 whenever you call the ROM BIOS to
     select an alphanumeric video mode. By default, therefore, bit 7 of
     each character's attribute byte controls blinking rather than
     background intensity. You must reset the Enable Blink bit to display
     characters with intensified background colors.

     Many CGA-compatible displays squeeze a bit more out of the 16
     available colors (8 nonintensified, 8 intensified) by displaying low-
     intensity yellow as brown and high-intensity black as gray.
     Unfortunately, a program cannot determine whether a particular display
     can do this. Be careful about displaying, for example, gray characters
     on a black background with a CGA, because such color combinations are
     invisible on some color displays.


EGA

     In 16-color alphanumeric modes, the EGA uses the same attribute byte
     format as the CGA. However, the 4-bit foreground and background values
     do not correspond directly to the colors displayed. Instead, each 4-
     bit value is masked with the four low-order bits of the Attribute
     Controller's Color Plane Enable register (12H); the resulting 4-bit
     value designates one of the EGA's 16 palette registers (see Figure 3-
     7). Each bit of the 6-bit color value contained in the designated
     palette register corresponds to one of the six RGB signals that drive
     the monitor (see Figure 3-8).

     An EGA-compatible color monitor is driven by six color signals--three
     primary (higher intensity) and three secondary (lower intensity). All
     64 combinations of these six signals appear as different colors and/or
     intensities. With a 200-line color monitor--or in 200-line modes on an
     EGA-compatible monitor--bits 0, 1, and 2 control the color signals,
     while bit 4 controls the intensity signal.



Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³                 ³    Logical AND    ³   Color Plane    ³
     ³ 4-bit attribute ÃÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄ´ Enable register  ³
     ³                 ³         ³         ³                  ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ³         ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                 ³
                     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                     ³Palette register 0-0FH ³
                     ÀÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ
                                 ³
                                 
               6-bit digital output to video display
                (2-bits each for red, green, blue)

     Figure 3-7.  Attributes and colors on the EGA.


     200-line monitors (CGA-compatible):

     Bit   7     6     5     4     3     2     1     0
        ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
        ³     ³     ³     ³  I  ³     ³  R  ³  G  ³  B  ³ Palette register
        ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÂÄÄÁÄÄÄÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
                             ³           ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄPin 5
                             ³           ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 4
                             ³           ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 3
                             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 6

     350-line color monitors (EGA-compatible):

     Bit   7     6     5     4     3     2     1     0
        ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
        ³     ³     ³  r  ³  g  ³  b  ³  R  ³  G  ³  B  ³ Palette register
        ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
                       ³     ³     ³     ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄPin 5
                       ³     ³     ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 4
                       ³     ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 3
                       ³     ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 7
                       ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 6
                       ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 2

     350-line monochrome monitors (MDA-compatible)

     Bit   7     6     5     4     3    2     1     0
        ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
        ³     ³     ³     ³  I  ³  V  ³     ³     ³     ³ Palette register
        ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÙ
                             ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 7
                             ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 6

     R,G,B = primary red, green, blue (higher intensity)
     r,g,b = secondary red, green, blue (lower intensity)
     I = intensity
     V = monochrome video

     Figure 3-8.  EGA palette register values and corresponding monitor
     color drive signals. Pin numbers refer to the EGA's 9-pin connector.


     The EGA's method of generating colors indirectly through palette
     registers is more complex than the CGA's direct scheme, but the EGA is
     more flexible. You can select the foreground and background colors for
     each character individually, yet you can produce global color changes
     by updating the value in a particular palette register.

     The high-order bit of each character's attribute byte can control
     either blinking or background intensity, just as on the MDA and the
     CGA. Bit 3 of the EGA's Attribute Controller Mode Control register
     (register 10H at I/O port 3C0H) is the Enable Blink bit. Setting it to
     1 enables blinking, so only the low-order 3 bits of the background
     nibble (bits 4 through 6 of the attribute byte) designate palette
     registers. Thus, when blinking is enabled, you can reference only
     the first eight palette registers to select the background color for
     a character. Setting the Enable Blink bit to 0 disables blinking,
     making all 16 palette registers available for background colors
     (see Listing 3-2).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-2.  Setting and resetting the Enable Blink bit on the MCGA,
     EGA, or VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     When you select an alphanumeric video mode using the EGA BIOS, the
     palette registers are loaded with default values that correspond to
     the colors available on the CGA. The color values in the second eight
     palette registers are intensified versions of those in the first
     eight. Thus, if you simply treat bit 7 of the attribute byte as a
     "background intensity or blink" bit, your program will run on both an
     EGA and a CGA.

     You can update the contents of any palette register either directly or
     with INT 10H function 10H (see Listing 3-3). Using the BIOS routine
     is more convenient and avoids the need to write hardware-dependent
     code. Moreover, the BIOS routine can also load all 16 palette
     registers at once, given a table of color values (see Appendix A).
     Nevertheless, you may still need to program the palette registers
     directly to produce very rapid color changes such as might be required
     in some types of animation.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-3.  Palette register programming on the EGA or VGA.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In monochrome alphanumeric mode, the EGA emulates the MDA monochrome
     display attributes. The video BIOS initializes the palette registers
     with values that correspond to MDA attributes (see Figure 3-9). Bit 3
     determines whether pixels are on or off, and bit 4 (if set in addition
     to bit 3) causes a higher-intensity display. The underline attribute
     is generated whenever a character's foreground attribute is 1 or 9,
     regardless of the value in the corresponding palette register.


Value       Attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0           Black
8           Normal intensity
10H         Dim
18H         High intensity
     Figure 3-9.  Monochrome alphanumeric attribute values for the EGA
     palette registers.


       ÉÍÍÍ»     The EGA also generates an underline attribute in 16-color
       º T º     alphanumeric modes when the foreground attribute is 1 or 9
       º I º     and the background attribute is 0 or 8. However, you do
       º P º     not normally see an underline in 16-color modes because
       ÈÍÍÍ¼     the video BIOS default value for the CRTC Underline
                 Location register (14H) is 1FH. This value is greater than
                 the number of scan lines normally displayed for
                 alphanumeric characters, so the underline does not appear.

                 You can generate underlined characters in 16-color modes
                 by storing a displayable value in the Underline Location
                 register. Of course, only characters with attributes of 1,
                 9, 81H, or 89H will appear underlined, but you can change
                 the values in the corresponding palette registers to
                 produce underlined characters of any desired color.


InColor Card

     The InColor Card can decode alphanumeric attributes in several
     different ways. The card has a set of 16 palette registers whose
     function is analogous to the EGA's Attribute Controller palette
     registers, but the InColor Card can be configured by your program to
     bypass the palette registers and decode each character's 4-bit
     foreground and background attributes in an MDA- or CGA-compatible
     manner. Bits 4 and 5 of the Exception register (17H) control how the
     InColor Card interprets alphanumeric attributes (see Figure 3-10).
     Bit 5 determines whether the InColor Card displays monochrome
     attributes (as on the MDA) or color attributes (as on the CGA or EGA).
     Bit 4 enables attribute mapping through the palette registers.

     When the InColor Card is powered up, Exception register bit 5 has the
     value 1 and bit 4 has the value 0. Thus, by default, the card
     interprets attributes as an MDA would. However, if you set both bits 5
     and 4 to 0 (see Listing 3-4), alphanumeric attributes specify the
     same set of 16 colors as on a CGA (refer to Figure 3-6).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-4.  InColor Exception register programming.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Bit 5     Bit 4     Attribute Emulation
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0         0         CGA
0         1         EGA
1         0         MDA
1         1         MDA mapped through palette registers.
     Figure 3-10.  Exception register control of attributes on the Hercules
     InColor Card.


     Setting bit 4 to 1 causes attributes to map to the card's palette
     registers, regardless of the value of bit 5. Thus, if bit 4 is 1 and
     bit 5 is 0, the InColor Card interprets attributes as does the EGA. If
     bit 4 is 1 and bit 5 is 1, however, the card maps each character's
     foreground and background attributes only to the palette registers
     that correspond to valid monochrome attribute values. In this case,
     the "black," "dim," "normal intensity," and "high intensity"
     attributes select palette registers 00H, 08H, 07H, and 0FH
     respectively.

     Bit 5 of the CRT Mode Control register at 3B8H is the Enable Blink

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     bit. This bit controls background intensity regardless of the values
     of Exception register bits 4 and 5. However, characters are blinked
     only when Exception register bit 5 is 1 (MDA-compatible attributes);
     characters do not blink when bit 5 of the Exception register is 0
     (CGA-compatible attributes), regardless of the Enable Blink bit's
     setting.

     No video BIOS support is provided for the InColor Card's palette
     registers. Your program must therefore update the palette by directly
     storing values in the palette registers. Listing 3-5 is an example of
     how you might do this. The initial I/O read (IN AL,DX) of the palette
     register (1CH) resets an internal index which points to the first of
     the 16 internal palette registers. Each subsequent I/O write
     (OUT DX,AL) updates one internal palette register and increments the
     internal index to point to the next palette register, so all 16
     registers can be loaded by executing a simple loop.

       ÉÍÍÍ»     Because monochrome attributes can be mapped through
       º T º     palette registers, you can assign as many as four
       º I º     different colors to monochrome programs that run on the
       º P º     InColor Card. Do this by setting Exception register bits 4
       ÈÍÍÍ¼     and 5 to 1 and updating palette registers 00H, 08H, 07H,
                 and 0FH with the desired colors.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-5.  InColorpalette register programming.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     On the InColor Card, the colors of both the cursor and the underscore
     are independent of the foreground colors of the characters in the
     video buffer. The cursor color is specified in bits 0 through 3 of the
     Exception register, and the underscore color value is specified in
     bits 4 through 7 of the Underscore register (CRTC register 15H). When
     the InColor Card is displaying MDA attributes (that is, when bit 5 of
     the Exception register is set to 1), you can specify only the three
     low-order bits of the cursor and underscore colors; the high-order bit
     of these color values is derived from the foreground attribute of the
     character where the cursor or underscore is displayed.

     When palette mapping is enabled (Exception register bit 4 is set to
     1), both the cursor and underscore color values select palette
     registers. When palette mapping is disabled, the cursor and underscore
     color values are displayed using the usual CGA colors. Also, if you
     specify a value of 0 for either the underscore color or the cursor
     color, the InColor Card uses the value 7 instead.


MCGA

     The components of the PS/2 Model 30's video subsystem that transform
     attribute data into color video signals are the Video Formatter and
     the video Digital-to- Analog Converter (DAC). The Video Formatter gate
     array decodes attributes and generates an 8-bit digital output which
     is passed to the video DAC; from this, the DAC generates analog red,
     green, and blue signals for the video display. The DAC converts the 8-
     bit output from the Video Formatter to the three analog color signals
     by using the 8 bits to select one of the DAC's 256 color registers.
     Each DAC color register is 18 bits wide, comprising three 6-bit values
     for red, green, and blue (see Figure 3-12). The DAC converts each
     6-bit value into an analog signal with the highest value (3FH)
     corresponding to the highest-intensity signal.

     In alphanumeric modes, the four low-order bits of the Video
     Formatter's 8-bit digital output are derived from attribute bytes,
     while the four high-order bits are always 0 (see Figure 3-11). Thus,
     only the first 16 of the video DAC's color registers are used in MCGA
     alphanumeric modes. The remaining 240 registers can be accessed only
     in 320-by-200 256-color graphics mode (see Chapter 4). When an MCGA
     is attached to a color display, the video BIOS initializes the first
     16 video DAC color registers with the same colors found on the CGA.

       ÉÍÍÍ»     The value in the video DAC Mask register (I/O port 3C6H)
       º T º     masks the 8-bit value passed to the video DAC. The Mask
       º I º     register value is set to 0FFH by the video BIOS
       º P º     initialization routines so that all 256 video DAC color
       ÈÍÍÍ¼     registers can be accessed. IBM technical documentation
                 recommends that this value not be modified.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³   4-bit attribute    ³   Logical AND    ³  Video DAC Mask register ³
     ³                      ÃÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ´                          ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ³        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                      
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³        Video DAC         ³
                        ³   color register 0-0FH   ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                      ³
                                      
                    18-bit analog output to video display
                     (6 bits each for red, green, blue)

     Figure 3-11.  Attributes and colors on the MCGA. (The value in the
     video DAC Mask register should normally be 0FFH.)


           6 bits           6 bits          6 bits
     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³      Red       ³      Green     ³      Blue      ³
     ÀÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÙ
              ³                ³                ÀÄÄÄÄÄÄÄÄÄÄPin 3
              ³                ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 2
              ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄPin 1

     Figure 3-12.  Video DAC color register values and monitor color drive
     signals. Pin numbers refer to the MCGA's 15-pin connector.


     Unlike the EGA, an MCGA with a monochrome display does not emulate the
     MDA's attributes. Instead, the 16 default video DAC color register
     values consist of four groups of four shades of gray. Each group is
     displayed with higher intensity than the preceding group. Within each
     group, the intensity increases from lower to higher attribute values.
     Thus, attribute values 0 through 3 make up a range of four shades of
     gray, values 4 through 7 a second range of somewhat higher intensity,
     and values 8 through 0BH and 0CH through 0FH a third and fourth range
     of still higher intensity.

       ÉÍÍÍ»     Instead of this default MCGA monochrome gray-scale
       º T º     configuration, you might prefer to use gray-scale values
       º I º     that increase uniformly with increasing attribute values.
       º P º     The code in Listing 3-6 loads the video DAC registers
       ÈÍÍÍ¼     with appropriate values for this gray-scale gamut.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-6.  Loading an alternative MCGA monochrome gray-scale
     palette.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


VGA

     In general, the VGA exactly emulates EGA alphanumeric attribute
     decoding. However, the VGA has both a video DAC and a set of 16
     Attribute Controller palette registers. Each palette register value
     selects one of 256 video DAC color registers. The value in the
     selected video DAC color register determines the color displayed.

     Depending on the value of bit 7 in the Attribute Controller's Mode
     Control register, you can use the palette register value to select a
     video DAC color register in one of two ways. When bit 7 is set to 0,
     the Attribute Controller combines the 6-bit palette-register value
     with bits 2 and 3 of its Color Select register (14H) to produce an 8-
     bit value that selects a video DAC color register (see Figure 3-13).
     Alternatively, when bit 7 is set to 1, only the four low-order bits of
     each palette register are meaningful. The Attribute Controller derives
     the other four bits of the 8-bit value from bits 0 through 3 of the
     Color Select register (see Figure 3-14).

     In the first case (when bit 7 of the Mode Control register is set to
     0), the 6-bit palette registers are used to select one of four groups
     of 64 video DAC color registers, and bits 2 and 3 of the Color Select
     register determine which group of color registers is used. In the
     second case (when bit 7 of the Mode Control register is set to 1),
     each palette register value selects one of 16 groups of 16 video DAC
     color registers, and bits 0 through 3 of the Color Select register
     specify one of the 16 groups of DAC color registers.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³ 4-bit attribute ³ Logical AND  ³   Color Plane   ³
     ³                 ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄ´ Enable register ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ³      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                               
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Palette register 0-0FH³  ³Color Select register ³
                   ³                      ³  ³     (bits 2-3)       ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
                               ³Bits 0-5 of              ³ Bits 6-7 of
                               ³color register           ³ color register
                               ³number                   ³ number
                               ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                            ³
                                            ³     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                            ³     ³    Video DAC Mask     ³
                                            ³     ³       register        ³
                                            ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
                                            ³   Logical AND    ³
                                            ÀÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ
                                                   ³
                                                   
                                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                        ³      Video DAC       ³
                                        ³color register 0-0FFH ³
                                        ÀÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ
                                                   ³
                                                   
                                 18-bit analog output to video display
                                   (6 bits each for red, green, blue)
     
     Figure 3-13.  Attributes and colors on the VGA (when bit 7 of the
     Attribute Controller's Mode Control register is set to 0).

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.


     This added level of indirection, afforded by the combined use of
     palette registers and video DAC color registers, makes switching
     between palettes easy, since you can select any of 16 different 16-
     color palettes just by changing the value in the Attribute
     Controller's Color Select register. If you store 16 palettes of
     gradually increasing intensity in the DAC color registers, you can
     accentuate characters on the screen by cyclically increasing and
     decreasing their intensity. This effect is more subtle than simply
     blinking the characters on and off, particularly when applied to a
     large area of the display.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿              ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³ 4-bit attribute ³ Logical AND  ³   Color Plane   ³
     ³                 ÃÄÄÄÄÄÄÄÂÄÄÄÄÄÄ´ Enable register ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ       ³      ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                               
                   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                   ³Palette register 0-0FH³  ³Color Select register ³
                   ³                      ³  ³     (bits 0-3)       ³
                   ÀÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ  ÀÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
                               ³Bits 0-3 of              ³ Bits 4-7 of
                               ³color register           ³ color register
                               ³number                   ³ number
                               ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                            ³
                                            ³     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                            ³     ³    Video DAC Mask     ³
                                            ³     ³       register        ³
                                            ³     ÀÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÙ
                                            ³   Logical AND    ³
                                            ÀÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ
                                                   ³
                                                    
                                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                                        ³      Video DAC       ³
                                        ³color register 0-0FFH ³
                                        ÀÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÙ
                                                   ³
                                                   
                                 18-bit analog output to video display
                                   (6 bits each for red, green, blue)

     Figure 3-14.  Attributes and colors on the VGA (when bit 7 of the
     Attribute Controller's Mode Control register is set to 1).


       ÉÍÍÍ»     When the VGA emulates 80-by-25 16-color alphanumeric mode
       º T º     on a monochrome display, the palette consists of the same
       º I º     four groups of four gray-scaled values as does the
       º P º     corresponding palette on the MCGA. As on the MCGA, you can
       ÈÍÍÍ¼     create a gray-scale palette with gradually increasing
                 intensities. Listing 3-7 illustrates how you might do
                 this. Note how the appropriate video DAC registers are
                 selected by examining the values in the Attribute
                 Controller's palette registers.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-7.  Loading an alternative VGA monochrome gray-scale
     palette.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The VGA emulates the MDA's monochrome alphanumeric mode (video BIOS
     mode 7) on either a color or a monochrome display. The Attribute
     Controller palette register values and the control of blinking and
     underlining are the same as on the EGA. In this mode, the video DAC
     registers corresponding to the palette values 00H, 07H, 08H, and 18H
     are initialized with the appropriate gray-scale values. The palette
     and video DAC register values are the same in this mode regardless of
     whether a color or monochrome display is attached.


Gray-Scale Summing


     Both the MCGA and the VGA BIOS contain logic which can transform the
     red-green-blue values in the video DAC registers into corresponding
     gray-scale values. This transformation is performed by taking a
     weighted average of the red, green, and blue components. To compute
     the gray-scaled equivalent value, the BIOS sums 30 percent of the red
     value, 59 percent of the green, and 11 percent of the blue. (These
     percentages approximate the displayed intensities of pure red, green,
     and blue.) For example, the default color for video DAC Color Register
     02H (cyan) is made up of three 6-bit components. The value of the red
     component is 0, the green component 2AH, and the blue component 2AH.
     The gray-scale value is therefore 1DH, the sum of

     (.30 x 0) + (.59 x 2AH) + (.11 x 2AH)

     INT 10H function 10H includes a subfunction (AL = 1BH) that reads a
     set of video DAC color registers and updates them with equivalent
     gray-scale values. Appendix A contains an example of the use of this
     video BIOS function.
 
     On both the MCGA and the VGA, INT 10H function 0 uses gray-scale
     summing by default when a monochrome display is attached. With a color
     display, gray-scale summing is disabled by default. You can
     selectively enable or disable default gray-scale summing by executing
     INT 10H function 12H with BL = 33H.


Border Color


     On the CGA, EGA, MCGA, and VGA, you can specify a color to be
     displayed during the vertical and horizontal overscan intervals. This
     overscan or border color is not represented by any data in the video
     buffer. Instead, a special control register contains the value of the
     color displayed.


CGA

     On the CGA, you select the border color with the four low-order bits
     of the Color Select register at I/O port 3D9H (see Listing 3-8). The
     color values parallel those available for character attributes: bits
     0, 1, and 2 select the blue, green, and red primaries, and bit 3 is
     interpreted as an intensity bit.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-8.  Setting a border color.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Using INT 10H function 0BH to update the border color is probably more
     convenient than programming the Color Select register directly. The
     code is more portable, and the BIOS routine saves the most recently
     written value of the Color Select register in its Video Display Data
     Area in the byte at 0040:0066 (CRT_PALETTE). If you do write directly
     to the Color Select register, you should update CRT_PALETTE as in the
     example in Listing 3-8.

       ÉÍÍÍ»     The MCGA does not generate a colored border, regardless of
       º T º     the value in its Color Select register.
       º I º
       º P º
       ÈÍÍÍ¼


EGA and VGA

     On the EGA and VGA, the overscan color is specified by the contents of
     register 11H of the Attribute Controller (I/O port 3C0H). You could
     write directly to the  I/O port, but doing the job with an INT 10H
     call is usually easier. You can use the EGA BIOS to update the
     overscan color in two ways. You can use function 0BH of INT 10H or you
     can include the border color as the 17th and last entry in the table
     of palette register colors you pass to INT 10H function 10H (see
     Appendix A).

       ÉÍÍÍ»     On the VGA with a monochrome display, the only useful
       º T º     border attributes are 0 (black), 8 (normal), and 18H
       º I º     (intense).
       º P º
       ÈÍÍÍ¼

     The 350-line video modes on the EGA have relatively short vertical and 
     horizontal overscan intervals. The displayed border may be only 1 or 2
     mm wide, or it may bleed across the screen during the horizontal
     retrace interval. For this reason you should avoid setting the border
     color in any 350-line mode on the EGA.

       ÉÍÍÍ»     You can increase the EGA's horizontal and vertical
       º T º     overscan intervals in 350-line modes by modifying the CRTC
       º I º     horizontal and vertical timing parameters. A reasonable
       º P º     border, about as wide as that displayed with the VGA, can
       ÈÍÍÍ¼     be achieved by adding one or two characters to the
                 Horizontal Total value and eight or ten scan lines to the
                 Vertical Total value. The corresponding timing values for
                 the Horizontal and Vertical Retrace and Blanking registers
                 must be adjusted accordingly (see  Figure 3-15).

                 The problem with reprogramming the CRTC in this way is
                 that the horizontal and vertical frequencies that drive
                 the video display are somewhat lower than nominal. For
                 example, with the CRTC values shown in Figure 3-15,
                 the horizontal scan rate becomes 16.257 MHz / (94
                 chars/line x 8/char), or 21.62 KHz, which is about 1
                 percent lower than the nominal horizontal scan frequency
                 of 21.85 KHz. Similarly, the vertical scan rate becomes
                 21.62 KHz / 374 lines, or 58 Hz, almost 4 percent lower
                 than the usual 60 Hz frame rate. Still, these scan rates
                 are usually within the tolerances of an EGA-compatible
                 video display.


               80-by-25 16-Color Alphanumeric Mode:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CRTC register  Function                      Setting (default)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0              Horizontal Total              5CH (5BH)

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
2              Horizontal Blanking Start     54H (53H)
3              Horizontal Blanking End       3CH (37H)
4              Horizontal Retrace Start      52H (51H)
5              Horizontal Retrace End        5CH (5BH)
6              Vertical Total                76H (6CH)
10H            Vertical Retrace Start        64H (5EH)
11H            Vertical Retrace End          25H (2BH)
15H            Vertical Blank Start          64H (5EH)
16H            Vertical Blank End            11H (0AH)


               640-by-350 16-Color Graphics Mode:
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
CRTC register  Function                      Setting (default)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0              Horizontal Total              5CH (5BH)
2              Horizontal Blanking Start     53H (53H)
3              Horizontal Blanking End       3CH (37H)
4              Horizontal Retrace Start      53H (52H)
5              Horizontal Retrace End        00H (00H)
6              Vertical Total                76H (6CH)
10H            Vertical Retrace Start        64H (5EH)
11H            Vertical Retrace End          25H (2BH)
15H            Vertical Blank Start          64H (5EH)
16H            Vertical Blank End            11H (0AH)

     Figure 3-15.  CRTC parameters for increased border width in 350-line
     EGA video modes. (Default register values are listed in parentheses.)


Avoiding CGA Snow


     On the CGA, alphanumeric video display modes present a particular
     programming challenge whenever you are concerned about the speed of
     video display output. You must program carefully in alphanumeric modes
     to prevent interference with the display when you read or write data
     in the CGA's video buffer.

     Directly accessing the contents of the CGA's video buffer from 
     your program has its pros and cons. On the positive side, it enables
     your program to completely control the buffer's contents, and thus
     what is displayed. The negative side is that when both the CPU and
     the display-refresh circuitry access the buffer at the same time,
     interference, or "snow," can appear on the display. The snow can be
     barely noticeable or greatly distracting, depending on the amount of
     data transferred to or from the video buffer.

     In general, to avoid snow you must limit CPU accesses to the video
     buffer to intervals when data is not being fetched from the buffer to
     refresh the screen. In practice, this means that your program must
     transfer data to and from the video buffer only when the electron
     beam in the video display is moving through an overscan or retrace
     interval.

     This synchronization can be achieved in several ways, but,
     unfortunately, all of them introduce a certain amount of hardware
     dependency into your program. As a general rule, the more hardware-
     dependent tricks you play, the faster your program runs on a CGA but
     the less likely it is to run on another video adapter.


Blanking the Display

     One technique for preventing display interference on the CGA is to
     turn off the electron beam whenever you access the display buffer. You
     then leave the beam off while data is transferred to or from the video
     buffer. This method is used in the ROM BIOS routines which scroll the
     display.

     The best time to blank the display is when it's blank anyway, at the
     start of a vertical blanking interval. If you do not take care to turn
     the electron beam off during the vertical blanking interval, you will
     instead blank the screen while it is being refreshed. This can produce
     an annoying flicker or interference stripes.

     The technique is straightforward (see Listing 3-9). The trick is to
     synchronize buffer access with the start of a vertical blanking
     interval. Do this by detecting an interval when vertical blanking is
     not occurring. Then wait for the next subsequent vertical blanking
     interval to begin.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-9.  Display alphanumeric text on the CGA by blanking the
     display.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     The procedure for detecting the start of a vertical blanking interval
     requires you to first determine a timeout value for the horizontal
     retrace interval (see Listing 2-2). This value is then used to wait
     for the last horizontal scan in the current frame. When the last
     horizontal blanking interval times out, the vertical blanking interval
     has begun.

     At this point, your program should explicitly disable the electron
     beam by resetting bit 3 of the CGA's Mode Control register (port
     3D8H). When this bit is zeroed, the electron beam is disabled and the
     display remains dark. While the display is dark, you can move data to
     or from the video buffer without causing snow. When the data transfer
     is complete, restore the display by setting bit 3 of the Mode Control
     register to 1.

     It is not necessarily desirable to wait for another vertical blanking
     interval before reenabling the electron beam. If the period during
     which you transferred data left the screen dark long enough to cause
     noticeable flicker, waiting until the next vertical retrace will only
     prolong the duration of the flicker. If you reenable the display
     somewhere in the middle of a refresh cycle, the flicker will be worse
     in the top part of the screen but better in the bottom part. Neither
     situation is ideal; it's up to you to decide which alternative is
     preferable.

     The amount of time it takes to access the video buffer determines how
     long your program must keep the screen dark. Obviously, the longer the
     screen is dark, the more flicker you perceive. If your program is
     executed on one of the slower members of the IBM PC family (PC or
     PC/XT), the flicker effect can become annoying.

     Consider what might happen whenever you scroll an entire 80-by-25
     screen up one line. Within the video buffer, 4000 bytes of data must
     be moved. On a vintage IBM PC, with its 4.77 MHz 8088, this data
     transfer takes about 21 milliseconds. Since each video frame lasts
     about 16.7 milliseconds (1/60 second), the screen remains dark for
     about 1-1/3 frames. The resulting flicker is very noticeable,
     particularly if the background color is not black. On the other hand,
     on a PC with a faster CPU, the data transfer takes less time, so the
     flicker is less apparent.


Using the Vertical Blanking Interval

     A technique that avoids the flicker problem is to access the video
     buffer only for the duration of the vertical blanking interval.
     However, this slows data transfer, because you can move only a limited
     number of bytes of data during a single vertical blanking interval.

     The limitations here are the duration of the vertical blanking
     interval (about 4 milliseconds) and the rate at which the CPU can move
     data in the video buffer. A 4.77 MHz 8088 in a PC or PC/XT can move
     about 450 words (900 bytes) of data before the vertical blanking
     interval ends and snow becomes visible. Obviously, a PC with a higher
     clock speed or with an 80286 or 80386 can move more data during a
     single vertical blanking interval.


Using the Horizontal Blanking Interval

     If your video output routine synchronizes with the start of horizontal
     blanking intervals, you have about 7 microseconds in which to access
     the video buffer at the end of each raster scan line without causing
     snow (see Listing 3-10). Although 7 microseconds may not seem like
     much time, it is long enough to move 2 bytes into or out of the video
     buffer without causing display interference. Since each frame contains
     200 horizontal blanking intervals, you can significantly increase
     performance by taking advantage of them.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-10.  Display alphanumeric text on the CGA during horizontal
     and vertical blanking intervals.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Because the horizontal blanking interval is so short, synchronization
     is critical. The technique is parallel to that used for synchronizing
     with the vertical retrace interval. In this case, you determine the
     status of the Display Enable signal by testing bit 0 of the CRT Status
     register (3DAH). When this bit has a value of 1, the Display Enable
     signal is off and a horizontal blanking interval is in progress.

     Keep in mind two considerations if you take the trouble to use the
     horizontal blanking intervals. First, you might as well use the
     vertical blanking intervals as well, since they're there. Second, you
     should use MOVS or STOS instructions to do the actual data transfers.
     The slower MOV mem/reg instruction can take longer than the horizontal
     blanking interval lasts, so snow isn't eliminated.

     The IBM ROM BIOS routines that write to the video buffer during
     horizontal retrace use the sequence

        mov    ax,bx
        stosw

     to move a character and attribute into the buffer without snow.
     Nevertheless, if you use the same two instructions in a RAM-based
     program, you see snow on a CGA running on a 4.77 MHz PC. The reason is
     that, at the point where these instructions are executed, the 4-byte
     instruction prefetch queue in the 8088 has room for only two more
     bytes. This means that the STOSW opcode cannot be prefetched. Instead,
     the 8088 must fetch the opcode from memory before it can  be executed.

     That last memory access to fetch the STOSW instruction makes the
     difference. Because accesses to ROM are faster than accesses to RAM,
     the instruction fetch is slightly faster out of ROM, so no snow is

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     visible because the STOSW can run before the horizontal blanking
     interval ends. The routine in Listing 3-10 sidesteps the problem by
     using XCHG AX,BX (a 1-byte opcode) instead of MOV AX,BX (a 2-byte
     opcode). This avoids the extra instruction fetch, so the code executes
     fast enough to prevent display interference.

     Note how the interrupts are disabled in the loop that waits for the
     start of the horizontal blanking interval. Had an interrupt occurred
     between the JNZ L06 and the following XCHG AX,BX instructions, the
     horizontal blanking interval would have ended long before control
     returned from the interrupt handler. Disabling interrupts while each
     word is transferred into the video buffer avoids this possible loss of
     synchronization.

       ÉÍÍÍ»     The routine in Listing 3-10 never explicitly detects the
       º T º     end of the vertical blanking interval, nor does it count
       º I º     the 200 horizontal scans in each display refresh cycle.
       º P º     Instead, the number of bytes that can be transferred
       ÈÍÍÍ¼     during each vertical blanking interval (VBcount) is
                 determined empirically for a "worst case" situation (for
                 example, for a 4.77 MHz IBM PC).

                 The most important reason for this imprecision about the
                 number of bytes to transfer during vertical blanking
                 intervals is that interrupts can occur anywhere in a video
                 output routine except where they are explicitly disabled.
                 For example, clock-tick interrupts and keyboard interrupts
                 can occur at any time. Because you can't simply disable
                 all interrupts for the duration, you must design video
                 output routines to accommodate the unpredictable time
                 spent in interrupt handlers.

     The problem of snow is avoided in the hardware design of every other
     IBM PC and PS/2 video subsystem, including the MDA, EGA, MCGA, and VGA
     (and even the PCjr). Also, many second-source manufacturers of CGA-
     compatible adapters design their hardware to eliminate the problem.
     This means that retrace synchronization loops may not be needed in
     many applications.

     If you run a program either on a CGA (with snow) or on a CGA-
     compatible (without snow), the program should try to determine what
     type of hardware it is running on (see Appendix C). If the program is
     running on a machine without snow, it can skip over any vertical and
     horizontal synchronization loops. The slight extra overhead of
     detecting the presence of a CGA is repaid in greatly improved
     performance on video subsystems that have no snow problem.


Using All the Video Buffer


     In alphanumeric video modes, the CGA, EGA, MCGA, and VGA have much
     more RAM available in their video buffers than is required to display
     one screen of text. In other words, you can display only a portion of
     the data in the video buffer at a time. In effect, what you see on the
     screen is a "window" on the video buffer.

     For example, in 80-by-25-character alphanumeric modes, only 4000 bytes
     (80 x 25 x 2 bytes per character) are displayed at any one time.
     However, the CGA has 16 KB of video RAM, so you can actually store
     four 80-by-25 screens of data in the buffer. You can then program the
     CGA's CRT Controller to display any 2000 consecutive characters (4000
     bytes) in the buffer.


CGA Video Pages

     To program the CGA to display different portions of the buffer, you
     update two CRT Controller registers. When you call the ROM BIOS to
     select a video display mode, the BIOS initializes the CRTC to display
     the first 4000 bytes of the video buffer. It does this by storing 0,
     the offset of the first character to be displayed, in the CRTC Start
     Address registers (0CH and 0DH).

     You can display any arbitrary portion of the CGA's video buffer by
     storing a video buffer offset in words (not bytes) in the CRTC Start
     Address registers. The high-order byte of the offset belongs in
     register 0CH, the low-order byte in register 0DH. For example, loading
     the Start Address registers with the word offset of the second row
     (50H) causes the display to begin there (see Listing 3-11).

     Loading the Start Address registers is a much faster operation than
     transferring characters into the video buffer. Thus, you might regard
     the 16 KB video buffer as a 102-line "virtual" screen of which only 25
     lines can be displayed at a time. When the video buffer is filled with
     text, you can rapidly display any 25 consecutive lines simply by
     changing the value in the CRTC Start Address registers.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-11.  Setting the CRTC Start Address registers.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Whenever you update the Start Address registers, also update the BIOS
     Video Display Data Area word at 0040:004E (CRT_START). This helps to
     maintain functionality across video BIOS calls and with MS-DOS.

     Instead of deciding for yourself which portions of the video buffer to
     display, you might find it more convenient to adopt the conceptual
     model of the ROM BIOS, which supports four 80-by-25 (or eight 40-by-
     25) virtual "pages" in the CGA's video buffer. To simplify addressing,
     each page starts on a 1 KB (1024-byte) boundary. The four 80-by-25
     pages thus start at B800:0000, B800:1000, B800:2000, and B800:3000.
     You can selectively display any video page by calling INT 10H function
     05H (see Listing 3-12).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-12.  Video page selection using the ROM BIOS.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


       ÉÍÍÍ»     A technique that can improve CGA performance is to display
       º T º     one video page while you fill another (nondisplayed) video
       º I º     page with data. Then you display the newly filled video
       º P º     page and make the previous page available for more data
       ÈÍÍÍ¼     transfers. Design your user interface so that while the
                 user reads the display, a nondisplayed video page is
                 filled with the next screen of information. Careful use of
                 the video pages can make screen updates appear
                 "instantaneous."

                 You must still avoid display interference by using one of
                 the techniques for synchronizing the update with vertical
                 or horizontal blanking intervals, even if you write to a
                 nondisplayed portion of the buffer.


EGA, MCGA, and VGA Video Pages

     With the EGA, MCGA, and VGA, the techniques for using video RAM are
     similar to those used on the CGA. The Start Address registers in the
     CRT Controller are mapped to the same I/O port addresses as they are
     on the CGA's CRTC. Furthermore, the video BIOS supports video pages
     with the same interface used for the CGA. This simplifies writing a
     program to run on all of these video subsystems.

       ÉÍÍÍ»     One handy feature of the CRTC on the EGA, the MCGA, the
       º T º     VGA, and some but not all CGA look-alikes is that the
       º I º     Start Address registers can be read as well as written.
       º P º     This feature can be useful in programming these registers
       ÈÍÍÍ¼     directly, because you can determine their contents at any
                 time simply by inspecting them.


Cursor Control


     The CRT Controller also controls the size and screen location of the
     hardware cursor in alphanumeric modes. You specify the cursor's size
     by loading a CRTC register with values that indicate its top and
     bottom lines. The top line is 0; the value for the bottom line depends
     on the size of the displayed character matrix--7 for an 8-by-8 matrix
     and 0DH for a 9-by-14 matrix. The cursor's location is specified with
     a word offset into the video buffer, exactly as you specify the CRT
     Controller's start address.


Cursor Size on the MDA and CGA

     CRTC registers 0AH and 0BH control the cursor size on all IBM PC and
     PS/2 video subsystems. On the MDA and the CGA, the low-order five bits
     of register 0AH (Cursor Start) indicate the top line of the displayed
     cursor. The low-order five bits of register 0BH (Cursor End) specify
     the bottom line.

     Changing the size of the hardware cursor is a matter of programming
     these two registers. For example, to display a "block" cursor, which
     is a rectangle filling an entire character space, set the Cursor Start
     register to 0 and the Cursor End register to one less than the height
     of the character matrix. To display the ROM BIOS's default cursor, set
     the Cursor Start and Cursor End registers to the values for the last
     two lines of the character matrix, as is done in Listing 3-13.

     In most applications, however, you can use INT 10H function 1 (Set
     Cursor Type) to change the cursor's size. Using this function ensures
     compatibility with the video BIOS on all IBM PC and PS/2 video
     subsystems. Although performing the software interrupt and executing
     the BIOS routine is slower than programming the CRTC directly, in
     general you modify the cursor size so infrequently that you'll never
     notice the slight slowing of your program.

     Also, the BIOS routine maintains the current cursor size in two bytes
     in the Video Display Data Area at 0040:0060 (CURSOR_MODE). On the MDA
     and CGA, the CRTC's Cursor Start and Cursor End registers are read-
     only registers, so you might as well use the BIOS to keep track of the
     current state of the cursor. The byte at 0040:0060 represents the
     value in 6845 register 0AH (Cursor Start), and the following byte, at
     0040:0061, represents register 0BH (Cursor End). If you do bypass the
     BIOS routine and program the 6845 directly, keep the values in
     CURSOR_MODE up to date.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     Listing 3-13.  Setting the cursor size.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Cursor Location on the MDA and CGA

     To control the cursor's location, load a buffer offset into the CRTC's
     Cursor Location High (0EH) and Cursor Location Low (0FH) registers
     (see Listing 3-14). The Cursor Location offset is relative to the
     start of the video buffer. If you have changed the CRTC Start Address
     registers, you must adjust for the new Start Address offset in
     calculating the Cursor Location offset.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-14.  Setting the cursor location.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


MCGA Cursor Control

     The MCGA's CRTC doubles the values you store in the Cursor Start and
     Cursor End registers and doubles the number of scan lines in the
     displayed cursor. Thus, the size of the MCGA's alphanumeric cursor is
     a multiple of two scan lines.

     This doubling of the Cursor Start and Cursor End values allows you to
     specify default alphanumeric cursor sizes with the same values you
     would use on a CGA. For example, in the MCGA's default alphanumeric
     modes, the character matrix is 16 lines high. If you set Cursor Start
     to 6 and Cursor End to 7, as you would in a CGA alphanumeric mode, you
     see the MCGA's cursor at the bottom of the character matrix in lines
     0CH through 0FH. In this way the MCGA's Cursor Start and End registers
     emulate the CGA's despite the MCGA's taller character matrix.

     However, there are several differences in the way the MCGA interprets
     the Cursor Start and Cursor End values (see Figure 3-16). On the
     MCGA, only the four low-order bits of the Cursor Start and Cursor End
     values are significant. Furthermore, since the character matrix can be
     at most 16 scan lines high, Cursor Start and Cursor End values are
     usually limited to the range 0 through 7. Values greater than 7 can
     produce a cursor that wraps around to the top of the character matrix
     (see Figure 3-16e).


EGA and VGA Cursor Control

     On the EGA and the VGA, the Cursor Start, Cursor End, Cursor Location
     High, and Cursor Location Low registers are mapped to the same CRTC
     register numbers as on the MDA and CGA. This can lead to trouble if
     you're concerned about portability and need to write to the CRTC
     registers directly. This is because the EGA and VGA Cursor Start and
     Cursor End registers do not function exactly as do those on the MDA,
     CGA, or MCGA.

     On the EGA, the value you specify for the Cursor End register must be
     1 greater than the bottom line of the cursor (see Figure 3-17). The
     EGA's CRT Controller displays the alphanumeric cursor from the
     character scan line specified in the Cursor Start register to the line
     specified by the Cursor End register minus 1.

     If the Cursor End value is less than the Cursor Start value, the
     cursor wraps around the character matrix. If the low-order four bits
     of the Cursor Start and Cursor End values are equal, the cursor
     appears only on the single line specified in the Cursor Start
     register. Finally, the Cursor End value must be less than the number
     of scan lines in the character matrix. Otherwise, the CRT Controller
     displays a full-height cursor regardless of the Cursor Start
     register's value.


     Cursor Start = 2                   Cursor Start = 2
     Cursor End = 2                     Cursor End = 4
                      ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0-1   ³ º º º º º º º ³  Scan line 0-1   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2-3   ³ º º º º º º º ³  Scan line 2-3   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4-5   ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 4-5   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6-7   ³ º º º º º º º ³  Scan line 6-7   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 8-9   ³ º º º º º º º ³  Scan line 8-9   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 10-11 ³ º º º º º º º ³  Scan line 10-11 ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 12-13 ³ º º º º º º º ³  Scan line 12-13 ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 14-15 ³ º º º º º º º ³  Scan line 14-15 ³ º º º º º º º ³
                      ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     a.                                 b.


     Cursor Start = 3                   Cursor Start = 4
     Cursor End = 7                     Cursor End = 2
                      ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0-1   ³ º º º º º º º ³  Scan line 0-1   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2-3   ³ º º º º º º º ³  Scan line 2-3   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4-5   ³ º º º º º º º ³  Scan line 4-5   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6-7   ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 6-7   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 8-9   ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 8-9   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 10-11 ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 10-11 ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 12-13 ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 12-13 ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 14-15 ³ÛºÛºÛºÛºÛºÛºÛºÛ³  Scan line 14-15 ³ º º º º º º º ³
                      ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     c.                                 d.


     Cursor Start = 3
     Cursor End = 8
                      ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0-1   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2-3   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4-5   ³ º º º º º º º ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6-7   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 8-9   ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 10-11 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 12-13 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 14-15 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                      ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     e.

     Figure 3-16.  Sample MCGA alphanumeric cursor settings for an 8-by-16
     character matrix.


     The VGA's Cursor Start and Cursor End values (see Figure 3-18) work
     slightly differently than do the EGA's. The VGA's Cursor End value
     indicates the last line of the displayed cursor (not the last line
     plus 1), and the displayed cursor does not wrap around to the top of
     the character matrix if the Cursor End value is less than the Cursor
     Start value. (Compare Figures 3-17 and 3-18.)


     Cursor Start = 4                     Cursor Start = 4
     Cursor End = 4                       Cursor End = 8
                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                    ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0 ³ º º º º º º º ³        Scan line 0 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 1 ³ º º º º º º º ³        Scan line 1 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2 ³ º º º º º º º ³        Scan line 2 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 3 ³ º º º º º º º ³        Scan line 3 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 5 ³ º º º º º º º ³        Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6 ³ º º º º º º º ³        Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 7 ³ º º º º º º º ³        Scan line 7 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                    ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     a.                                   b.


     Cursor Start = 4                     Cursor Start = 4
     Cursor End = 7                       Cursor End = 2
                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                    ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0 ³ º º º º º º º ³        Scan line 0 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 1 ³ º º º º º º º ³        Scan line 1 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2 ³ º º º º º º º ³        Scan line 2 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 3 ³ º º º º º º º ³        Scan line 3 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 7 ³ º º º º º º º ³        Scan line 7 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                    ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     c.                                   d.


     Cursor Start = 4
     Cursor End = 0
                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
      Scan line 1 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 3 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 7 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     e.

     Figure 3-17.  Sample EGA alphanumeric cursor settings for an 8-by-8
     character matrix.


       ÉÍÍÍ»     Bits 5 and 6 of the Cursor End register (0BH) on the EGA
       º T º     and VGA control the rightward skew of the cursor. If bits
       º I º     5 and 6 are not 0, the cursor appears one, two, or three
       º P º     characters to the right of the location that the Cursor
       ÈÍÍÍ¼     Location registers specify. For most applications, the
                 cursor skew should be 0.


     Cursor Start = 4                     Cursor Start = 4
     Cursor End = 4                       Cursor End = 8
                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                    ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0 ³ º º º º º º º ³        Scan line 0 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 1 ³ º º º º º º º ³        Scan line 1 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2 ³ º º º º º º º ³        Scan line 2 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 3 ³ º º º º º º º ³        Scan line 3 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 5 ³ º º º º º º º ³        Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6 ³ º º º º º º º ³        Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 7 ³ º º º º º º º ³        Scan line 7 ³ÛºÛºÛºÛºÛºÛºÛºÛ³
                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                    ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
     a.                                   b.


     Cursor Start = 4                     Cursor Start = 4
     Cursor End = 7                       Cursor End = 2
                  ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿                    ÚÄÒÄÒÄÒÄÒÄÒÄÒÄÒÄ¿
      Scan line 0 ³ º º º º º º º ³        Scan line 0 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 1 ³ º º º º º º º ³        Scan line 1 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 2 ³ º º º º º º º ³        Scan line 2 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 3 ³ º º º º º º º ³        Scan line 3 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 4 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 4 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 5 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 5 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 6 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 6 ³ º º º º º º º ³
                  ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ                    ÆÍÎÍÎÍÎÍÎÍÎÍÎÍÎÍµ
      Scan line 7 ³ÛºÛºÛºÛºÛºÛºÛºÛ³        Scan line 7 ³ º º º º º º º ³
                  ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ                    ÀÄĞÄĞÄĞÄĞÄĞÄĞÄĞÄÙ
      c.                                  d.

     Figure 3-18.  Sample VGA alphanumeric cursor settings for an 8-by-8
     character matrix.


ROM BIOS Cursor Emulation

     The ROM BIOS routine for INT 10H function 01H uses the values in 80x86
     registers CH and CL to program the CRTC Cursor Start and Cursor End
     registers (see Listing 3-13). On an MDA or CGA, these values are
     simply copied into the CRTC registers. On an EGA or VGA, however, the
     BIOS can scale these values relative to an 8-line character matrix and
     program the CRTC with the scaled results. This scaling is called
     "cursor emulation" in IBM's technical manuals.

     When ROM BIOS cursor emulation is in effect, the values you specify to
     INT 10H function 01H represent the position of the start and end of
     the displayed cursor relative to an 8-line character matrix. When the
     actual character matrix is larger than 8 lines, the BIOS routine
     adjusts the Cursor Start and Cursor End values to maintain the
     cursor's relative location in the matrix.

     Consider what happens, for example, when you call INT 10H function 01H
     with CH = 6 and CL = 7. If the character matrix is 8 lines high, the
     cursor appears on the bottom two lines. (This is the usual cursor in
     200-line video modes.) If the character matrix is 14 lines high,
     however, the BIOS routine adjusts the Cursor Start and Cursor End
     values so that the cursor appears near the bottom of the matrix; that
     is, on lines 0BH and 0CH. Thus, cursor emulation allows programs that
     change the cursor size with INT 10H function 01H to run unchanged
     regardless of the size of the character matrix.

     The BIOS carries out cursor emulation in INT 10H functions whenever
     bit 0 of the Video Display Data Area INFO byte (0040:0087) is set to
     0. (This is the power-on default for both the EGA and the VGA.) You
     can disable cursor emulation by setting this bit to 1 before calling
     INT 10H function 01H. On the EGA, you must set and reset the bit
     directly, but on the VGA, you should use INT 10H function 12H to set
     the bit's value.

       ÉÍÍÍ»     On the EGA, cursor emulation is implemented by adding 5 to
       º T º     any Cursor Start or Cursor End value greater than 4. This
       º I º     works well when the character matrix is the default 14
       º P º     lines high. For character matrices of other heights,
       ÈÍÍÍ¼     however, this simple algorithm breaks down and computes
                 the Cursor Start and Cursor End values incorrectly. You
                 should therefore disable cursor emulation when you program
                 the EGA's character generator to change the size of its
                 character matrix (see Chapter 10).

                 On the VGA, the cursor-emulation computation takes into
                 account the height of the character matrix, so the
                 emulated cursor is displayed correctly regardless of
                 character matrix dimensions.


An Invisible Cursor

     You can make the cursor "invisible" by programming the CRT Controller
     to display it at an offscreen location. Do this by setting the Cursor
     High and Cursor Low registers to a non-displayed buffer offset.
     Another way to make the cursor vanish is to load the Cursor Start and
     Cursor End registers with values below the displayed character matrix.
     On the MDA, CGA, and VGA, load the Cursor Start register with the
     value 20H to make the cursor disappear. On the EGA, set Cursor Start
     to a value greater than or equal to the number of lines in the
     character matrix and set Cursor End to 0 (see Listing 3-15).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 3-15.  An invisible alphanumeric cursor for IBM video
     subsystems.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



                         4  Graphics Modes


                        Using Graphics Modes

                    Mapping Pixels to the Screen
                           CGA ş HGC ş EGA
                Hercules InColor Card ş MCGA and VGA

                          Pixel Coordinates
                      Pixel Coordinate Scaling
                            Aspect Ratio

                      Pixel Display Attributes
                           CGA ş HGC ş EGA
                 Hercules InColor Card ş MCGA ş VGA



     This chapter covers the basics of graphics-mode programming on the
     CGA, EGA, MCGA, VGA, and Hercules cards. First the chapter describes
     how pixels are represented in the video buffer and how they are mapped
     to the screen. Then it focuses on pixel display attributes; that is,
     on how to determine a pixel's color, intensity, and blinking.


Using Graphics Modes


     In graphics modes, your program can manipulate the color of every
     pixel on the display. For this reason, graphics modes are sometimes
     called All Points Addressable (APA) modes. Because you have control
     over each pixel in the displayed image, you can construct complex
     geometric images, fill arbitrary areas of the screen with solid colors
     or blends of colors, and display animated images that move smoothly
     across the screen.

     Most programmers, however, use graphics modes only when pixel-by-pixel
     control over the screen is essential to an application. The reason:
     The price you pay for total control over the screen is increased
     source code complexity and decreased performance. A simple comparison
     of the amount of data required to display a full screen of information
     in alphanumeric and in graphics modes shows why.

     For example, to display 25 rows of 16-color, 80-column text in
     alphanumeric mode on an EGA, you need to store 4000 bytes (80 x 25 x
     2) in the video buffer. With a 350-line monitor, the text is displayed
     with 640-by-350-pixel resolution. Obtaining the same resolution in a
     16-color graphics mode requires 112,000 bytes (640 x 350 x 4 bits per
     pixel / 8 bits per byte). Obviously, a program that must manipulate
     112,000 bytes of data is more complex and slower than a program that
     manipulates only 4000 bytes.

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.

     Of course, the performance penalty for using graphics-mode video
     output is less apparent when you use a faster computer, such as an
     80286-based or 80386-based machine whose CPU runs at a high clock
     speed. Still, before you leap into graphics-mode programming, you
     should carefully consider the alternatives. Alphanumeric modes are
     sufficient for displaying text and simple block graphics and, hence,
     for the majority of real-world applications.

       ÉÍÍÍ»     An alternative in some applications is to use a video
       º T º     subsystem that has an alphanumeric character generator
       º I º     capable of displaying RAM-based character sets. (The EGA,
       º P º     MCGA, VGA, HGC+, and InColor Card all have this
       ÈÍÍÍ¼     capability.) With these subsystems, you can design
                 "characters" that are actually subunits of a larger
                 graphics image and then assemble the subunits into a
                 complete image in an alphanumeric mode. (Chapter 10
                 explains the technique in detail.)


Mapping Pixels to the Screen


     PC and PS/2 video subsystems store pixel data as groups of bits that
     represent pixel values. The color of each pixel on the display is
     determined, directly or indirectly, by its pixel value. Furthermore,
     no pixel value is ever represented by more than eight bits, so one or
     more pixels are mapped into every byte in the video buffer.

     The format of the pixel map or bit map in the video buffer depends on
     the number of bits required to represent each pixel, as well as on the
     architecture of the video RAM. Obviously, the number of colors that a
     given graphics mode can display at one time is determined by the
     number of bits used to represent each pixel.

     When pixel values are smaller than eight bits, pixels are mapped in
     bit fields from left to right across each byte. The leftmost pixel
     represented in a given byte is always found in that byte's high-order
     bit(s). This is true on all PC and PS/2 video subsystems.


Color Graphics Adapter

     On the CGA, each pixel is represented either by two bits, as in 320-
     by-200 4-color mode (see Figure 4-1a) or by one bit, as in 640-by-200
     2-color mode (see Figure 4-1b). Because two bits are used to
     represent pixels in 320-by-200 mode, a pixel can have any of four
     different pixel values, so this mode can display four different colors
     at a time. Only one bit is used to represent pixel values in 640-by-
     200 mode, so that mode can display only two colors at a time.


                  Bit fields in one byte
     ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
     ³           ³           ³           ³           ³
     ³  0     0  ³  0     1  ³  1     0  ³  1     1  ³
     ³           ³           ³           ³           ³
     ÀÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÁÄÄÄÄÄÅÄÄÄÄÄÙ
           ³           ³           ³           ³
         ÚÄÄ¿       ÚÄÄ¿       ÚÄÄ¿       ÚÄÄ¿
         ³   ³       ³±±±³       ³²²²³       ³ÛÛÛ³ Pixels on screen
         ÀÄÄÄÙ       ÀÄÄÄÙ       ÀÄÄÄÙ       ÀÄÄÄÙ
     a.

                  Bit fields in one byte
     ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
     ³           ³           ³           ³           ³
     ³  0     0  ³  0     1  ³  1     0  ³  1     1  ³
     ³           ³           ³           ³           ³
     ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
        ³     ³     ³     ³     ³     ³     ³     ³
      ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿ ÚÄÄ¿
      ³   ³ ³   ³ ³   ³ ³±±±³ ³±±±³ ³   ³ ³±±±³ ³±±±³ Pixels on screen
      ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ ÀÄÄÄÙ
     b.

     Figure 4-1.  Pixel mapping in CGA graphics modes.


     The pixel data is mapped in two interleaved halves of the CGA's 16 KB
     video buffer. Data for the 100 even-numbered scan lines starts at
     B800:0000, and data for the odd-numbered scan lines starts at
     B800:2000 (see Figure 4-2). If the scan lines are numbered
     consecutively from 0, the half of the video buffer in which the nth
     scan line is represented can be determined by calculating n MOD 2.

       ÉÍÍÍ»     This two-way buffer interleave lets the CGA's CRT
       º T º     Controller display 200 lines of graphics data without
       º I º     overflowing the 7-bit CRTC vertical timing registers. In
       º P º     CGA graphics modes, the CRTC is set up to display 100 rows
       ÈÍÍÍ¼     of "characters," each two scan lines high. The top (even)
                 line of each character is derived from the first half of
                 the video buffer, and the bottom (odd) line is read from
                 the second half of the buffer.


     B800:0000 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                             ÚÄÄÄÄÄÄÄÄÄ
               ³                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Scan line 0 ³ÛÛÛÛÛÛÛÛÛ
          0050 ÃÄÄÄÄÄÄVÄÄÄÄÄÄÄÄÄÄÄÄ´                             ³°°°°D°°°°
               ³      i            ÃÄÄÄÄÄÄ¿  ÚÄÄÄÄÄ Scan line 1 ³ÛÛÛÛiÛÛÛÛ
          00A0 ÃÄÄÄÄÄÄdÄÄÄÄÄÄÄÄÄÄÄÄ´      ³  ³                   ³°°°°s°°°°
               ³      e            ÃÄÄÄÄ¿ ÀÄÄÅÄÄÄÄÄ Scan line 2 ³ÛÛÛÛpÛÛÛÛ
          00F0 ÀÄÄÄÄÄÄoÄÄÄÄÄÄÄÄÄÄÄÄÙ    ³    ³                   ³°°°°l°°°°
               ³                   ³    ³    ³  ÚÄÄ Scan line 3 ³ÛÛÛÛaÛÛÛÛ
                Ä Ä Ä B Ä Ä Ä Ä Ä Ä     ³    ³  ³                ³°°°°y°°°°
               ³      u            ³    ÀÄÄÄÄÅÄÄÅÄÄ Scan line 4 ³ÛÛÛÛÛÛÛÛÛ
                Ä Ä Ä f Ä Ä Ä Ä Ä Ä          ³  ³                ³°°°°°°°°°
               ³      f            ³         ³  ³ Ú Scan line 5 ³ÛÛÛÛÛÛÛÛÛ
     B800:2000 ÚÄÄÄÄÄÄeÄÄÄÄÄÄÄÄÄÄÄÄ¿         ³  ³ ³
               ³      r            ÃÄÄÄÄÄÄÄÄÄÙ  ³ ³
          2050 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´            ³ ³
               ³                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÙ ³
          20A0 ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´              ³
               ³                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
          20F0 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               ³                   ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä 
               ³                   ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä 
               ³                   ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä 

     Figure 4-2.  Video buffer interleave in CGA graphics modes.


Hercules Graphics Card

     In 720-by-348 graphics mode on the HGC and HGC+, pixel representation
     is similar to that in the CGA's 640-by-200 2-color graphics mode. One
     bit represents each pixel, so only two "colors" (pixel on or pixel
     off) are available.

     However, the HGC's 348 90-byte lines of pixel data are interleaved
     using four separate areas of the video buffer (see Figure 4-3), each
     containing 87 (348 / 4) lines of data. With this buffer organization,
     the area in the buffer in which the nth scan line is represented can
     be determined by n MOD 4.

     On Hercules video adapters, the four-way interleave allows the CRTC to
     be programmed to display 87 rows of characters which are four scan
     lines high. (See Listing 2-4 in Chapter 2.) Each of the four scan
     lines in a "character" is read from the corresponding location in one
     of the four interleaved portions of the video buffer.


     B000:0000 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                            ÚÄÄÄÄÄÄÄÄÄ
               ³                   ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄ Scan line 0 ³ÛÛÛÛÛÛÛÛÛ
          005A ÃÄÄÄÄÄÄÄÄVÄÄÄÄÄÄÄÄÄÄ´                            ³°°°°D°°°°
               ³        i          ÃÄ¿  ÚÄÄÄÄÄÄÄÄÄ Scan line 1 ³ÛÛÛÛiÛÛÛÛ
          00B4 ÀÄÄÄÄÄÄÄÄdÄÄÄÄÄÄÄÄÄÄÙ ³  ³                       ³°°°°s°°°°
               ³        e          ³ ³  ³    ÚÄÄÄÄ Scan line 2 ³ÛÛÛÛpÛÛÛÛ
                Ä Ä Ä Ä o Ä Ä Ä Ä Ä  ³  ³    ³                  ³°°°°l°°°°
               ³                   ³ ³  ³ ÚÄÄÅÄÄÄÄ Scan line 3 ³ÛÛÛÛaÛÛÛÛ
                Ä Ä Ä Ä B Ä Ä Ä Ä Ä  ³  ³ ³  ³                  ³°°°°y°°°°
               ³        u          ³ ÀÄÄÅÄÅÄÄÅÄÄÄÄ Scan line 4 ³ÛÛÛÛÛÛÛÛÛ
     B000:2000 ÚÄÄÄÄÄÄÄÄfÄÄÄÄÄÄÄÄÄÄ¿    ³ ³  ³                  ³°°°°°°°°°
               ³        f          ÃÄÄÄÄÙ ³ÚÄÅÄÄÄÄ Scan line 5 ³ÛÛÛÛÛÛÛÛÛ
          205A ÃÄÄÄÄÄÄÄÄeÄÄÄÄÄÄÄÄÄÄ´      ³³ ³                  ³°°°°°°°°°
               ³        r          ÃÄÄÄÄÄÄÅÙ ³  ÚÄ Scan line 6 ³ÛÛÛÛÛÛÛÛÛ
          20B4 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ      ³  ³  ³               ³°°°°°°°°°
               ³                   ³   ÚÄÄÅÄÄÅÄÄÅÄ Scan line 7 ³ÛÛÛÛÛÛÛÛÛ
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä    ³  ³  ³  ³
               ³                   ³   ³  ³  ³  ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä    ³  ³  ³  ³
               ³                   ³   ³  ³  ³  ³
     B000:4000 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³  ³  ³  ³
               ³                   ÃÄÄÄÅÄÄÅÄÄÙ  ³
          405A ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ³  ³     ³
               ³                   ÃÄÄÄÅÄÄÅÄÄÄÄÄÙ
          40B4 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ³  ³
               ³                   ³   ³  ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä    ³  ³
               ³                   ³   ³  ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä    ³  ³
               ³                   ³   ³  ³
     B000:6000 ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³  ³
               ³                   ÃÄÄÄÅÄÄÙ
          605A ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´   ³
               ³                   ÃÄÄÄÙ
          60B4 ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
               ³                   ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä 
               ³                   ³
                Ä Ä Ä Ä Ä Ä Ä Ä Ä Ä 

     Figure 4-3.  Video buffer interleave in Hercules graphics mode.


Enhanced Graphics Adapter

     When the EGA is configured to emulate a CGA graphics mode, pixels are
     mapped in the video buffer just as they would be on the CGA. However,
     in the EGA's native graphics modes (200-line 16-color modes and all
     350-line modes), pixels are always mapped eight to a byte.

     This mapping is dictated by the architecture of the EGA's video
     buffer. The 256 KB video buffer consists of four 64 KB maps, or
     parallel banks of RAM. The maps are parallel in the sense that they
     occupy the same range of addresses in the CPU's address space; the
     EGA's Sequencer and Graphics Controller allow the maps to be accessed

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     either individually or in parallel (more about this in Chapter 5).

     A pixel's value is determined by the values of the corresponding bits
     at the same byte offset and bit offset in each map (see Figure 4-4).
     For this reason, in graphics modes, the four maps are called bit
     planes. You might imagine each pixel's value as the result of
     concatenating one bit from the same location in each bit plane.

       ÉÍÍÍ»     The relationship of memory maps to bit planes is altered
       º T º     in 350-line graphics modes on an IBM EGA equipped with
       º I º     only 64 KB of video RAM. (To bring IBM's original EGA up
       º P º     to 256 KB, you must install a piggyback board, called the
       ÈÍÍÍ¼     Graphics Memory Expansion Card.) When you use INT 10H
                 function 00H to select 640-by-350 graphics modes (mode
                 0FH or 10H) on an EGA with a 64 KB video buffer, video
                 buffer address decoding is altered so that even-numbered
                 addresses in the buffer reference the even-numbered maps
                 and odd-numbered addresses refer to odd-numbered maps
                 (see Figure 4-5).

                 In this way the four video buffer maps are chained
                 together, with maps 0 and 1 forming bit plane 0 and maps
                 2 and 3 forming bit plane 2. Routines that access pixels
                 in the video buffer must accommodate this relationship
                 between the bit planes and buffer addresses.


                   ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
Bit          Map 3 ³  1  ³  1  ³  0  ³  0  ³  0  ³  0  ³  1  ³  1  ³
fields in          ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
correspond-         ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ
ing byte         ÚÄÄÄÄÚÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄ¿
in each    Map 2 ³  0  ³  1  ³  0  ³  1  ³  0  ³  0  ³  1  ³  0  ³
map              ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ
                  ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ
               ÚÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄ¿
         Map 1 ³  1  ³  0  ³  1  ³  0  ³  1  ³  0  ³  0  ³  1  ³
               ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ     Color
                ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ        Plane
             ÚÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄ¿      Enable
       Map 0 ³  1  ³  0  ³  1  ³  1  ³  0  ³  1  ³  1  ³  0  ³    register
             ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÙÚÄÄÄÄÄÄÄÄÄÄ¿
                                                      ³   0111   ³
Pixel          1011  1100  0011  0101  0010  0001  1101  1010 ÀÄÄÄÄÄÂÄÄÄÄÙ
values          ³     ³     ³     ³     ³     ³     ³     ³   ÄÄÄÄÄÙ
                                                   
AND with       0011  0100  0011  0101  0010  0001  0101  0010
Color Plane     ³     ³     ³     ³     ³     ³     ³     ³
Enable                                             
               ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿
Pixels on      ³²³   ³Û³   ³²³   ³Û³   ³±³   ³°³   ³Û³   ³±³
screen         ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ

     Figure 4-4.  Pixel mapping in native EGA graphics modes.


Bit fields
in corres-     ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
ponding   Map 2³  0  ³  1  ³  0  ³  1  ³  0  ³  0  ³  1  ³  0  ³
byte in        ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙ      Color
each map        ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ         Plane
             ÚÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄ¿       Enable
        Map 0³  1  ³  0  ³  1  ³  1  ³  0  ³  1  ³  1  ³  0  ³     register
             ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÙÚÄÄÄÄÄÄÄÄÄÄÄ¿
                                                      ³    0101   ³
Pixel          01    10    01    11    00    01    11    00   ÀÄÄÄÄÄÂÄÄÄÄÄÙ
values          ³     ³     ³     ³     ³     ³     ³     ³   ÄÄÄÄÄÙ
                                                   
AND with bits  01    10    01    11    00    01    11    00   Note: Bits
2 and 0 of      ³     ³     ³     ³     ³     ³     ³     ³   2 and 0 mask
Color Plane     ³     ³     ³     ³     ³     ³     ³     ³   pixel values.
Enable          ³     ³     ³     ³     ³     ³     ³     ³   Bits 3 and 1
                                                      should be 0.
Pixels on      ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿
screen         ³±³   ³²³   ³±³   ³Û³   ³ ³   ³±³   ³Û³   ³ ³
               ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ
a.


Bit fields
in corres-     ÚÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄÂÄÄÄÄÄ¿
ponding   Map 3³  1  ³  1  ³  0  ³  0  ³  0  ³  0  ³  1  ³  1  ³
byte in        ÀÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÁÄÄÂÄÄÙColor
each map        ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   ÚÄÙ   Plane
             ÚÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄÂÄÄÄÄ¿  Enable
        Map 1³  1  ³  0  ³  1  ³  0  ³  1  ³  1  ³  0  ³  1  ³  register
             ÀÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÁÄÄÄÄÄÙÚÄÄÄÄÄÄÄÄÄÄÄ¿
                                                      ³   0101    ³
Pixel          11    10    01    00    01    01    10    11   ÀÄÄÄÄÄÂÄÄÄÄÄÙ
values          ³     ³     ³     ³     ³     ³     ³     ³   ÄÄÄÄÄÙ
                                                   
AND with bits  11    10    01    00    01    01    10    11   Note: Bits
2 and 0 of      ³     ³     ³     ³     ³     ³     ³     ³   2 and 0 mask
Color Plane     ³     ³     ³     ³     ³     ³     ³     ³   pixel values.
Enable          ³     ³     ³     ³     ³     ³     ³     ³   Bits 3 and 1
                                                      should be 0.
Pixels on      ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿   ÚÄ¿
screen         ³Û³   ³²³   ³²³   ³ ³   ³±³   ³±³   ³²³   ³Û³
               ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ   ÀÄÙ
b.

     Figure 4-5.  Video buffer maps in 350-line graphics modes (EGA with 64
     KB video RAM). Pixel values at even addresses are stored in maps 0 and
     2 (Figure 4-5a); pixels at odd addresses are stored in maps 1 and 3
     (Figure 4-5b).


     In native EGA graphics modes, there is no line-by-line interleaving of
     the pixel data in the video buffer, as in CGA and HGC graphics modes.
     Instead, rows of pixels are mapped linearly, just as rows of
     characters are mapped linearly in alphanumeric video modes.


Hercules InColor Card

     In its 720-by-348 graphics mode, the InColor Card's video buffer has
     four parallel maps organized as four parallel bit planes. As on the
     EGA, a pixel's value is determined by concatenating the corresponding
     bits in each of the bit planes. However, video buffer addressing is
     not linear, as it is on the EGA.

     Pixels are stored in the InColor Card's video buffer using the same
     four-way interleave that the HGC and HGC+ use. In the buffer, 348
     lines of 90 bytes (720 pixels) are mapped in a four-way interleave
     starting at B000:0000. The buffer also contains two video pages (as on
     the monochrome HGC), at B000:0000 and B000:8000. This aspect of the
     InColor Card's design preserves its symmetry with Hercules monochrome
     graphics cards but differentiates it from the EGA.


MCGA and VGA

     The PS/2 video subsystems support three graphics modes not found on
     earlier PC video adapters. The 640-by-480 2-color mode (MCGA and VGA)
     and 640-by-480 16-color mode (VGA only) resemble the native EGA
     graphics modes: Both use a linear bit map starting at A000:0000. A
     similar linear pixel map also is used in 320-by-200 (MCGA and VGA)
     256-color mode, with one important difference: Each byte in the video
     buffer represents one pixel (see Figure 4-6). Since there are eight
     bits to a byte, each pixel can have any of 256 (2^8) different colors.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿                  ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³   8-bit pixel value  ³   Logical AND    ³      Video DAC Mask      ³
     ³                      ÃÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄ´                          ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ         ³        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                      
                        ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                        ³        Video DAC         ³
                        ³   color register 0-0FFH  ³
                        ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÙ
                                      ³
                                      
                    18-bit analog output to video display
                     (6 bits each for red, green, blue)

     Figure 4-6.  Color selection in MCGA and VGA 320-by-200 256-color
     mode.


       ÉÍÍÍ»     On the VGA, 640-by-480 2-color mode is nearly identical to
       º T º     640-by-480 16-color mode. All four bit planes remain
       º I º     active in the 2-color mode even though one bit plane is
       º P º     sufficient to store a full screen of pixels. The only
       ÈÍÍÍ¼     difference between the two modes is that the video BIOS
                 makes only two palette colors available in the 2-color
                 mode, whereas it sets up 16 palette colors in the 16-color
                 mode.


Pixel Coordinates


     In graphics modes, the video buffer can be thought of as a flat, two-
     dimensional array of pixels with its origin at the upper left corner.
     What is visible on the screen is a subset of the pixels represented in
     the buffer. On the CGA, the video buffer can contain only one
     screenful of pixels, so the first byte in the buffer represents the
     pixels in the screen's upper left corner. On the EGA, MCGA, and VGA,
     however, the video buffer can store several screenfuls of pixels. You
     can thus select which portion of the video buffer appears on the
     screen.

     Every pixel on the screen can be identified by a unique pair of (x,y)
     coordinates relative to the screen's upper left corner. Each (x,y)
     pair also corresponds to a particular byte offset in the video buffer
     and a bit offset in that byte. Thus, given a pixel's (x,y) coordinates
     on the screen, you can compute where in the video buffer the pixel is
     represented.

     Converting from pixel coordinates to the corresponding byte and bit
     offsets is one of the most frequent operations in IBM video graphics
     programming. The program examples in Listings 4-1 through 4-5
     demonstrate how to do this efficiently and in a uniform manner.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-1.  Computing a pixel's address in 320-by-200 4-color


Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-2.  Computing a pixel's address in 640-by-200 2-color

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Transforming pixel coordinates to a buffer offset involves simple
     logic. Begin by calculating the offset of the start of pixel row y.
     (For CGA and Hercules graphics modes, this calculation accounts for
     the interleaving of the video buffer.) To this value, add the byte
     offset of the xth pixel in the row. Finally, add the byte offset of
     the start of the displayed portion of the video buffer to obtain the
     final byte offset of the pixel.

     PixelByteOffset = RowOffset(y) + ByteOffset(x) + OriginOffset

     The bit offset of the pixel within the byte that contains its value
     depends only on the number of pixels represented in each byte of the
     video buffer. You could express the relationship this way:

     PixelBitOffset = PixelsPerByte - (x MOD PixelsPerByte) - 1

     However, it is more practical to represent a pixel's bit offset as a
     bit mask rather than as an ordinal bit number. This can be done easily
     with a table lookup (for example, an assembler XLAT instruction) or
     with a logical shift instruction. (This is why Listings 4-1 through
     4-4 return the bit offset as a number of bits to shift.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-3.  Computing a pixel's address in Hercules graphics mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-4.  Computing a pixel's address in CGA and VGA graphics
     modes.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     Here is a high-level example of a pixel coordinate transformation for
     the CGA's 320-by-200 4-color graphics mode. As Figure 4-1a shows,
     each byte in the video buffer contains four pixels. At four pixels per
     byte, 80 bytes of data represent one row of 320 pixels. The origin of
     the screen--that is, the byte offset of the displayed portion of the
     buffer--is 0, since the CGA video buffer contains only one screenful
     of pixels.

     int PixelsPerByte = 4;
     int BytesPerRow = 80;
     int OriginOffset = 0;
     static int Masks[] = { 0xC0, 0x30, 0x0C, 0x03 };

     unsigned int x,y;
     unsigned int ByteOffset,BitMask;

     /* buffer interleave (0 or 0x2000) */
     ByteOffset = (y & 1) << 13;

     /* offset of start of row */
     ByteOffset += BytesPerRow * (y/2);

     /* byte offset in screen */
     ByteOffset += (x / PixelsPerByte) % BytesPerRow;

     /* byte offset in video buffer */
     ByteOffset += OriginOffset;

     BitMask = Masks[x % PixelsPerByte];

     The same routine in assembly language is much more efficient, because
     all arithmetic can be done in registers and register halves (refer to
     Listing 4-1). Also, if you know that the number of bytes per row of
     pixels is a constant, you  can further increase performance by
     performing multiplication and division as a sequence of bit shifts.

     For example, in Listing 4-5, the y-coordinate is multiplied by 320
     through a series of logical shift operations instead of a single MUL
     instruction. The resulting routine runs about 40 percent faster on the
     8086-based PS/2 Model 30 and about 10 percent faster on the 80286-
     based PS/2 Model 60. This optimization complicates the assembly code
     somewhat, but the speed gained is worth the effort--low-level routines
     such as those in Listings 4-1 through 4-5 may execute many thousands
     of times in a graphics-oriented application.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-5.  Computing a pixel's address in 320-by-200 256-color
     mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Pixel Coordinate Scaling

     One characteristic of most IBM graphics modes is that horizontal pixel
     resolution differs from vertical pixel resolution. For example, in a
     640-by-200 mode, a typical 200-line color monitor displays about 70
     pixels per horizontal inch, but only about 30 pixels per vertical
     inch.

     This discrepancy complicates the mapping of pixels in the display
     buffer to screen locations, as is shown in Figure 4-7. For example,
     in a 640-by-200 mode, a line drawn between the pixel at (0,0) in the
     screen's upper left corner and the pixel at (100,100) has a
     mathematical slope of 1, so you would expect it to be displayed at a
     45-degree angle from the display's top and left edges. However, the
     displayed line (line a, Figure 4-7) is "compressed" in the horizontal
     direction.

     Displaying a line at a 45-degree angle requires scaling the pixel
     coordinates to account for the discrepancy in vertical and horizontal
     resolution. In a 640-by-200 mode, the horizontal scaling factor is
     about 2.4 (horizontal resolution / vertical resolution). In the
     example, you would scale the x-coordinates of the endpoints to 0 (0 *
     2.4) and 240 (100 * 2.4). The scaled line (line b, Figure 4-7), with
     endpoints at (0,0) and (240,100), appears at a 45-degree angle on the
     screen.

     You must scale the (x,y) coordinates of all pixels in all geometric
     figures in all graphics modes--unless, of course, the scaling factor
     happens to be 1. Otherwise, squares appear as rectangles and circles
     as ellipses. Furthermore, you must adjust the scaling factor for the
     horizontal and vertical resolutions of each graphics mode. Figure 4-8
     is a table of the horizontal-to-vertical scaling ratios for graphics
     modes on IBM video subsystems with typical monitors.


     ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
     ³ (O,O)                            ³
     ³   ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿   ³
     ³   ³³³                        ³   ³
     ³   ³³ÀÄÄÄÄÄÄÄÄÄ¿              ³   ³
     ³   ³ÀÄÄ¿       ³b.            ³   ³
     ³   ³ a.³       ³(240,100)     ³   ³
     ³   ³(100,100)                 ³   ³
     ³   ³                          ³   ³
     ³   ³                          ³   ³
     ³   ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ   ³
     ³                                  ³
     ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

     Figure 4-7.  Pixel coordinate scaling in 640-by-200 graphics.


BIOS Mode   Mode                     Scaling Factor
Number      Description              (horizontal/vertical)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
4,5         320-by-200 4-color       1.20
6           640-by-200 2-color       2.40
0DH         320-by-200 16-color      1.20
0EH         640-by-200 16-color      2.40
0FH         640-by-350 monochrome    1.26 (monochrome monitor)
10H         640-by-350 16-color      1.37
11H         640-by-480 2-color       1.00
12H         640-by-480 16-color      1.00
13H         320-by-200 256-color     2.40
            720-by-348 (Hercules)    1.43 (monochrome monitor)
     Figure 4-8.  Pixel scaling values for PC and PS/2 graphics modes. An
     aspect ratio of 1.33 (4:3) for color monitors, 1.45 for monochrome
     monitors, is assumed.


Aspect Ratio

     A related programming concern is the screen's aspect ratio--the ratio
     of a screen's width to its height. The color monitors commonly used
     with IBM video subsystems have aspect ratios of about 1.33 (4:3); for
     the typical green monochrome monitor, the aspect ratio is about 1.45.
     Because the screen is rectangular instead of square, the maximum
     potential width of a screen image exceeds its maximum potential
     height. This limitation must always be considered in scaling pixel
     coordinates.

       ÉÍÍÍ»     One attractive feature of the MCGA, the VGA, and other
       º T º     video subsystems that offer 640-by-480 resolution is that
       º I º     horizontal resolution and vertical resolution are the same
       º P º     on a display with an aspect ratio of 4:3. You can think of
       ÈÍÍÍ¼     the pixels in this situation as being "square." With
                 "square" pixels, mapping the video buffer to the screen is
                 simpler because the pixel coordinate scaling factor is 1.


Pixel Display Attributes


     In general, pixel values determine video attributes--in other words,
     the bits that represent a pixel in the video buffer determine how the
     pixel looks on the screen. The way that pixel values are decoded in

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
     graphics modes is similar to the way that alphanumeric attributes are
     decoded. But in graphics modes, pixel values may range from one
     through eight bits, while alphanumeric attributes are four bits wide.


Color Graphics Adapter

     In 640-by-200 2-color mode, one bit represents each pixel. If the bit
     is 0, the pixel is displayed as black. If the bit is 1, the pixel is
     displayed with the color specified in bits 0 through 3 of the CGA's
     Color Select register (port 3D9H). This is the same register that
     specifies the overscan color in alphanumeric modes. If you change
     video modes by directly programming the CGA's CRTC and Mode Control
     registers, you should avoid spurious border colors or pixel colors by
     programming the Color Select register as well.

     You can use INT 10H function 0BH to select the displayed color of
     nonzero pixels in 640-by-200 2-color mode (see Listing 4-6). This BIOS
     function stores a color value in the Color Select register and updates
     the variable CRT_PALETTE in the Video Display Data Area at 0040:0066.
     If you bypass the video BIOS and program the Color Select register
     directly, you should also update CRT_PALETTE.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-6.  Foreground color in CGA 640-by-200 2-color graphics.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     In 320-by-200 4-color modes, two bits represent each pixel, so pixel
     values can range from 0 through 3. Pixels with the value 0 are
     displayed with the color value stored in the Color Select register at
     port 3D9H. A quirk of the CGA is that the Color Select register value
     determines both the overscan (border) color and the color for pixel
     value 0. This means you cannot specify a border color independently of
     the background color on the CGA in this video mode.

     The colors displayed for pixels with nonzero values are taken from one
     of three hardware palettes (see Figure 4-9). The palette is selected
     by the values of bit 5 of the Color Select register (port 3D9H) and of
     bit 2 of the Mode Control register at port 3D8H (Listing 4-7). If bit
     2 of the Mode Control register is 1, the palette comprises cyan, red,
     and white. If this bit is 0, bit 5 of the Color Select register
     selects either green, red, and yellow (if bit 2 in the Color Select
     register is 0), or cyan, violet, and white (if bit 2 in the Color
     Select register is 1). In effect, setting bit 2 in the Color Select
     register adds blue to the palette; that is, green plus blue produces
     cyan, red plus blue produces violet, and yellow plus blue produces
     white.

       ÉÍÍÍ»     Setting bit 2 of the CGA's Mode Control register to 1
       º T º     disables the color burst component of the adapter's
       º I º     composite video output signal. If you use a black-and-
       º P º     white display, appropriate shades of gray are generated
       ÈÍÍÍ¼     for the four possible pixel values when bit 2 is set to 1.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Bit 2 of Mode Control register = 0
Pixel Value                    Color Displayed
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Bit 5 of Color Select register = 0
1                              Green
2                              Red
3                              Yellow

Bit 5 of Color Select register = 1
1                              Cyan
2                              Violet
3                              White
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Bit 2 of Mode Control register = 1
Pixel Value                    Color Displayed
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
1                              Cyan
2                              Red
3                              White

     Figure 4-9.  Palettes available in CGA 320-by-200 4-color mode.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-7.  Four-color palettes in CGA 320-by-200 4-color mode.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     You can use INT 10H functions to select among the three 4-color
     palettes. The video BIOS assigns two video mode numbers to 320-by-200
     4-color graphics mode: In BIOS mode 4, bit 2 of the Mode Control
     register is 0, and in mode 5, bit 2 is set to 1. Thus, to select the
     cyan-red-white palette, use INT 10H function 0 to set mode 5. To
     select the other two palettes, use INT 10H function 0 to set mode 4,
     and then call INT 10H function 0BH to choose either green-red-yellow
     or cyan-violet-white, as shown in Listing 4-8.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Listing 4-8.  Four-color palettes in CGA 320-by-200 4-color mode using
     video BIOS.

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


     You can select high-intensity colors in the 320-by-200 4-color palette
     by setting bit 4 of the Color Select register to 1. When this bit is
     0, the same four colors are displayed with normal intensity.


Hercules Graphics Card

     Life is easy with an HGC as far as graphics attributes are concerned.
     In the 720-by-348 monochrome graphics mode on the HGC and HGC+, one
     bit represents each pixel. If the bit is set to 1, the pixel is
     displayed. If the bit is set to 0, the pixel is not displayed.


Enhanced Graphics Adapter

     Although the EGA supports a number of graphics modes with pixel values
     ranging from 1 to 4 bits, it decodes pixel values in a straightforward
     manner. As in alphanumeric modes, each pixel's value is masked by the
     value in the Attribute Controller's Color Plane Enable register; the
     resulting 4-bit value selects one of the Attribute Controller's 16
     palette registers. Thus, a pixel's displayed attribute is derived from
     the palette register that corresponds to the pixel value.

     When you use INT 10H function 0 to select an EGA video mode, the BIOS
     routine loads a default set of color values into the palette registers
     (see Figure 4-10). The actual values depend on the video mode, but
     each set maps the palette registers so that the color displayed for a
     given pixel value is the same as a CGA would display. Using this
     function improves the portability of programs between the CGA and the
     EGA, since a program that never touches the palette registers can run
     with the same set of colors on both adapters.

       ÉÍÍÍ»     The BIOS default palette register values for 320-by-200
       º T º     and 640-by-200 16-color modes are correct for 200-line
       º I º     monitors but incorrect for some EGA-compatible monitors.
       º P º     IBM's Enhanced Color Display converts the 4-bit default
       ÈÍÍÍ¼     color values in 200-line graphics modes (see Figure 4-10)
                 to 6-bit color values that emulate the 16 CGA colors.
                 Unfortunately, not all EGA-compatible monitors do this.
                 Thus, if you use INT 10H function 0 to invoke these modes
                 (mode numbers 0DH and 0EH), you generally should program
                 the palette registers with an appropriate set of values,
                 such as the default set used in 640-by-350 16-color mode.


     CGA Emulation Modes
     In 640-by-200 2-color mode, when bit 3 of the Attribute Controller
     Mode Control register (10H) is 0, a pixel value of 0 designates
     palette register 0, and a pixel value of 1 designates palette register
     1. When Mode Control bit 3 is 1, palette registers 8 and 9 are used.
     With a CGA-compatible display, these four palette registers can
     contain any of the 16 displayable color values. With an EGA-compatible
     350-line monitor, these registers can contain any four of the 64
     displayable color values.


350-Line 16-Color Modes
Palette Register  Color Value          Attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H               00H                  Black
01H               01H                  Mid-intensity blue
02H               02H                  Mid-intensity green
03H               03H                  Mid-intensity cyan
04H               04H                  Mid-intensity red
05H               05H                  Mid-intensity violet
06H               14H                  Brown
07H               07H                  Mid-intensity white
08H               38H                  Low-intensity white (gray)
09H               39H                  High-intensity blue
0AH               3AH                  High-intensity green
0BH               3BH                  High-intensity cyan
0CH               3CH                  High-intensity red
0DH               3DH                  High-intensity violet
0EH               3EH                  High-intensity yellow
0FH               3FH                  High-intensity white

200-Line 16-Color Modes
Palette Register  Color Value          Attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H               00H                  Black
01H               01H                  Blue
02H               02H                  Green
03H               03H                  Cyan
04H               04H                  Red
05H               05H                  Violet
06H               06H                  Yellow (brown)
07H               07H                  White
08H               10H                  Black (gray)
09H               11H                  High-intensity blue

Programmer's Guide to PC and PS/2 Video Systems
Copyright (c) 1987 by Richard Wilton. 
All Rights Reserved.
0AH               12H                  High-intensity green
0BH               13H                  High-intensity cyan
0CH               14H                  High-intensity red
0DH               15H                  High-intensity violet
0EH               16H                  High-intensity yellow
0FH               17H                  High-intensity white

640-by-350 Monochrome Graphics
Palette Register  Color Value          Attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H               00H                  Not displayed
01H               08H                  Normal intensity
04H               18H                  High intensity
05H               18H                  High intensity
08H               00H                  Not displayed
09H               08H                  Normal
0CH               00H                  Not displayed
0DH               18H                  High intensity
     Figure 4-10.  Default EGA and VGA palette register values.


     In 320-by-200 4-color mode, each of the four possible pixel values (0
     through 3) designates a corresponding palette register. When bit 3 in
     the Attribute Controller Mode Control register is 0, palette registers
     0-3 are used; when bit 3 is 1, palette registers 8-0BH are used. With
     a CGA-compatible monitor, you can store any eight of the 16
     displayable color values in these palette registers. With an EGA-
     compatible monitor, you can use any eight of the 64 displayable color
     values in these registers.

     In both CGA emulation modes, the video BIOS initializes the palette
     registers with default color values that match the colors in the CGA
     hardware palettes. In 640-by-200 2-color mode, the default colors are
     black, white, and intense white. In 320-by-200 4-color modes, the BIOS
     supports the green-red-yellow and cyan-violet-white palettes in normal
     and high intensities.


     16-Color Modes
     In 320-by-200, 640-by-200, and 640-by-350 16-color modes, each 4-bit
     pixel value designates one of the 16 palette registers. For a CGA-
     compatible monitor, the palette registers can contain the usual 16
     colors, but with an EGA-compatible monitor, you can specify any of the
     64 displayable colors in each palette register.


     Monochrome Graphics
     There are two bits per pixel in the EGA's 640-by-350 monochrome
     graphics mode, so pixel values can range from 0 through 3. However,
     this graphics mode uses only even-numbered bit planes, so the EGA's
     Attribute Controller interprets only the even-numbered bits of the
     usual 4-bit pixel value. Thus, bits 0 and 1 of a 2-bit monochrome
     pixel value designate bits 0 and 2 of the corresponding 4-bit palette
     register number. (Bits 1 and 3 of the palette register number are
     always 0.) Thus, the four possible pixel values--0, 1, 2, and 3--
     actually reference palette registers 0, 1, 4, and 5 respectively (see
     Figure 4-11).


Pixel Value        Corresponding Palette Register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
0 (00B)            0 (0000B)
1 (01B)            1 (0001B)
2 (10B)            4 (0100B)
3 (11B)            5 (0101B)
     Figure 4-11.  Pixel values and palette registers in 640-by-350
     monochrome graphics.


       ÉÍÍÍ»     On EGAs with only 64 KB of video RAM, the odd bit planes
       º T º     represent pixels at odd buffer addresses, and the even bit
       º I º     planes represent pixels at even buffer addresses (see
       º P º     Figure 4-5). In this situation, pixel values in 640-by-
       ÈÍÍÍ¼     350 monochrome and 640-by-350 4-color graphics modes are
                 two bits in size, but bits 0 and 2 are used for pixels at
                 even byte addresses, while bits 1 and 3 are used for
                 pixels at odd byte addresses.

     Monochrome pixels can be undisplayed (palette register value 0), can
     be displayed with normal intensity (08H), or can be displayed with
     high intensity (18H). INT 10H function 00H loads the palette registers
     with a default set of monochrome values whenever you select video mode
     0FH (see Figure 4-11).


     Blinking
     In native graphics modes on the EGA (as well as on the VGA), pixels
     can have a blinking attribute. As in alphanumeric modes, you select
     blinking by setting the Enable Blink bit of the Attribute Controller's
     Mode Control register (bit 3 of register 10H at port 3C0H) to 1. In
     16-color modes, this causes the adapter to interpret the high-order
     bit (bit 3) of each 4-bit pixel value as a blink attribute, in the
     same way the high-order bit of a character's attribute byte is used in
     alphanumeric modes. Thus, when the Enable Blink bit is set, pixels
     with values 8 through 0FH blink, and pixels with values 0 through 7 do
     not. In monochrome graphics mode, all pixels blink regardless of their
     value.

     However, the EGA blinks pixels differently in graphics modes than it
     blinks characters in alphanumeric modes. In graphics modes, pixels are
     blinked by alternately selecting two different palette registers for
     each pixel's value. The two registers are designated by turning bit 3
     of the pixel value on and off at the blink rate (about twice per
     second). Thus, pixels are blinked by alternating the values in the
     first eight palette registers (registers 00H through 07H) with the
     values in the second eight (08H through 0FH).

     For example, a pixel with a value of 0AH is blinked by repeatedly
     changing the value of bit 3 whenever the Enable Blink bit is set.
     Thus, the pixel's color alternates between that designated by palette
     register 0AH (1010B) and that in palette register 02H (0010B). If you
     use the set of BIOS default palette registers, this pixel blinks
     between green and high-intensity green.

     A peculiarity of the EGA's blinking attribute in color graphics modes
     is what happens to pixels with values from 0 through 7; that is, where
     bit 3 of the pixel value is 0. These pixels do not blink, but they are
     displayed as if bit 3 were 1. For example, if you use the BIOS default
     palette values, pixels displayed at lower intensity (pixel values 0
     through 7) become nonblinking pixels displayed at high intensity using
     palette registers 08H through 0FH.

     Thus, in using the blinking attribute in graphics modes, you should
     reprogram the palette registers each time you change the Enable Blink
     bit, to maintain a consistent set of colors. For example, the palette
     register values shown in Figure 4-12 might be useful in this context.
     This palette is designed for use as an alternative to the default BIOS
     palette (see Figure 4-10) when blinking is enabled. If this palette
     is used with the Enable Blink bit set to 1, all high-intensity pixels
     (pixel values 08H through 0FH) blink, but all normal-intensity pixels
     do not.


     Border Color
     As in alphanumeric modes, you can set the overscan (border) color by
     storing a color value in the Attribute Controller's Overscan Color
     register (register 11H, port 3C0H). Techniques for setting the border
     color are covered in Chapter 3.


Palette Register    Color Value    Attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
00H                 00H            Black (background)

01H                 39H±
02H                 3AH±
03H                 3BH±
04H                 3CH±ÄÄÄÄÄÄÄÄÄÄ(high-intensity colors)
05H                 3DH±
06H                 3EH±
07H                 3FH±

08H                 00H            Black (background)

09H                 01H±
0AH                 02H±
0BH                 03H±
0CH                 04H±ÄÄÄÄÄÄÄÄÄÄ(mid-intensity colors)
0DH                 05H±
0EH                 14H±
0FH                 07H±
     Figure 4-12.  Palette register values for blinking in 640-by-350
     16-color mode.

